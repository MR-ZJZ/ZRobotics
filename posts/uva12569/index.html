<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>UVa12569 | SonnyCalcr&#39;s Blog</title>
<meta name="keywords" content="Bilibili, 算法竞赛, UVa, 算法竞赛入门经典, BFS">
<meta name="description" content="UVa12569 解题思路及代码解析">
<meta name="author" content="Sonny Calcr">
<link rel="canonical" href="http://localhost:1313/posts/uva12569/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.31606b01ae31539001706d41fc833c993b1758dbed2a9d814f4563b7298aa9f6.css" integrity="sha256-MWBrAa4xU5ABcG1B/IM8mTsXWNvtKp2BT0VjtymKqfY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.png">
<link rel="mask-icon" href="http://localhost:1313/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/posts/uva12569/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">
<script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<meta property="og:url" content="http://localhost:1313/posts/uva12569/">
  <meta property="og:site_name" content="SonnyCalcr&#39;s Blog">
  <meta property="og:title" content="UVa12569">
  <meta property="og:description" content="UVa12569 解题思路及代码解析">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-21T23:56:38+08:00">
    <meta property="article:modified_time" content="2024-08-21T23:56:38+08:00">
    <meta property="article:tag" content="Bilibili">
    <meta property="article:tag" content="算法竞赛">
    <meta property="article:tag" content="UVa">
    <meta property="article:tag" content="算法竞赛入门经典">
    <meta property="article:tag" content="BFS">
      <meta property="og:image" content="https://i.postimg.cc/7hwBy7VS/calcr.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.postimg.cc/7hwBy7VS/calcr.png">
<meta name="twitter:title" content="UVa12569">
<meta name="twitter:description" content="UVa12569 解题思路及代码解析">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "UVa12569",
      "item": "http://localhost:1313/posts/uva12569/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UVa12569",
  "name": "UVa12569",
  "description": "UVa12569 解题思路及代码解析",
  "keywords": [
    "Bilibili", "算法竞赛", "UVa", "算法竞赛入门经典", "BFS"
  ],
  "articleBody": "前言 首先，建议大家读一下原题目，题目的内容这里就不放了，大家可以到这个地址去下载: https://vjudge.net/problem/UVA-12569，有些人可能说英文不太好，那么，也没关系，除了查字典，现在还可以使用这个翻译插件：沉浸式翻译，总之，现在英语语言层面的问题是不会有问题的。\n为什么我建议大家读原题目呢？虽然我们大家接触到这个题目可能都是通过刘汝佳的这本《算法竞赛入门经典》才选择去看的，但是，书中给出的描述都是很略的，简单讲一点，题目很重要的输入和输出样例数据，书上一般都是没有的，其他的细节更不必说。大概就这样。\n然后，我们来详细研究一下 UVa12569 这道题的思路和解析。\n这道题整体的思路是 BFS。然后代码参考(可能有我的微小调整)的是《算法竞赛入门经典-习题与解答》的配套代码，GitHub 地址为：https://github.com/sukhoeing/aoapc-bac2nd-keys。\n此外，如果我们想要更多的测试数据，这个 udebug 的网站也是必不可少的：https://www.udebug.com。本题的测试数据地址为：https://www.udebug.com/UVa/12569。\n同时，我的代码托管在了这个地址：https://github.com/sonnycalcr/aoapc-homework。\n首先，这道题很多人可能觉得简单，我说一下我的观点：对于初学者或者算法初阶的同学来讲，这道题还是有很多值得学习的部分的。\n接下来，我挑一些关键的代码讲一下，更详细的解释在代码的注释里面。\n注意，在具体看/写代码之前，我们首先要明确一个点，题目中的编号是从 1 开始递增的，而下面我们的程序都是从 0 开始递增的。\nPart1 先看数据结构，一个是 Node，\n1struct Node { 2 int from, to; 3 Node *next; 4}; Node 是表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点，主要是用来在 State 类型中表示 path，也就是当前的状态是由上一个状态从 from 移动了机器人/石头到 to 而转化过来的。\nPart2 再看 State，\n1struct State { 2 Node *path; // 路径 3 int g; // 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 \u003c= n \u003c= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头 4 int len; // 路径长度，到了当前状态已经经历的长度 5 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 6 inline bool operator[](size_t i) const { return g \u0026 (1 \u003c\u003c (i + 4)); } // 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头 7 inline void setRock(size_t i, bool val = true) { // 设置位置 i 上是否有石头 8 if (val) 9 g |= 1 \u003c\u003c (i + 4); // 位或操作来把第(i + 4)位来置 1 10 else 11 g \u0026= ~(1 \u003c\u003c (i + 4)); // 先取反，再用与操作来把第(i + 4)位来置 0 12 } 13 // 机器人的位置操作 14 inline int getP() const { return g \u0026 15; } // 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置 15 inline void setP(int p) { g = ((g \u003e\u003e 4) \u003c\u003c 4) | p; } // 设置机器人的位置，这里先右移再左移 4 位清除原有的数据 16}; 所谓的 State，就是当前的局面，由以下几个维度的数据构成，\npath 是路径，上面讲过了，其中保存了上一个状态转变到当前状态是移动了哪一个编号，然后又是移动到了哪一个编号，同时 next 指向了上一次状态的 path。 g 代表了整体的状态，其中，前 4 位(分别是：0, 1, 2, 3)二进制值作为一个整体可以转化成十进制，表示了当前机器人在哪个编号的位置；然后再往左取 16 位二进制 bit 位，其中每一位都代表了一个编号，比如，0 号位置的 bit 位是 (0 + 4)，也就是第 4 位，如果这一位为 1，则表示树中编号为 0 的位置上有石头，反之则没有，其它的编号依此类推。 len 表示从最原始的状态来到了当前的状态，一共走了多少步。 理解了上面的几个成员变量，就不难理解之后的几个成员函数了。\nPart3 我们再看输出运算符的重载，\n1// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的 2ostream \u0026operator\u003c\u003c(ostream \u0026os, Node *p) { 3 if (p == NULL) 4 return os; 5 os \u003c\u003c p-\u003enext \u003c\u003c p-\u003efrom + 1 \u003c\u003c \" \" \u003c\u003c p-\u003eto + 1 \u003c\u003c endl; // 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号 6 return os; 7} 这里我们要注意，因为 Node 实际上是用来表示 State 中的 path 的，所以，并且，我们是到了最后成功到达终点时(看代码 109 行)直接打印最终的那个 State 的 path 的，而每一个 path 指向的又是上一个 State 的 path，所以，这个输出重载就达到了输出从初始的状态移动到最终目标的全部路径的目的。\nPart4 然后，我们看一下尝试移动机器人或者石头的思路，在这之前，我们先再来看一下全局变量，\n1const int MAXN = 16; // 节点的最大数量是 16，根据题目中的条件得来 2vector\u003cint\u003e G[MAXN]; // 图的邻接矩阵表示，题目中简化成了树(无环图) 3MemPool\u003cNode\u003e pool; // 链表节点分配，用 MemPool 比较好管理内存 4// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置 5// O: 每一个石头的位置编号 6// VIS: 表示某个位置是否已经 visited 过了 7int n, m, S, T, O[MAXN], VIS[1 \u003c\u003c 19]; 这个注释比较清晰了，就不多讲了。然后，让我们进入正题，来看 tryMove 这个函数，\n1// 尝试移动在点 from 上的物体(机器人或者石头) 2void tryMove(const State \u0026s, int from, queue\u003cState\u003e \u0026q) { 3 int rp = s.getP(); // 获取当前状态下机器人的位置编号 4 for (auto to : G[from]) { 5 if ((to == rp) || s[to]) // to 和当前状态的机器人位置重合或者 to 的位置上有机器人 6 continue; 7 int ng = s.g; 8 if (from == rp) 9 ng = ((s.g \u003e\u003e 4) \u003c\u003c 4) | to; // 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置 10 else 11 ng ^= (1 \u003c\u003c (from + 4)), ng ^= (1 \u003c\u003c (to + 4)); // 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置 12 if (VIS[ng]) 13 continue; // 新的状态已经访问过 14 VIS[ng] = 1; // 标记访问 15 // 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node 16 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 17 } 18} 因为 G 是邻接矩阵，我们可以利用这个特点来进行 for 循环，遍历与 from 顶点所邻接的几个顶点，尝试去移动到这些位置，然后就是一系列的细节处理，看注释比较容易理解。\nPart5 下面我们来看最终的核心的代码，\n1// bfs 2void solve() { 3 // 定义并初始化原始的状态 4 State s; 5 _for(i, 0, m) s.setRock(O[i]); 6 s.setP(S); 7 queue\u003cState\u003e q; 8 q.push(s); 9 VIS[s.g] = 1; // 标记当前机器人和石头的状态已经被访问过 10 // bfs 一层一层地遍历 11 while (!q.empty()) { 12 const State \u0026st = q.front(); 13 int rp = st.getP(); 14 if (rp == T) { // 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数 15 cout \u003c\u003c st.len \u003c\u003c endl \u003c\u003c st.path; 16 return; 17 } 18 tryMove(st, rp, q); // 尝试移动机器人 19 _for(i, 0, n) if (st[i]) tryMove(st, i, q); // 尝试移动石头 20 q.pop(); 21 } 22 cout \u003c\u003c \"-1\" \u003c\u003c endl; // 无法到达目的地 23} 这里就是一个纯粹的 bfs，我们定义好了原始的状态之后，然后利用队列这个数据结构一圈一圈地往外进行波纹扩散性地遍历，队列中从前往后存放的分别是第 1 圈、第 2 圈…的数据，而且队列是先进先出(FIFO, First In First Out)，所以，我们可以暴力地遍历所有的情况，并且，可以保证，一旦第一次得到了想要的结果，那么，这个结果就是我们最终想要的结果。\n完整的代码和注释 以上就是关键的代码和解释了。其他的东西没什么好讲的。关于数据的输入和处理，上面也没有细讲，直接看注释即可。\n下面就是完整的代码和详细的注释：\n1#include 2#include 3#include 4#include 5#include 6#include 7 8#define _for(i, a, b) for (int i = (a); i \u003c (b); ++i) 9 10using namespace std; 11 12int readint() { 13 int x; 14 cin \u003e\u003e x; 15 return x; 16} 17 18template \u003ctypename T\u003e struct MemPool { 19 vector\u003cT *\u003e buf; 20 T *createNew() { 21 buf.push_back(new T()); 22 return buf.back(); 23 } 24 25 void dispose() { 26 for (int i = 0; i \u003c buf.size(); i++) 27 delete buf[i]; 28 buf.clear(); 29 } 30}; 31 32const int MAXN = 16; // 节点的最大数量是 16 33 34struct Node { // 表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点 35 int from, to; 36 Node *next; 37}; 38 39struct State { 40 Node *path; // 路径 41 int g; // 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 \u003c= n \u003c= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头 42 int len; // 路径长度，到了当前状态已经经历的长度 43 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 44 inline bool operator[](size_t i) const { return g \u0026 (1 \u003c\u003c (i + 4)); } // 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头 45 inline void setRock(size_t i, bool val = true) { // 设置位置 i 上是否有石头 46 if (val) 47 g |= 1 \u003c\u003c (i + 4); // 位或操作来把第(i + 4)位来置 1 48 else 49 g \u0026= ~(1 \u003c\u003c (i + 4)); // 先取反，再用与操作来把第(i + 4)位来置 0 50 } 51 // 机器人的位置操作 52 inline int getP() const { return g \u0026 15; } // 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置 53 inline void setP(int p) { g = ((g \u003e\u003e 4) \u003c\u003c 4) | p; } // 设置机器人的位置，这里先右移再左移 4 位清除原有的数据 54}; 55 56vector\u003cint\u003e G[MAXN]; // 图的邻接矩阵表示，题目中简化成了树(无环图) 57MemPool\u003cNode\u003e pool; // 链表节点分配，用 MemPool 比较好管理内存 58// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置 59// O: 每一个石头的位置编号 60// VIS: 表示某个位置是否已经 visited 过了 61int n, m, S, T, O[MAXN], VIS[1 \u003c\u003c 19]; 62Node *newNode(Node *next = NULL, int u = -1, int v = -1) { 63 Node *p = pool.createNew(); 64 p-\u003enext = next, p-\u003efrom = u, p-\u003eto = v; 65 return p; 66} 67 68// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的 69ostream \u0026operator\u003c\u003c(ostream \u0026os, Node *p) { 70 if (p == NULL) 71 return os; 72 os \u003c\u003c p-\u003enext \u003c\u003c p-\u003efrom + 1 \u003c\u003c \" \" \u003c\u003c p-\u003eto + 1 \u003c\u003c endl; // 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号 73 return os; 74} 75 76// 尝试移动在点 from 上的物体(机器人或者石头) 77void tryMove(const State \u0026s, int from, queue\u003cState\u003e \u0026q) { 78 int rp = s.getP(); // 获取当前状态下机器人的位置编号 79 for (auto to : G[from]) { 80 if ((to == rp) || s[to]) // to 和当前状态的机器人位置重合或者 to 的位置上有机器人 81 continue; 82 int ng = s.g; 83 if (from == rp) 84 ng = ((s.g \u003e\u003e 4) \u003c\u003c 4) | to; // 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置 85 else 86 ng ^= (1 \u003c\u003c (from + 4)), ng ^= (1 \u003c\u003c (to + 4)); // 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置 87 if (VIS[ng]) 88 continue; // 新的状态已经访问过 89 VIS[ng] = 1; // 标记访问 90 // 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node 91 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 92 } 93} 94 95// bfs 96void solve() { 97 // 定义并初始化原始的状态 98 State s; 99 _for(i, 0, m) s.setRock(O[i]); 100 s.setP(S); 101 queue\u003cState\u003e q; 102 q.push(s); 103 VIS[s.g] = 1; // 标记当前机器人和石头的状态已经被访问过 104 // bfs 一层一层地遍历 105 while (!q.empty()) { 106 const State \u0026st = q.front(); 107 int rp = st.getP(); 108 if (rp == T) { // 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数 109 cout \u003c\u003c st.len \u003c\u003c endl \u003c\u003c st.path; 110 return; 111 } 112 tryMove(st, rp, q); // 尝试移动机器人 113 _for(i, 0, n) if (st[i]) tryMove(st, i, q); // 尝试移动石头 114 q.pop(); 115 } 116 cout \u003c\u003c \"-1\" \u003c\u003c endl; // 无法到达目的地 117} 118 119int main() { 120 // 重定向标准输入到文件 121 string relativePathToCurrentCppFile = \"./data/UVa12569/input1.txt\"; 122 // relativePathToCurrentCppFile = \"./data/UVa12569/input2.txt\"; 123 // 因为我们是在根目录下执行编译出来的可执行文件的 124 ifstream inputFile(\"./ch07\" + relativePathToCurrentCppFile.substr(1, relativePathToCurrentCppFile.size() - 1)); 125 if (!inputFile.is_open()) { 126 cerr \u003c\u003c \"Failed to open input data file.\" \u003c\u003c endl; 127 return 2; 128 } 129 streambuf *cinbuf = cin.rdbuf(); // save original buf 130 cin.rdbuf(inputFile.rdbuf()); 131 132 int K = readint(); // 读取 case 的数量，为了和 case 关键字区分，一般用 Kase 或者 K 来表示 case 133 for (int t = 1; t \u003c= K; t++) { 134 memset(VIS, 0, sizeof(VIS)); // 初始化置 0 135 cin \u003e\u003e n \u003e\u003e m \u003e\u003e S \u003e\u003e T; // 读入 n m S T 136 --S; // 程序用到的编号要减 1 137 --T; // 同上 138 cout \u003c\u003c \"Case \" \u003c\u003c t \u003c\u003c \": \"; 139 _for(i, 0, m) O[i] = readint() - 1; // 读入石头的编号，编号是从给的数据减 1 而得来 140 _for(i, 0, n) G[i].clear(); // 清除之前的数据 141 142 // 构建邻接矩阵 143 _for(i, 0, n - 1) { // 读入 n - 1 条边 144 int u = readint() - 1, v = readint() - 1; // 每一个顶点的编号都要减 1 145 G[u].push_back(v); 146 G[v].push_back(u); 147 } 148 149 solve(); 150 pool.dispose(); // 释放内存 151 cout \u003c\u003c endl; 152 } 153 154 // 恢复标准输入 155 cin.rdbuf(cinbuf); 156 return 0; 157} 纯净的代码 由于上面的代码我为了自己测试方便进行标准输入流重定向的处理，是不能直接提交的，所以，我在下面提供一份纯净的可以用于提交验证的代码，这里同时去除了所有的注释，因为中文字符似乎不被接受，\n1#include 2#include 3#include 4#include 5#include 6 7#define _for(i, a, b) for (int i = (a); i \u003c (b); ++i) 8 9using namespace std; 10 11int readint() { 12 int x; 13 cin \u003e\u003e x; 14 return x; 15} 16 17template \u003ctypename T\u003e struct MemPool { 18 vector\u003cT *\u003e buf; 19 T *createNew() { 20 buf.push_back(new T()); 21 return buf.back(); 22 } 23 24 void dispose() { 25 for (int i = 0; i \u003c buf.size(); i++) 26 delete buf[i]; 27 buf.clear(); 28 } 29}; 30 31const int MAXN = 16; 32 33struct Node { 34 int from, to; 35 Node *next; 36}; 37 38struct State { 39 Node *path; 40 int g; 41 int len; 42 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 43 inline bool operator[](size_t i) const { return g \u0026 (1 \u003c\u003c (i + 4)); } 44 inline void setRock(size_t i, bool val = true) { 45 if (val) 46 g |= 1 \u003c\u003c (i + 4); 47 else 48 g \u0026= ~(1 \u003c\u003c (i + 4)); 49 } 50 51 inline int getP() const { return g \u0026 15; } 52 inline void setP(int p) { g = ((g \u003e\u003e 4) \u003c\u003c 4) | p; } 53}; 54 55vector\u003cint\u003e G[MAXN]; 56MemPool\u003cNode\u003e pool; 57 58int n, m, S, T, O[MAXN], VIS[1 \u003c\u003c 19]; 59Node *newNode(Node *next = NULL, int u = -1, int v = -1) { 60 Node *p = pool.createNew(); 61 p-\u003enext = next, p-\u003efrom = u, p-\u003eto = v; 62 return p; 63} 64 65ostream \u0026operator\u003c\u003c(ostream \u0026os, Node *p) { 66 if (p == NULL) 67 return os; 68 os \u003c\u003c p-\u003enext \u003c\u003c p-\u003efrom + 1 \u003c\u003c \" \" \u003c\u003c p-\u003eto + 1 \u003c\u003c endl; 69 return os; 70} 71 72void tryMove(const State \u0026s, int from, queue\u003cState\u003e \u0026q) { 73 int rp = s.getP(); 74 for (auto to : G[from]) { 75 if ((to == rp) || s[to]) 76 continue; 77 int ng = s.g; 78 if (from == rp) 79 ng = ((s.g \u003e\u003e 4) \u003c\u003c 4) | to; 80 else 81 ng ^= (1 \u003c\u003c (from + 4)), ng ^= (1 \u003c\u003c (to + 4)); 82 if (VIS[ng]) 83 continue; 84 VIS[ng] = 1; 85 86 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 87 } 88} 89 90void solve() { 91 92 State s; 93 _for(i, 0, m) s.setRock(O[i]); 94 s.setP(S); 95 queue\u003cState\u003e q; 96 q.push(s); 97 VIS[s.g] = 1; 98 99 while (!q.empty()) { 100 const State \u0026st = q.front(); 101 int rp = st.getP(); 102 if (rp == T) { 103 cout \u003c\u003c st.len \u003c\u003c endl \u003c\u003c st.path; 104 return; 105 } 106 tryMove(st, rp, q); 107 _for(i, 0, n) if (st[i]) tryMove(st, i, q); 108 q.pop(); 109 } 110 cout \u003c\u003c \"-1\" \u003c\u003c endl; 111} 112 113int main() { 114 int K = readint(); 115 for (int t = 1; t \u003c= K; t++) { 116 memset(VIS, 0, sizeof(VIS)); 117 cin \u003e\u003e n \u003e\u003e m \u003e\u003e S \u003e\u003e T; 118 --S; 119 --T; 120 cout \u003c\u003c \"Case \" \u003c\u003c t \u003c\u003c \": \"; 121 _for(i, 0, m) O[i] = readint() - 1; 122 _for(i, 0, n) G[i].clear(); 123 124 _for(i, 0, n - 1) { 125 int u = readint() - 1, v = readint() - 1; 126 G[u].push_back(v); 127 G[v].push_back(u); 128 } 129 130 solve(); 131 pool.dispose(); 132 cout \u003c\u003c endl; 133 } 134 135 return 0; 136} 当然，这个代码也是可以在我的 GitHub 仓库中找到的。\n参考 1、《算法竞赛入门经典》第二版\n2、https://github.com/sukhoeing/aoapc-bac2nd-keys\n",
  "wordCount" : "5144",
  "inLanguage": "zh",
  "image": "https://i.postimg.cc/7hwBy7VS/calcr.png","datePublished": "2024-08-21T23:56:38+08:00",
  "dateModified": "2024-08-21T23:56:38+08:00",
  "author":{
    "@type": "Person",
    "name": "Sonny Calcr"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/uva12569/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SonnyCalcr's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.png"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="SonnyCalcr&#39;s Blog (Alt + H)">SonnyCalcr&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="SonnyCalcr&#39;s Blog">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      UVa12569
    </h1>
    <div class="post-meta"><span title='2024-08-21 23:56:38 +0800 CST'>2024-08-21</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;Sonny Calcr

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#part1" aria-label="Part1">Part1</a></li>
                <li>
                    <a href="#part2" aria-label="Part2">Part2</a></li>
                <li>
                    <a href="#part3" aria-label="Part3">Part3</a></li>
                <li>
                    <a href="#part4" aria-label="Part4">Part4</a></li>
                <li>
                    <a href="#part5" aria-label="Part5">Part5</a></li>
                <li>
                    <a href="#%e5%ae%8c%e6%95%b4%e7%9a%84%e4%bb%a3%e7%a0%81%e5%92%8c%e6%b3%a8%e9%87%8a" aria-label="完整的代码和注释">完整的代码和注释</a></li>
                <li>
                    <a href="#%e7%ba%af%e5%87%80%e7%9a%84%e4%bb%a3%e7%a0%81" aria-label="纯净的代码">纯净的代码</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83" aria-label="参考">参考</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>首先，建议大家读一下原题目，题目的内容这里就不放了，大家可以到这个地址去下载: <a href="https://vjudge.net/problem/UVA-12569">https://vjudge.net/problem/UVA-12569</a>，有些人可能说英文不太好，那么，也没关系，除了查字典，现在还可以使用这个翻译插件：沉浸式翻译，总之，现在英语语言层面的问题是不会有问题的。</p>
<p>为什么我建议大家读原题目呢？虽然我们大家接触到这个题目可能都是通过刘汝佳的这本《算法竞赛入门经典》才选择去看的，但是，书中给出的描述都是很略的，简单讲一点，题目很重要的输入和输出样例数据，书上一般都是没有的，其他的细节更不必说。大概就这样。</p>
<p>然后，我们来详细研究一下 UVa12569 这道题的思路和解析。</p>
<p>这道题整体的思路是 BFS。然后代码参考(可能有我的微小调整)的是《算法竞赛入门经典-习题与解答》的配套代码，GitHub 地址为：<a href="https://github.com/sukhoeing/aoapc-bac2nd-keys">https://github.com/sukhoeing/aoapc-bac2nd-keys</a>。</p>
<p>此外，如果我们想要更多的测试数据，这个 udebug 的网站也是必不可少的：<a href="https://www.udebug.com">https://www.udebug.com</a>。本题的测试数据地址为：<a href="https://www.udebug.com/UVa/12569">https://www.udebug.com/UVa/12569</a>。</p>
<p>同时，我的代码托管在了这个地址：<a href="https://github.com/sonnycalcr/aoapc-homework">https://github.com/sonnycalcr/aoapc-homework</a>。</p>
<p>首先，这道题很多人可能觉得简单，我说一下我的观点：对于初学者或者算法初阶的同学来讲，这道题还是有很多值得学习的部分的。</p>
<p>接下来，我挑一些关键的代码讲一下，更详细的解释在代码的注释里面。</p>
<p>注意，在具体看/写代码之前，我们首先要明确一个点，题目中的编号是从 1 开始递增的，而下面我们的程序都是从 0 开始递增的。</p>
<h2 id="part1">Part1<a hidden class="anchor" aria-hidden="true" href="#part1">#</a></h2>
<p>先看数据结构，一个是 <code>Node</code>，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>Node 是表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点，主要是用来在 <code>State</code> 类型中表示 <code>path</code>，也就是当前的状态是由上一个状态从 from 移动了机器人/石头到 to 而转化过来的。</p>
<h2 id="part2">Part2<a hidden class="anchor" aria-hidden="true" href="#part2">#</a></h2>
<p>再看 <code>State</code>，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="nc">State</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span> <span class="c1">// 路径
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>      <span class="c1">// 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 &lt;= n &lt;= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>    <span class="c1">// 路径长度，到了当前状态已经经历的长度
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>    <span class="n">State</span><span class="p">(</span><span class="kt">int</span> <span class="n">gi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">li</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">pn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">:</span> <span class="n">g</span><span class="p">(</span><span class="n">gi</span><span class="p">),</span> <span class="n">len</span><span class="p">(</span><span class="n">li</span><span class="p">),</span> <span class="n">path</span><span class="p">(</span><span class="n">pn</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span> <span class="p">}</span> <span class="c1">// 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setRock</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>                      <span class="c1">// 设置位置 i 上是否有石头
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">g</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 位或操作来把第(i + 4)位来置 1
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>        <span class="k">else</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="n">g</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">// 先取反，再用与操作来把第(i + 4)位来置 0
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// 机器人的位置操作
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">getP</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span> <span class="p">}</span>           <span class="c1">// 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setP</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">g</span> <span class="o">=</span> <span class="p">((</span><span class="n">g</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 设置机器人的位置，这里先右移再左移 4 位清除原有的数据
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>所谓的 State，就是当前的局面，由以下几个维度的数据构成，</p>
<ul>
<li><code>path</code> 是路径，上面讲过了，其中保存了上一个状态转变到当前状态是移动了哪一个编号，然后又是移动到了哪一个编号，同时 <code>next</code> 指向了上一次状态的 <code>path</code>。</li>
<li><code>g</code> 代表了整体的状态，其中，前 4 位(分别是：0, 1, 2, 3)二进制值作为一个整体可以转化成十进制，表示了当前机器人在哪个编号的位置；然后再往左取 16 位二进制 bit 位，其中每一位都代表了一个编号，比如，0 号位置的 bit 位是 (0 + 4)，也就是第 4 位，如果这一位为 1，则表示树中编号为 0 的位置上有石头，反之则没有，其它的编号依此类推。</li>
<li><code>len</code> 表示从最原始的状态来到了当前的状态，一共走了多少步。</li>
</ul>
<p>理解了上面的几个成员变量，就不难理解之后的几个成员函数了。</p>
<h2 id="part3">Part3<a hidden class="anchor" aria-hidden="true" href="#part3">#</a></h2>
<p>我们再看输出运算符的重载，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里我们要注意，因为 <code>Node</code> 实际上是用来表示 <code>State</code> 中的 <code>path</code> 的，所以，并且，我们是到了最后成功到达终点时(看代码 109 行)直接打印最终的那个 <code>State</code> 的 <code>path</code> 的，而每一个 <code>path</code> 指向的又是上一个 <code>State</code> 的 <code>path</code>，所以，这个输出重载就达到了输出从初始的状态移动到最终目标的全部路径的目的。</p>
<h2 id="part4">Part4<a hidden class="anchor" aria-hidden="true" href="#part4">#</a></h2>
<p>然后，我们看一下尝试移动机器人或者石头的思路，在这之前，我们先再来看一下全局变量，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="c1">// 节点的最大数量是 16，根据题目中的条件得来
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span> <span class="c1">// 图的邻接矩阵表示，题目中简化成了树(无环图)
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span><span class="n">MemPool</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pool</span><span class="p">;</span>  <span class="c1">// 链表节点分配，用 MemPool 比较好管理内存
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1">// O: 每一个石头的位置编号
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1">// VIS: 表示某个位置是否已经 visited 过了
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">O</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">VIS</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">];</span>
</span></span></code></pre></div><p>这个注释比较清晰了，就不多讲了。然后，让我们进入正题，来看 <code>tryMove</code> 这个函数，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// 尝试移动在点 from 上的物体(机器人或者石头)
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">tryMove</span><span class="p">(</span><span class="k">const</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">int</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">getP</span><span class="p">();</span> <span class="c1">// 获取当前状态下机器人的位置编号
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">to</span> <span class="p">:</span> <span class="n">G</span><span class="p">[</span><span class="n">from</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">to</span> <span class="o">==</span> <span class="n">rp</span><span class="p">)</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">to</span><span class="p">])</span> <span class="c1">// to 和当前状态的机器人位置重合或者 to 的位置上有机器人
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="kt">int</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="n">rp</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="n">ng</span> <span class="o">=</span> <span class="p">((</span><span class="n">s</span><span class="p">.</span><span class="n">g</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">to</span><span class="p">;</span> <span class="c1">// 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>        <span class="k">else</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="n">ng</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">from</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)),</span> <span class="n">ng</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">to</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">// 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">VIS</span><span class="p">[</span><span class="n">ng</span><span class="p">])</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="k">continue</span><span class="p">;</span> <span class="c1">// 新的状态已经访问过
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>        <span class="n">VIS</span><span class="p">[</span><span class="n">ng</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 标记访问
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>        <span class="c1">// 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">State</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">newNode</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>因为 <code>G</code> 是邻接矩阵，我们可以利用这个特点来进行 <code>for</code> 循环，遍历与 <code>from</code> 顶点所邻接的几个顶点，尝试去移动到这些位置，然后就是一系列的细节处理，看注释比较容易理解。</p>
<h2 id="part5">Part5<a hidden class="anchor" aria-hidden="true" href="#part5">#</a></h2>
<p>下面我们来看最终的核心的代码，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// bfs
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// 定义并初始化原始的状态
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">State</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="n">setRock</span><span class="p">(</span><span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">setP</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">queue</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">VIS</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 标记当前机器人和石头的状态已经被访问过
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="c1">// bfs 一层一层地遍历
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="k">const</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">st</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="kt">int</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">getP</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rp</span> <span class="o">==</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        <span class="n">tryMove</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>                         <span class="c1">// 尝试移动机器人
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">tryMove</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="c1">// 尝试移动石头
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-1&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 无法到达目的地
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>这里就是一个纯粹的 bfs，我们定义好了原始的状态之后，然后利用队列这个数据结构一圈一圈地往外进行波纹扩散性地遍历，队列中从前往后存放的分别是第 1 圈、第 2 圈&hellip;的数据，而且队列是先进先出(FIFO, First In First Out)，所以，我们可以暴力地遍历所有的情况，并且，可以保证，一旦第一次得到了想要的结果，那么，这个结果就是我们最终想要的结果。</p>
<h2 id="完整的代码和注释">完整的代码和注释<a hidden class="anchor" aria-hidden="true" href="#完整的代码和注释">#</a></h2>
<p>以上就是关键的代码和解释了。其他的东西没什么好讲的。关于数据的输入和处理，上面也没有细讲，直接看注释即可。</p>
<p>下面就是完整的代码和详细的注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln">  1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  3</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  4</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  5</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  6</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  7</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">  8</span><span class="cl"><span class="cp">#define _for(i, a, b) for (int i = (a); i &lt; (b); ++i)
</span></span></span><span class="line"><span class="ln">  9</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 10</span><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 11</span><span class="cl">
</span></span><span class="line"><span class="ln"> 12</span><span class="cl"><span class="kt">int</span> <span class="nf">readint</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 13</span><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 14</span><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 15</span><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 16</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 17</span><span class="cl">
</span></span><span class="line"><span class="ln"> 18</span><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">MemPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 19</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 20</span><span class="cl">    <span class="n">T</span> <span class="o">*</span><span class="nf">createNew</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 21</span><span class="cl">        <span class="n">buf</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">());</span>
</span></span><span class="line"><span class="ln"> 22</span><span class="cl">        <span class="k">return</span> <span class="n">buf</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">    <span class="kt">void</span> <span class="nf">dispose</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 26</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 27</span><span class="cl">            <span class="k">delete</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">        <span class="n">buf</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 29</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 30</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 31</span><span class="cl">
</span></span><span class="line"><span class="ln"> 32</span><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="c1">// 节点的最大数量是 16
</span></span></span><span class="line"><span class="ln"> 33</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 34</span><span class="cl"><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span> <span class="c1">// 表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点
</span></span></span><span class="line"><span class="ln"> 35</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 36</span><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 37</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 38</span><span class="cl">
</span></span><span class="line"><span class="ln"> 39</span><span class="cl"><span class="k">struct</span> <span class="nc">State</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span> <span class="c1">// 路径
</span></span></span><span class="line"><span class="ln"> 41</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>      <span class="c1">// 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 &lt;= n &lt;= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头
</span></span></span><span class="line"><span class="ln"> 42</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>    <span class="c1">// 路径长度，到了当前状态已经经历的长度
</span></span></span><span class="line"><span class="ln"> 43</span><span class="cl"><span class="c1"></span>    <span class="n">State</span><span class="p">(</span><span class="kt">int</span> <span class="n">gi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">li</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">pn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">:</span> <span class="n">g</span><span class="p">(</span><span class="n">gi</span><span class="p">),</span> <span class="n">len</span><span class="p">(</span><span class="n">li</span><span class="p">),</span> <span class="n">path</span><span class="p">(</span><span class="n">pn</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">    <span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span> <span class="p">}</span> <span class="c1">// 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头
</span></span></span><span class="line"><span class="ln"> 45</span><span class="cl"><span class="c1"></span>    <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setRock</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>                      <span class="c1">// 设置位置 i 上是否有石头
</span></span></span><span class="line"><span class="ln"> 46</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 47</span><span class="cl">            <span class="n">g</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// 位或操作来把第(i + 4)位来置 1
</span></span></span><span class="line"><span class="ln"> 48</span><span class="cl"><span class="c1"></span>        <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 49</span><span class="cl">            <span class="n">g</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">// 先取反，再用与操作来把第(i + 4)位来置 0
</span></span></span><span class="line"><span class="ln"> 50</span><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 51</span><span class="cl">    <span class="c1">// 机器人的位置操作
</span></span></span><span class="line"><span class="ln"> 52</span><span class="cl"><span class="c1"></span>    <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">getP</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span> <span class="p">}</span>           <span class="c1">// 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置
</span></span></span><span class="line"><span class="ln"> 53</span><span class="cl"><span class="c1"></span>    <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setP</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">g</span> <span class="o">=</span> <span class="p">((</span><span class="n">g</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 设置机器人的位置，这里先右移再左移 4 位清除原有的数据
</span></span></span><span class="line"><span class="ln"> 54</span><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 55</span><span class="cl">
</span></span><span class="line"><span class="ln"> 56</span><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span> <span class="c1">// 图的邻接矩阵表示，题目中简化成了树(无环图)
</span></span></span><span class="line"><span class="ln"> 57</span><span class="cl"><span class="c1"></span><span class="n">MemPool</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pool</span><span class="p">;</span>  <span class="c1">// 链表节点分配，用 MemPool 比较好管理内存
</span></span></span><span class="line"><span class="ln"> 58</span><span class="cl"><span class="c1">// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置
</span></span></span><span class="line"><span class="ln"> 59</span><span class="cl"><span class="c1">// O: 每一个石头的位置编号
</span></span></span><span class="line"><span class="ln"> 60</span><span class="cl"><span class="c1">// VIS: 表示某个位置是否已经 visited 过了
</span></span></span><span class="line"><span class="ln"> 61</span><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">O</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">VIS</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 62</span><span class="cl"><span class="n">Node</span> <span class="o">*</span><span class="nf">newNode</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 63</span><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">createNew</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 65</span><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 66</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">
</span></span><span class="line"><span class="ln"> 68</span><span class="cl"><span class="c1">// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的
</span></span></span><span class="line"><span class="ln"> 69</span><span class="cl"><span class="c1"></span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 70</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 72</span><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号
</span></span></span><span class="line"><span class="ln"> 73</span><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 74</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 75</span><span class="cl">
</span></span><span class="line"><span class="ln"> 76</span><span class="cl"><span class="c1">// 尝试移动在点 from 上的物体(机器人或者石头)
</span></span></span><span class="line"><span class="ln"> 77</span><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">tryMove</span><span class="p">(</span><span class="k">const</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 78</span><span class="cl">    <span class="kt">int</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">getP</span><span class="p">();</span> <span class="c1">// 获取当前状态下机器人的位置编号
</span></span></span><span class="line"><span class="ln"> 79</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">to</span> <span class="p">:</span> <span class="n">G</span><span class="p">[</span><span class="n">from</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 80</span><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">to</span> <span class="o">==</span> <span class="n">rp</span><span class="p">)</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">to</span><span class="p">])</span> <span class="c1">// to 和当前状态的机器人位置重合或者 to 的位置上有机器人
</span></span></span><span class="line"><span class="ln"> 81</span><span class="cl"><span class="c1"></span>            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 82</span><span class="cl">        <span class="kt">int</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 83</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="n">rp</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 84</span><span class="cl">            <span class="n">ng</span> <span class="o">=</span> <span class="p">((</span><span class="n">s</span><span class="p">.</span><span class="n">g</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">to</span><span class="p">;</span> <span class="c1">// 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置
</span></span></span><span class="line"><span class="ln"> 85</span><span class="cl"><span class="c1"></span>        <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">            <span class="n">ng</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">from</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)),</span> <span class="n">ng</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">to</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">// 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置
</span></span></span><span class="line"><span class="ln"> 87</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">VIS</span><span class="p">[</span><span class="n">ng</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 88</span><span class="cl">            <span class="k">continue</span><span class="p">;</span> <span class="c1">// 新的状态已经访问过
</span></span></span><span class="line"><span class="ln"> 89</span><span class="cl"><span class="c1"></span>        <span class="n">VIS</span><span class="p">[</span><span class="n">ng</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 标记访问
</span></span></span><span class="line"><span class="ln"> 90</span><span class="cl"><span class="c1"></span>        <span class="c1">// 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node
</span></span></span><span class="line"><span class="ln"> 91</span><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">State</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">newNode</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln"> 92</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 93</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 94</span><span class="cl">
</span></span><span class="line"><span class="ln"> 95</span><span class="cl"><span class="c1">// bfs
</span></span></span><span class="line"><span class="ln"> 96</span><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">    <span class="c1">// 定义并初始化原始的状态
</span></span></span><span class="line"><span class="ln"> 98</span><span class="cl"><span class="c1"></span>    <span class="n">State</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">    <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="n">setRock</span><span class="p">(</span><span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">100</span><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">setP</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">101</span><span class="cl">    <span class="n">queue</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">102</span><span class="cl">    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">103</span><span class="cl">    <span class="n">VIS</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 标记当前机器人和石头的状态已经被访问过
</span></span></span><span class="line"><span class="ln">104</span><span class="cl"><span class="c1"></span>    <span class="c1">// bfs 一层一层地遍历
</span></span></span><span class="line"><span class="ln">105</span><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">106</span><span class="cl">        <span class="k">const</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">st</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">107</span><span class="cl">        <span class="kt">int</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">getP</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">108</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rp</span> <span class="o">==</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数
</span></span></span><span class="line"><span class="ln">109</span><span class="cl"><span class="c1"></span>            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">110</span><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">111</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">112</span><span class="cl">        <span class="n">tryMove</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>                         <span class="c1">// 尝试移动机器人
</span></span></span><span class="line"><span class="ln">113</span><span class="cl"><span class="c1"></span>        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">tryMove</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span> <span class="c1">// 尝试移动石头
</span></span></span><span class="line"><span class="ln">114</span><span class="cl"><span class="c1"></span>        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">115</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">116</span><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-1&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 无法到达目的地
</span></span></span><span class="line"><span class="ln">117</span><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="ln">118</span><span class="cl">
</span></span><span class="line"><span class="ln">119</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">120</span><span class="cl">    <span class="c1">// 重定向标准输入到文件
</span></span></span><span class="line"><span class="ln">121</span><span class="cl"><span class="c1"></span>    <span class="n">string</span> <span class="n">relativePathToCurrentCppFile</span> <span class="o">=</span> <span class="s">&#34;./data/UVa12569/input1.txt&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">122</span><span class="cl">    <span class="c1">// relativePathToCurrentCppFile = &#34;./data/UVa12569/input2.txt&#34;;
</span></span></span><span class="line"><span class="ln">123</span><span class="cl"><span class="c1"></span>    <span class="c1">// 因为我们是在根目录下执行编译出来的可执行文件的
</span></span></span><span class="line"><span class="ln">124</span><span class="cl"><span class="c1"></span>    <span class="n">ifstream</span> <span class="n">inputFile</span><span class="p">(</span><span class="s">&#34;./ch07&#34;</span> <span class="o">+</span> <span class="n">relativePathToCurrentCppFile</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">relativePathToCurrentCppFile</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">125</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inputFile</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">126</span><span class="cl">        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed to open input data file.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">127</span><span class="cl">        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">128</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">129</span><span class="cl">    <span class="n">streambuf</span> <span class="o">*</span><span class="n">cinbuf</span> <span class="o">=</span> <span class="n">cin</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">();</span> <span class="c1">// save original buf
</span></span></span><span class="line"><span class="ln">130</span><span class="cl"><span class="c1"></span>    <span class="n">cin</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">(</span><span class="n">inputFile</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">131</span><span class="cl">
</span></span><span class="line"><span class="ln">132</span><span class="cl">    <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span> <span class="c1">// 读取 case 的数量，为了和 case 关键字区分，一般用 Kase 或者 K 来表示 case
</span></span></span><span class="line"><span class="ln">133</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">134</span><span class="cl">        <span class="n">memset</span><span class="p">(</span><span class="n">VIS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VIS</span><span class="p">));</span> <span class="c1">// 初始化置 0
</span></span></span><span class="line"><span class="ln">135</span><span class="cl"><span class="c1"></span>        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">S</span> <span class="o">&gt;&gt;</span> <span class="n">T</span><span class="p">;</span>     <span class="c1">// 读入 n m S T
</span></span></span><span class="line"><span class="ln">136</span><span class="cl"><span class="c1"></span>        <span class="o">--</span><span class="n">S</span><span class="p">;</span>                         <span class="c1">// 程序用到的编号要减 1
</span></span></span><span class="line"><span class="ln">137</span><span class="cl"><span class="c1"></span>        <span class="o">--</span><span class="n">T</span><span class="p">;</span>                         <span class="c1">// 同上
</span></span></span><span class="line"><span class="ln">138</span><span class="cl"><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Case &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">139</span><span class="cl">        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readint</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 读入石头的编号，编号是从给的数据减 1 而得来
</span></span></span><span class="line"><span class="ln">140</span><span class="cl"><span class="c1"></span>        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>         <span class="c1">// 清除之前的数据
</span></span></span><span class="line"><span class="ln">141</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">142</span><span class="cl">        <span class="c1">// 构建邻接矩阵
</span></span></span><span class="line"><span class="ln">143</span><span class="cl"><span class="c1"></span>        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>                           <span class="c1">// 读入 n - 1 条边
</span></span></span><span class="line"><span class="ln">144</span><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">readint</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">readint</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 每一个顶点的编号都要减 1
</span></span></span><span class="line"><span class="ln">145</span><span class="cl"><span class="c1"></span>            <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">146</span><span class="cl">            <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">147</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">148</span><span class="cl">
</span></span><span class="line"><span class="ln">149</span><span class="cl">        <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">150</span><span class="cl">        <span class="n">pool</span><span class="p">.</span><span class="n">dispose</span><span class="p">();</span> <span class="c1">// 释放内存
</span></span></span><span class="line"><span class="ln">151</span><span class="cl"><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">152</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">153</span><span class="cl">
</span></span><span class="line"><span class="ln">154</span><span class="cl">    <span class="c1">// 恢复标准输入
</span></span></span><span class="line"><span class="ln">155</span><span class="cl"><span class="c1"></span>    <span class="n">cin</span><span class="p">.</span><span class="n">rdbuf</span><span class="p">(</span><span class="n">cinbuf</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">156</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">157</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="纯净的代码">纯净的代码<a hidden class="anchor" aria-hidden="true" href="#纯净的代码">#</a></h2>
<p>由于上面的代码我为了自己测试方便进行标准输入流重定向的处理，是不能直接提交的，所以，我在下面提供一份纯净的可以用于提交验证的代码，这里同时去除了所有的注释，因为中文字符似乎不被接受，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="ln">  1</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  3</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  4</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  5</span><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="ln">  6</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">  7</span><span class="cl"><span class="cp">#define _for(i, a, b) for (int i = (a); i &lt; (b); ++i)
</span></span></span><span class="line"><span class="ln">  8</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln">  9</span><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 10</span><span class="cl">
</span></span><span class="line"><span class="ln"> 11</span><span class="cl"><span class="kt">int</span> <span class="nf">readint</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 12</span><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 13</span><span class="cl">    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 14</span><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 15</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 16</span><span class="cl">
</span></span><span class="line"><span class="ln"> 17</span><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">MemPool</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 18</span><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span> <span class="o">*&gt;</span> <span class="n">buf</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 19</span><span class="cl">    <span class="n">T</span> <span class="o">*</span><span class="nf">createNew</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 20</span><span class="cl">        <span class="n">buf</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">());</span>
</span></span><span class="line"><span class="ln"> 21</span><span class="cl">        <span class="k">return</span> <span class="n">buf</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 22</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">    <span class="kt">void</span> <span class="nf">dispose</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 26</span><span class="cl">            <span class="k">delete</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 27</span><span class="cl">        <span class="n">buf</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 29</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 30</span><span class="cl">
</span></span><span class="line"><span class="ln"> 31</span><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 32</span><span class="cl">
</span></span><span class="line"><span class="ln"> 33</span><span class="cl"><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 34</span><span class="cl">    <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 35</span><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 36</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 37</span><span class="cl">
</span></span><span class="line"><span class="ln"> 38</span><span class="cl"><span class="k">struct</span> <span class="nc">State</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 39</span><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">    <span class="kt">int</span> <span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 41</span><span class="cl">    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 42</span><span class="cl">    <span class="n">State</span><span class="p">(</span><span class="kt">int</span> <span class="n">gi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">li</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">pn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">:</span> <span class="n">g</span><span class="p">(</span><span class="n">gi</span><span class="p">),</span> <span class="n">len</span><span class="p">(</span><span class="n">li</span><span class="p">),</span> <span class="n">path</span><span class="p">(</span><span class="n">pn</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="ln"> 43</span><span class="cl">    <span class="kr">inline</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">    <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setRock</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">val</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 45</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 46</span><span class="cl">            <span class="n">g</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 47</span><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 48</span><span class="cl">            <span class="n">g</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 49</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 50</span><span class="cl">
</span></span><span class="line"><span class="ln"> 51</span><span class="cl">    <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">getP</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">g</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 52</span><span class="cl">    <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">setP</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">g</span> <span class="o">=</span> <span class="p">((</span><span class="n">g</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 53</span><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 54</span><span class="cl">
</span></span><span class="line"><span class="ln"> 55</span><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 56</span><span class="cl"><span class="n">MemPool</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pool</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 57</span><span class="cl">
</span></span><span class="line"><span class="ln"> 58</span><span class="cl"><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">O</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">VIS</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 59</span><span class="cl"><span class="n">Node</span> <span class="o">*</span><span class="nf">newNode</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 60</span><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">createNew</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 61</span><span class="cl">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">=</span> <span class="n">u</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 62</span><span class="cl">    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 63</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">
</span></span><span class="line"><span class="ln"> 65</span><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 66</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 68</span><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">from</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">to</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 69</span><span class="cl">    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 70</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">
</span></span><span class="line"><span class="ln"> 72</span><span class="cl"><span class="kt">void</span> <span class="nf">tryMove</span><span class="p">(</span><span class="k">const</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">queue</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 73</span><span class="cl">    <span class="kt">int</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">getP</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 74</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">to</span> <span class="p">:</span> <span class="n">G</span><span class="p">[</span><span class="n">from</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 75</span><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">to</span> <span class="o">==</span> <span class="n">rp</span><span class="p">)</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">to</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 76</span><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 77</span><span class="cl">        <span class="kt">int</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 78</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">==</span> <span class="n">rp</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 79</span><span class="cl">            <span class="n">ng</span> <span class="o">=</span> <span class="p">((</span><span class="n">s</span><span class="p">.</span><span class="n">g</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 80</span><span class="cl">        <span class="k">else</span>
</span></span><span class="line"><span class="ln"> 81</span><span class="cl">            <span class="n">ng</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">from</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)),</span> <span class="n">ng</span> <span class="o">^=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">to</span> <span class="o">+</span> <span class="mi">4</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 82</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">VIS</span><span class="p">[</span><span class="n">ng</span><span class="p">])</span>
</span></span><span class="line"><span class="ln"> 83</span><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 84</span><span class="cl">        <span class="n">VIS</span><span class="p">[</span><span class="n">ng</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 85</span><span class="cl">
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">State</span><span class="p">(</span><span class="n">ng</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">newNode</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">)));</span>
</span></span><span class="line"><span class="ln"> 87</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 88</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 89</span><span class="cl">
</span></span><span class="line"><span class="ln"> 90</span><span class="cl"><span class="kt">void</span> <span class="nf">solve</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 91</span><span class="cl">
</span></span><span class="line"><span class="ln"> 92</span><span class="cl">    <span class="n">State</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 93</span><span class="cl">    <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="n">setRock</span><span class="p">(</span><span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 94</span><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">setP</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 95</span><span class="cl">    <span class="n">queue</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 96</span><span class="cl">    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">    <span class="n">VIS</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 98</span><span class="cl">
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">100</span><span class="cl">        <span class="k">const</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">st</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">101</span><span class="cl">        <span class="kt">int</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">getP</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">102</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rp</span> <span class="o">==</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">103</span><span class="cl">            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">len</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">path</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">104</span><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">105</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">106</span><span class="cl">        <span class="n">tryMove</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">rp</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">107</span><span class="cl">        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">tryMove</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">108</span><span class="cl">        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">109</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">110</span><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-1&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">111</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">112</span><span class="cl">
</span></span><span class="line"><span class="ln">113</span><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">114</span><span class="cl">    <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="n">readint</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">115</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">116</span><span class="cl">        <span class="n">memset</span><span class="p">(</span><span class="n">VIS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">VIS</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">117</span><span class="cl">        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="n">S</span> <span class="o">&gt;&gt;</span> <span class="n">T</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">118</span><span class="cl">        <span class="o">--</span><span class="n">S</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">119</span><span class="cl">        <span class="o">--</span><span class="n">T</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">120</span><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Case &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">121</span><span class="cl">        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="n">O</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">readint</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">122</span><span class="cl">        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">123</span><span class="cl">
</span></span><span class="line"><span class="ln">124</span><span class="cl">        <span class="n">_for</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">125</span><span class="cl">            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">readint</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">readint</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">126</span><span class="cl">            <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">127</span><span class="cl">            <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">128</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">129</span><span class="cl">
</span></span><span class="line"><span class="ln">130</span><span class="cl">        <span class="n">solve</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">131</span><span class="cl">        <span class="n">pool</span><span class="p">.</span><span class="n">dispose</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">132</span><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">133</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">134</span><span class="cl">
</span></span><span class="line"><span class="ln">135</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">136</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><img loading="lazy" src="https://i.postimg.cc/ZYpk0djw/image.png"></p>
<p>当然，这个代码也是可以在我的 GitHub 仓库中找到的。</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<p>1、《算法竞赛入门经典》第二版<br>
2、<a href="https://github.com/sukhoeing/aoapc-bac2nd-keys">https://github.com/sukhoeing/aoapc-bac2nd-keys</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/bilibili/">Bilibili</a></li>
      <li><a href="http://localhost:1313/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">算法竞赛</a></li>
      <li><a href="http://localhost:1313/tags/uva/">UVa</a></li>
      <li><a href="http://localhost:1313/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8/">算法竞赛入门经典</a></li>
      <li><a href="http://localhost:1313/tags/bfs/">BFS</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/is-arch-kde-wayland-good-for-daily-use/">
    <span class="title">« 上一页</span>
    <br>
    <span>Arch Linux KDE 适合我们作为一个日常的操作系统去使用吗？</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/personal-likes-terminal-and-shell-in-windows/">
    <span class="title">下一页 »</span>
    <br>
    <span>终端和 Shell 的使用之 Windows 篇</span>
  </a>
</nav>

  </footer><div id="tw-comment"></div>
<script>
    
    const getStoredTheme = () => localStorage.getItem("pref-theme") === "light" ? "light" : "dark";
    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "sonnycalcr\/sonnycalcr.github.io",
            "data-repo-id": "R_kgDOMed_Fg",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDOMed_Fs4ChXJF",
            "data-mapping": "pathname",
            "data-strict": "0",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "zh-CN",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
                ([key, value]) => giscusScript.setAttribute(key, value));
        document.querySelector("#tw-comment").appendChild(giscusScript);

        
        const themeSwitcher = document.querySelector("#theme-toggle");
        if (themeSwitcher) {
            themeSwitcher.addEventListener("click", setGiscusTheme);
        }
        const themeFloatSwitcher = document.querySelector("#theme-toggle-float");
        if (themeFloatSwitcher) {
            themeFloatSwitcher.addEventListener("click", setGiscusTheme);
        }
    });
</script>

</article>
    </main>
    
<footer class="footer">
        <span><a href="https://sonnycalcr.github.io/">©2024 SonnyCalcr&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>


<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.1.0/medium-zoom.min.js"
  integrity="sha512-9ZKhgaFdKlsELap/dGw3Iaz5Bj+Las0XXZiRKYZaN9QArg6FtkD5rULNmNH4rTCTFxjPiBGr3MX8smRADRorDA=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
  var OSName = "unknown";
  var navApp = navigator.userAgent.toLowerCase();
  switch (true) {
    case (navApp.indexOf("win") != -1):
      OSName = "windows";
      break;
    case (navApp.indexOf("mac") != -1):
      OSName = "apple";
      break;
    case (navApp.indexOf("linux") != -1):
      OSName = "linux";
      break;
    case (navApp.indexOf("x11") != -1):
      OSName = "unix";
      break;
  }

  const images = Array.from(document.querySelectorAll(".post-content img"));
  images.forEach(img => {
    mediumZoom(img, {
      margin: 1,    
      
      container: null,  
      template: null,  
      
    });
  });

  if (OSName == "windows") {
    document.body.className += ' win11'
  }
</script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
