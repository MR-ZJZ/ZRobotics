[{"content":"题意 https://onlinejudge.org/external/3/340.pdf https://onlinejudge.org/external/4/401.pdf 理解分析 这两道题比较直接，都是用字符数组来进行解决。\n","permalink":"http://localhost:1313/posts/uva401-and-uva340/","summary":"\u003ch2 id=\"题意\"\u003e题意\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/3/340.pdf\"\u003ehttps://onlinejudge.org/external/3/340.pdf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/4/401.pdf\"\u003ehttps://onlinejudge.org/external/4/401.pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"理解分析\"\u003e理解分析\u003c/h2\u003e\n\u003cp\u003e这两道题比较直接，都是用字符数组来进行解决。\u003c/p\u003e","title":"UVa401 and UVa340"},{"content":"配套的书是这本：\u0026lt;\n如何看自己当前的 Kotlin 的版本？\n在 build.gradle.kts 中，\n1// Top-level build file where you can add configuration options common to all sub-projects/modules. 2plugins { 3 alias(libs.plugins.android.application) apply false 4 alias(libs.plugins.kotlin.android) apply false 5 alias(libs.plugins.kotlin.compose) apply false 6} 我们点进第二行的版本中去查看即可。现在 Kotlin 的版本为 2.0.0.\n如何看 Jetpack Compose 的版本？\nhttps://developer.android.com/develop/ui/compose/compiler\n也是类似的道理，现在 Jetpack Compose 的版本为 2.0.0.\n书上是建议我们使用 Jetpack Compose v1.2.1，这里我们不听他的，我们直接用最新版，遇到不兼容的地方，就直接去解决就行。\n我们这里可以先把代码 clone 一份下来备用，\n1git clone https://github.com/kodecocodes/jet-materials.git 如何阅读这本书？\n直接从开头然后按照顺序读下去即可。\n开发环境的搭建。\n安装 Android Studio 即可。\n对于测试的设备，直接使用手头的安卓手机。\n","permalink":"http://localhost:1313/posts/jetpack-compose-by-tutorials-2nd-cn-version/before-you-begin/","summary":"\u003cp\u003e配套的书是这本：\u0026lt;\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如何看自己当前的 Kotlin 的版本？\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e在 build.gradle.kts 中，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eandroid\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eapplication\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekotlin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eandroid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekotlin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecompose\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们点进第二行的版本中去查看即可。现在 Kotlin 的版本为 2.0.0.\u003c/p\u003e","title":"在你开始之前"},{"content":"很多朋友在使用 Hyprland/Wayland 的时候，可能会遇到这样一个问题，那就是 Chrome、VSCode 和 Obsidian 这类基于 chromium 的软件的界面字体和 UI 比较模糊，不够 sharp 和清晰。那么，我这里简要介绍我常用的两种方法。\n一种是像 VSCode/Chrome 这种可以直接加 flags 的，那么，我们直接在在配置目录中新建一个 code-flags.conf 然后加上一些启动参数即可，\n1--ozone-platform-hint=wayland 2--enable-wayland-ime 对于 Chrome，我们则需要写一个 chrome-flags.conf，\n1--enable-features=UseOzonePlatform 2--ozone-platform=wayland 3--enable-wayland-ime 然后是一些我们不知道其 flags 文件怎么命名的软件，比如，Obsidian 和 Jetbrains 家的软件，那么，我们可以直接自制一份我们自己的 desktop file 来覆盖系统默认的，这里拿 Obsidian 举例，我们去 /usr/share/applications 下去复制一份 obsidian.desktop 文件到 ~/.local/share/applications/ 下面，然后在 Exec 那一行加一些启动参数即可，\n1Exec=/usr/bin/obsidian %U --enable-features=UseOzonePlatform --ozone-platform=wayland --enable-wayland-ime Jetbrains 家的软件也是一样，加一下它们提供的 wayland 相关的参数即可，\n1Exec=intellij-idea-ultimate-edition %u -Dawt.toolkit.name=WLToolkit ","permalink":"http://localhost:1313/posts/resolve-wayland-or-hyprland-chrome-and-jetrains-scale-issue/","summary":"\u003cp\u003e很多朋友在使用 Hyprland/Wayland 的时候，可能会遇到这样一个问题，那就是 Chrome、VSCode 和 Obsidian 这类基于 chromium 的软件的界面字体和 UI 比较模糊，不够 sharp 和清晰。那么，我这里简要介绍我常用的两种方法。\u003c/p\u003e","title":"解决 Hyprland/Wayland 下 Chrome/Chromium 系列软件和 Jetbrains 系列软件的缩放和输入法使用的问题"},{"content":"题意理解 https://onlinejudge.org/external/10/1025.pdf\n这里要我们求的输出是：最少等待时间。什么是最少等待时间呢？就是在车站逗留的时间。\n解题思路 用 $d(i, j)$ 表示时刻 i，Mario 在车站 j 最少还需要等待多少时间。 边界条件是：$d(T, n) = 0$，表示在 T 时刻，Mario 已经在 n 站台了。其他的 d(T, i) 为正无穷。 对于其他的普通的情况，也就是 d(i, j)，可以有 3 种决策： 1、等 1 个时间单位 2、搭乘往右开的车(如果有) 3、搭乘往左开的车(如果有) 代码理解 这里状态转移方程比较直观，其实就是最内层的 for 循环中的处理过程。因为我们的边界条件是 T 时刻，所以，对于时刻 i，我们从 T - 1 开始遍历。\n这里一定要明确，$dp[i, j]$ 表示的是时刻 i，在车站 j 最少还需要等待多少时间。\n1dp[i][j] = dp[i+1][j] + 1; // 等待一个时间单位 表示，从 dp[i][j] 状态来到 dp[i+1][j]，是在 j 站台等待了一个时间单位。并且，最终来到了 i + 1 时刻。\n1dp[i][j] = min(dp[i][j], dp[i+t[j]][j+1]); // 右 表示，从 dp[i][j] 状态来到 dp[i+t[j]][j+1] 状态，是在往右的列车上花费了 t[j] 个时间单位，并且，最终来到了 i + t[j] 时刻和 j + 1 站台。这个过程中，没有等待。\n1dp[i][j] = min(dp[i][j], dp[i+t[j-1]][j-1]); // 左 表示，从 dp[i][j] 状态来到 dp[i+t[j-1]][j-1] 状态，是在往左的列车上花费了 t[j-1] 个时间单位(因为题意说，两个站台之间列车往左往右花费的时间是一样的)，并且，最终来到了 i + t[j - 1] 时刻和 j - 1 站台。这个过程中，也没有等待。\n注意：这里为什么一次只让列车走一个站台呢？是因为一次走多个站台的情况也被我们这种挨个处理的方式给囊括了，便于我们去处理所有的情况。比如，我想坐列车一次往右走两个站台，那么，其实在我走完一个站台的时候，会有三种决策，那么，其中，直接向右走的决策就和一次走两个站台的那种情况是相等了。\n","permalink":"http://localhost:1313/posts/uva1025/","summary":"\u003ch2 id=\"题意理解\"\u003e题意理解\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://onlinejudge.org/external/10/1025.pdf\"\u003ehttps://onlinejudge.org/external/10/1025.pdf\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这里要我们求的输出是：最少等待时间。什么是最少等待时间呢？就是在车站逗留的时间。\u003c/p\u003e\n\u003ch2 id=\"解题思路\"\u003e解题思路\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e用 $d(i, j)$ 表示时刻 i，Mario 在车站 j 最少还需要等待多少时间。\u003c/li\u003e\n\u003cli\u003e边界条件是：$d(T, n) = 0$，表示在 T 时刻，Mario 已经在 n 站台了。其他的 d(T, i) 为正无穷。\u003c/li\u003e\n\u003cli\u003e对于其他的普通的情况，也就是 d(i, j)，可以有 3 种决策：\n\u003cul\u003e\n\u003cli\u003e1、等 1 个时间单位\u003c/li\u003e\n\u003cli\u003e2、搭乘往右开的车(如果有)\u003c/li\u003e\n\u003cli\u003e3、搭乘往左开的车(如果有)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"代码理解\"\u003e代码理解\u003c/h2\u003e\n\u003cp\u003e这里状态转移方程比较直观，其实就是最内层的 for 循环中的处理过程。因为我们的边界条件是 T 时刻，所以，对于时刻 i，我们从 T - 1 开始遍历。\u003c/p\u003e","title":"UVa1025"},{"content":"这两道题是整本书中出现的第一道和第二道 UVa 的题目。\nhttps://onlinejudge.org/external/2/272.pdf https://onlinejudge.org/external/100/10082.pdf 先看 UVa272，这里需要注意两点，\ngetchar =\u0026gt; 这里之所以使用 getchar，是因为如果使用 scanf 来读取输入的话，那么，像 TAB、空格这样的字符就会被当成分隔符而无法读入； EOF 是什么？EOF 表示一个文件的结束，如果是读取一个文件，那么，读取到文件尾时，就会读取到 EOF。更详细的内容可以看：https://stackoverflow.com/questions/4358728/end-of-file-eof-in-c。我们在使用命令行的时候，可以使用 Ctrl + D(在 Linux 系统下) 来手动触发 EOF。 额外说一句，第 46 页，\n如果用“scanf(\u0026quot;%d\u0026quot;, \u0026amp;n)”读取整数 n，则要是在输入 123 后多加了一个空格，用 getchar 读取的将是这个空格，\n这里的意思是先调用 scanf，然后调用 getchar，并不是上来就只调用 getchar。\n再看 UVa10082，思路也是一样，毕竟是开篇的题目，所以比较简单。\n好，那么这两道题所用到的知识点就是这个 getchar 了。\n然后，下面是代码时间，写代码的时候，注意一下题目的输入数据的格式即可。\n","permalink":"http://localhost:1313/posts/uva272-and-uva10082/","summary":"\u003cp\u003e这两道题是整本书中出现的第一道和第二道 UVa 的题目。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/2/272.pdf\"\u003ehttps://onlinejudge.org/external/2/272.pdf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/100/10082.pdf\"\u003ehttps://onlinejudge.org/external/100/10082.pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e先看 UVa272，这里需要注意两点，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egetchar =\u0026gt; 这里之所以使用 getchar，是因为如果使用 scanf 来读取输入的话，那么，像 TAB、空格这样的字符就会被当成分隔符而无法读入；\u003c/li\u003e\n\u003cli\u003eEOF 是什么？EOF 表示一个文件的结束，如果是读取一个文件，那么，读取到文件尾时，就会读取到 EOF。更详细的内容可以看：\u003ca href=\"https://stackoverflow.com/questions/4358728/end-of-file-eof-in-c\"\u003ehttps://stackoverflow.com/questions/4358728/end-of-file-eof-in-c\u003c/a\u003e。我们在使用命令行的时候，可以使用 Ctrl + D(在 Linux 系统下) 来手动触发 EOF。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e额外说一句，第 46 页，\u003c/p\u003e","title":"UVa272 and UVa10082"},{"content":"这里以 Windows11 为例。\n这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\n这个可以写的东西不多，就直接看视频吧。\n插件：\nC/C++ CMake Tools CMake(LSP) 首先，我们先手动地配置一个 C/C++ 项目。\n全手动。即，从命令行编译一个 C++ 文件。\n然后，如果你想省事儿，那么，可以试一下我的模板，\nhttps://github.com/fanlumaster/LinuxCppTemplate\n不过呢，我建议每个人还是自己给自己建立一个模板，这样用起来才放心、熟悉。\n最后，如果大家想更多从实际上手的角度来理解 CMake 的使用，我斗胆推荐一下这本 Modern CMake for C++，刚好前段时间刚出了第二版，很新。如果仅仅是想入个门，那么，读一下第一章也可以有不少收获。\n关于 debug 的配置，可以参考 cmake 插件给出的配置，\nhttps://github.com/microsoft/vscode-cmake-tools/blob/main/docs/debug-launch.md\n因为是在 Windows 平台，所以，就使用 msvc 比较好。\n","permalink":"http://localhost:1313/posts/configure-vscode-cmake-c-cpp-windows/","summary":"\u003cp\u003e这里以 Windows11 为例。\u003c/p\u003e\n\u003cp\u003e这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\u003c/p\u003e\n\u003cp\u003e这个可以写的东西不多，就直接看视频吧。\u003c/p\u003e\n\u003cp\u003e插件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC/C++\u003c/li\u003e\n\u003cli\u003eCMake Tools\u003c/li\u003e\n\u003cli\u003eCMake(LSP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先，我们先手动地配置一个 C/C++ 项目。\u003c/p\u003e","title":"Windows 配置 VSCode + CMake + C/C++ 开发环境"},{"content":"这里以 Arch Linux 为例。\n这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\n这个可以写的东西不多，就直接看视频吧。\n插件：\nC/C++ CMake Tools CMake(LSP) 首先，我们先手动地配置一个 C/C++ 项目。\n全手动。即，从命令行编译一个 C++ 文件。\n然后，如果你想省事儿，那么，可以试一下我的模板，\nhttps://github.com/fanlumaster/LinuxCppTemplate\n不过呢，我建议每个人还是自己给自己建立一个模板，这样用起来才放心、熟悉。\n最后，如果大家想更多从实际上手的角度来理解 CMake 的使用，我斗胆推荐一下这本 Modern CMake for C++，刚好前段时间刚出了第二版，很新。如果仅仅是想入个门，那么，读一下第一章也可以有不少收获。\n下下期视频(大概率)，我将带大家看一个真实的世界中使用 VSCode + C/C++ 插件 + CMake 插件大型项目：Hyprland。\n","permalink":"http://localhost:1313/posts/configure-vscode-cmake-c-cpp-linux/","summary":"\u003cp\u003e这里以 Arch Linux 为例。\u003c/p\u003e\n\u003cp\u003e这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\u003c/p\u003e\n\u003cp\u003e这个可以写的东西不多，就直接看视频吧。\u003c/p\u003e\n\u003cp\u003e插件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC/C++\u003c/li\u003e\n\u003cli\u003eCMake Tools\u003c/li\u003e\n\u003cli\u003eCMake(LSP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先，我们先手动地配置一个 C/C++ 项目。\u003c/p\u003e","title":"Linux 配置 VSCode + CMake + C/C++ 开发环境"},{"content":"或许也可以让 chatgpt 的访问更加丝滑。\n起因是在看 react 的官方教程时，发现有一张图片无法访问，对，就是下面这张，\n其实我最近两年的 imgur 的访问一直比较有问题，有时候需要换很多个节点才能尝试出来一个可以正常加载 imgur 图片的 ip，而有时候甚至会全军覆没。\n今天实在忍不了了，所以，就在网上找了一下有没有好的方法可以实现 imgur 的图片的正常访问，因为这个图床(图片托管网站)用到的地方挺多的，比如，像上面的 reactjs 的官网都会用到，还有 v 站也是默认会渲染 imgur 的图片，我自己的博客之前也是用 imgur 比较多，现在则换成了访问更加顺畅的 postimage，不过，我还有很多图片没有迁移过去，所以，解决 imgur 这个图床的问题迫在眉睫。找了一圈，发现还是用 warp 套一层比较合适。\n那么，具体是怎么操作呢？\n经过我的尝试，发现使用第三方开源的 cli 而非是 cloudflare 的官方 cli 在 Arch 上的体验是更加丝滑的，具体可以参考 Reddit 的这个帖子，\nhttps://www.reddit.com/r/CloudFlare/comments/q0hqj4/warpcli_is_not_working/\n具体来讲，就是先安装几个依赖，\n1yay -S cloudflare-warp-bin wireguard-dkms openresolv wireguard-tools wgcf 这里在安装完毕之后，不要忘记 reboot 一下。\n然后，来到一个临时的目录，依次执行，\n1wgcf register 2wgcf generate 3cp ./wgcf-profile.conf /etc/wireguard/ 然后，\n1wg-quick up wgcf-profile 然后，就可以查看一下 warp 的状态了，\n1curl https://www.cloudflare.com/cdn-cgi/trace/ 我这里的输出为，\n1fl=412f42 2h=www.cloudflare.com 3ip=2a09:bac5:55fd:1028::19c:2a 4ts=1729814011.542 5visit_scheme=https 6uag=curl/8.10.1 7colo=SIN 8sliver=none 9http=http/2 10loc=SG 11tls=TLSv1.3 12sni=plaintext 13warp=on 14gateway=off 15rbi=off 16kex=X25519 可以看到，warp 已经 on 的状态了。\n如果想要关闭，那么，这个时候，就可以 down 一下，\n1wg-quick down wgcf-profile 这样一来，imgur 对 ip 的限制就被我们绕过去了。\n比如，我以前很多博客的封面都是存在在 imgur 的，那么，我们可以看一下，访问的效果如何，\nhttps://fanlumaster.github.io/page/4/#board\n","permalink":"http://localhost:1313/posts/using-warp-to-unlock-imgur/","summary":"\u003cp\u003e或许也可以让 chatgpt 的访问更加丝滑。\u003c/p\u003e\n\u003cp\u003e起因是在看 react 的官方教程时，发现有一张图片无法访问，对，就是下面这张，\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/yXOvdOSs.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e其实我最近两年的 imgur 的访问一直比较有问题，有时候需要换很多个节点才能尝试出来一个可以正常加载 imgur 图片的 ip，而有时候甚至会全军覆没。\u003c/p\u003e","title":"使用 warp 来解除 imgur 的访问限制"},{"content":"","permalink":"http://localhost:1313/posts/my-experience-about-neovim-in-daily-dev-life/","summary":"","title":"My Experience About Neovim in Daily Dev Life"},{"content":"有网友问我关于我发布的算法竞赛入门经典(紫书)的更新计划，这里就简要说一下，顺便也可以作为这个系列的开篇/前言了。\n本来我的计划是，有时间就更，偶尔更，随机更。看到了感兴趣的题目或者随机抽一个就更一下。\n既然有人愿意看，那么，我就让这个系列稍微有秩序一些。所以，之后的更新计划是什么呢？那就是：如果是不忙的时候，我尽量两天更新一道题目。\n更新的计划 会讲哪些题目 对于没有和 UVa 绑定的例题，我应该不会讲解，因为那些题目是比较简单的、为了辅助读者理解概念的，读者看一遍就可以理解。\n但凡是可以提交到 OJ 的题目，在这本书里面，就都是 UVa 的题目了，那么，对于这些题目，我会一题不落的进行讲解，如果你发现有缺漏，那一定是时间的问题，我还没有更新到那里。\n更新的顺序是怎样的 对于更新的顺序问题，我会分成两条线，一条线是从第一章开始，按照顺序更，另一条线是在书中随机挑选题目进行更新。\n这两条线是同步进行的。\n初衷是什么 书的阅读说明里有这样一句话：\n本书最好是有人带着学习。\n确实，中学有很多的竞赛培训班，不过，但是，我认为他们的习惯他们的道德不符合我当初作为初学者时所期待的前辈的印象(包括很多大家可能认为比较权威的人士)，不管是所用工具，所传播出来的理念，动不动就加什么 QQ 群，收什么费之类，令人讨厌，徒增门槛，使人心生退意。一言以蔽之，乌烟瘴气，一群老登。\n而且，我认为，好的视频资源为什么只能存在于国外的平台？这好吗？这不好。\n所以，我就尽量在自己得空的时候，为一些真正对算法竞赛入门感兴趣的初学者提供一份还算能看的材料。就这么简单。\n是用爱发电吗 大概可以这么理解。首先视频绝无收费的可能。当然，如果你愿意花几块钱给我充个电，相当于是请我喝一杯奶茶了(奶茶我最喜欢喝蜜雪冰城)，那我也会很开心的。\n我是绝对没有依靠视频去获取多少收益的意思，如果大家愿意支持我，那么，后面大家愿意购买我开发的付费软件，那就可以算是最好的支持了。\n使用的工具 操作系统，\nWin11 Arch Linux (KDE 或者 hyprland) 当然，也不排除后续使用其他发行版的可能性。\n编程工具，\nNeovim VSCode gcc g++ clang++ MSVC 要讲的大概就这么多。如果大家还有什么想问的，评论区你问我答。\n","permalink":"http://localhost:1313/posts/my-updating-plan-about-aoapc2nd/","summary":"\u003cp\u003e有网友问我关于我发布的算法竞赛入门经典(紫书)的更新计划，这里就简要说一下，顺便也可以作为这个系列的开篇/前言了。\u003c/p\u003e\n\u003cp\u003e本来我的计划是，有时间就更，偶尔更，随机更。看到了感兴趣的题目或者随机抽一个就更一下。\u003c/p\u003e","title":"序言-更新计划-初衷-关于算法竞赛入门经典第二版"},{"content":"我现在如何给初中的少年作数学辅导工作。以一道具体的数学题举例。\n$x$、$y$、$z$ 都是有理数。求\n$$ |x| + |x - y| + |y - z| + |10 - z| $$\n的最小值，并说明什么时候取得最小值。\n一般来说，刚上初一的时候，做这道题目还是需要思索几分钟的，猜大家肯定几秒钟就都可以猜出来，10 嘛。但人一旦有过编程的经验，就不想自己去猜了，而是让机器去猜，那么，我们就写一点 Python 来猜一下，\n1min = float(\u0026#39;inf\u0026#39;) 2for x in range(-100, 100): 3 for y in range(-100, 100): 4 for z in range(-100, 100): 5 cur_min = abs(x) + abs(x - y) + abs(y - z) + abs(10 - z) 6 if cur_min \u0026lt; min: 7 min = cur_min 8print(min) $$ |x| + (|y - x| + |y - z|) + |10 - z| $$\n进一步，\n$$ |x| + |x - z| + |10 - z| $$\n再进一步，\n$$\n$$ $$ |x| + (|z - x| + |z - 10|) $$ 再进一步，\n$$ |x - 0| + |x - 10| $$\n显然，最小值就是 10。\n","permalink":"http://localhost:1313/posts/one-interesting-junior-high-school-math-problem/","summary":"\u003cp\u003e我现在如何给初中的少年作数学辅导工作。以一道具体的数学题举例。\u003c/p\u003e\n\u003cp\u003e$x$、$y$、$z$ 都是有理数。求\u003c/p\u003e\n\u003cp\u003e$$\n|x| + |x - y| + |y - z| + |10 - z|\n$$\u003c/p\u003e\n\u003cp\u003e的最小值，并说明什么时候取得最小值。\u003c/p\u003e","title":"一道有意思的初中数学题"},{"content":"按规矩，先上链接：https://github.com/fanlumaster/fcitx5-FanIME。\n这里我们可以简单看一下代码，因为有了 fcitx5 这个框架，所以实现起来就更加轻松了。我们只需要关注核心的逻辑。\n下面就是基本的功能的介绍啦。\n小鹤双拼 这是最基本的功能，即一个标准的小鹤双拼。\n关于辅助码，这里采用的方案基本是蓝天小雨点的方案。\n单码辅助 对于所有的词条，默认都支持首字单码辅助。\n对于两字词语，同时支持第二个字的单码辅助。比如：红杉，红衫。双码。混输。\n双码辅助 对于单字和双字，按下 Tab 进行翻页时，可以使用双码进行辅助。比如，对弈的弈。双码。尤其是打单字的时候，对于输入人名的时候，非常方便。\n造词时的辅助码 造词时也同时支持单码辅助和双码辅助。\n速度 绝大多数场景的候选词条生成速度在 1ms 以内。同时，最坏情况应该也不会超过 2ms，因为我目前的测试中还未出现这样的数据。\n词库 采用了两个比较经典的开源词库进行整合。目前大概有 170 万个不重复的词条。\nhttps://github.com/iDvel/rime-ice https://github.com/wuhgit/CustomPinyinDictionary 开源 没错，输入法这个东西，你不开源，你还想怎样？窃取用户的隐私吗？\n因为代码公开，所以，基于原始版本，你想怎么定制就怎么定制，至于隐私的问题，早就已经在九霄云外了，完全不用考虑。\nTODO 1、动态调频。这个完全是因为我懒，加上目前在使用辅助码的情况下，还没遇到需要翻页的情况，就暂时搁置了。\n2、之前基于 HMM 做了一个长句联想，但是效果不达标，这个需要后续迭代。不过，也不急，因为目前的功能其实完全够用了。\n3、基于 SLM 制作长句联想。\n4、中英混输。\n5、云输入。这个优先级最低。也还是因为目前已经可以使用得很舒适了。\n","permalink":"http://localhost:1313/posts/a-first-glimpse-on-my-own-ime-fcitx5-fanime/","summary":"\u003cp\u003e按规矩，先上链接：\u003ca href=\"https://github.com/fanlumaster/fcitx5-FanIME\"\u003ehttps://github.com/fanlumaster/fcitx5-FanIME\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e这里我们可以简单看一下代码，因为有了 fcitx5 这个框架，所以实现起来就更加轻松了。我们只需要关注核心的逻辑。\u003c/p\u003e\n\u003cp\u003e下面就是基本的功能的介绍啦。\u003c/p\u003e","title":"真·自制输入法·打你所想"},{"content":"一道经典的算法题。链接：https://onlinejudge.org/external/5/524.pdf。\n这里的原题的描述，我们需要注意的只有输入和输出的格式那里，对于题意的理解，书中的中文描述已经足够了，因为题意是比较简单的。(这里可以去书上读一下题目的意思。)\n首先，素数的定义：wiki。\n大于 1 的自然数中，除了 1 和该数自身外，无法被其他自然数整除的数。(2 当然是素数。)\n关于输出中的数字排列的顺序，书上说是逆时针排列，而原题中说的是顺时针和逆时针，这个其实无所谓，我们依次 dfs 过去，最终会把顺时针和逆时针的情况全部囊括的。\n然后，书上首先介绍了一个“生成-测试”法，这个比较容易，这里就不去详细说明，我们就简单看下用到的 next_permutation 这个函数，可以看一下文档。\n核心的部分是这个 dfs，\n1/* 2 从 1 开始，依次去搜索每个位置上的可能性 3 4 cur: 当前的位置 5*/ 6void dfs(int cur) { 7 if (cur == n \u0026amp;\u0026amp; isp[A[0] + A[n - 1]]) { // 递归边界 8 for (int i = 0; i \u0026lt; n; i++) { 9 if (i != 0) 10 printf(\u0026#34; \u0026#34;); 11 printf(\u0026#34;%d\u0026#34;, A[i]); 12 } 13 printf(\u0026#34;\\n\u0026#34;); 14 } else 15 for (int i = 2; i \u0026lt;= n; i++) 16 if (!vis[i] \u0026amp;\u0026amp; isp[i + A[cur - 1]]) { // 判断当前的数字是否可行，不行的就跳过，相当于是剪枝了 17 A[cur] = i; 18 vis[i] = 1; // 标记已经访问过 19 dfs(cur + 1); // 递归处理下一个位置 20 vis[i] = 0; // 还原 21 } 22} 我们直接看所有的代码，一次性整体进行讲解。\n","permalink":"http://localhost:1313/posts/uva524/","summary":"\u003cp\u003e一道经典的算法题。链接：\u003ca href=\"https://onlinejudge.org/external/5/524.pdf\"\u003ehttps://onlinejudge.org/external/5/524.pdf\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e这里的原题的描述，我们需要注意的只有输入和输出的格式那里，对于题意的理解，书中的中文描述已经足够了，因为题意是比较简单的。(这里可以去书上读一下题目的意思。)\u003c/p\u003e","title":"UVa524"},{"content":"首先，我看了所有的问题，基本上这些问题都是可以在问答平台上找到答案的，多检索、浏览，多看一些，肯定效果会不错的。我这里只能提供一些大而化之的回复，望理解。\n然后是，可以浏览的一些网站有：stackoverflow, reddit, 知乎, v2ex, 推特也可以多逛逛，然后就是，一般来说，现在你稍微有点追求的相关从业人员，至少也应该有一个 GitHub 和独立博客，通过这些独立博客，我相信应该能够挖掘到更加真实的信息，而且，遇到了一个你感兴趣的 GitHub 上面的项目，我想，大概率你也能够发现他的博客，那么，从别人的记录中，至少可以了解到一些过往的人家走过的路的经验。\n如果往硬件方向靠，只学c++这一门语言可以吗，c还没有学过，有必要先去补一下吗？ 按照我的经验，c 是有必要去补一下的，而且，因为 c 的语法知识其实不多，应该花费时间不是很多。\n有哪些学习步骤是学软件学硬件都要走的 这个我只了解软件，学习步骤的话，尽量多看，多学，多写，只有实际动手写起来，写一点自己感兴趣的东西，才可能知道自己该去学习什么东西。\n有什么好的方式去学习知识 Study in public. 多找一些优质的学习资源，远离营销号、远离吊儿郎当、胡吹海侃的内容。\n最近了解到acm，现在这个时间节点去弄acm对于我来说价值大嘛 可以先翻一下刘汝佳的《算法竞赛入门经典》(第二版)，如果你能在一个月内理解完书中所有的例题，那么，任何时候去搞 acm 都不晚。\n现在硬件方向待遇真的很好吗 大一点的公司的待遇其实都是差不多的，比如华为、tp，当然，更高的有大疆。大公司都是看职级来划分工资的，本科毕业的待遇平均 20k 起步(以华科为例)。\n想实习就业的话，四大件需要都学吗，还是重点放在项目上 都需要学，学习和项目不冲突，可以同步开展。还是那句话，只有真正做了，才能对知识点理解得更加深刻。否则只能停留在皮毛与侃大山。\n四大件怎么学习？我看别人都推荐国外的公开课（sc61abc这些）但是我感觉我边看字幕边学，速度太慢了[笑哭]，不知道能不能听国内的对应的课（请问up有推荐的吗） 我也没有很好的建议，大概就是把对应的经典的英文教材的英文版和中文版同时翻开，以中文版为主，遇到不清晰的翻原文，尽量理解书中出现的所有的代码和示例。这样大概比看视频快一点。公开课的话，可以作为补充，一般来讲，其实可以跟着学校的课过一遍，重点在于多问老师问题，即使学校的课可能讲得不好，但是和老师交流的收获会不少。\n学习顺序怎么安排，一门语言和对应框架＋四大件，该怎么分配学习顺序（好像四大件重点学哪些还要看想做什么岗位） 先基础，后上层，然后可以交替理解，反复琢磨，顺序什么的，看个人，有些人喜欢先有个概览性的概念，有些人则喜欢上来就扣细节。我个人认为细节是要注意的，但是不一定非要现在解决。\n对于小白，算法入门应该如何学习（学了一个内容就去刷对应的题目吗），顺便问一下有没有推荐的up主，灵神的看不太懂[笑哭] 算法入门的书，可以看 labuladong 的公开的免费的材料，虽然很多人诟病他抄袭国内外优秀题解，但是，他抄的那些确实是好东西，比较通俗。up 主的话，我个人其实讲得不好，当然，也没遇到过讲得比较好的，包括各种各样的大大小小的 up。关键还是在于多看，多想，前提多看看题解没什么坏处，就当是例题用来刷经验了。\n此外，建议把《算法竞赛入门经典》的所有例题当成例题给吃透了，代码也一行不能放过。\n编程语言选择建议C++吗，好像双非本学C++不好找工作的[笑哭] 我自己其实业余也写一点 C++，也很喜欢 Python，但是我找工作使用的是 Java。目前 Java 的后端岗位其实相比其他要多。至于专门的 C++，很多公司其实都是可以进去之后转语言的，你把一门语言吃透，然后做几个项目，经验度够了之后，其实看待问题的想法就会不一样。\n可以聊聊申请美国申请的事吗, 想了解[给心心] 这个可以多看看小红书上的帖子和一亩三分地上面的导师发布的招募帖，基本这两个地方的信息比较多。美国申请，其实不追求 QS 排名的话，老师应该都是比较包容的。现在需要注意的点可能是签证的问题，这个多上小红书看看经验。我因为拒签了一次就摆了，所以，提供不了太多的建议了。\n","permalink":"http://localhost:1313/posts/simple-replies-to-some-friends-questions-about-cs/","summary":"\u003cp\u003e首先，我看了所有的问题，基本上这些问题都是可以在问答平台上找到答案的，多检索、浏览，多看一些，肯定效果会不错的。我这里只能提供一些大而化之的回复，望理解。\u003c/p\u003e","title":"简要回复网友的关于计算机方面的问题"},{"content":"本题较为简单。本来是想讲另外一道题目的(UVa12171，例题 6-18)，但是那道题目提到了 floodfill，那么，就先把这个 floodfill 这个知识点给讲了吧。\n首先，搞清楚题目中的一些条件。\n输入的 m 和 n 分别代表行和列，其范围都是 $[1, 100]$。 * 代表空白，没有油的地块，而 @ 代表有油的地块。 然后，书上可能会让人觉得疑惑的点，\n上面的代码用一个二重循环来找到当前格子的相邻 8 个格子，也可以用常量数组或写 8 条 DFS 调用。\n这里说的是可以直接硬编码 8 个 DFS，因为每次遍历只需要 8 次的 DFS。或者，把这 8 次整成一个由 8 个向量组成的常量数组也可以。\n剩余的就是一个简单的 DFS 了。直接看代码很容易理解。\n","permalink":"http://localhost:1313/posts/uva572/","summary":"\u003cp\u003e本题较为简单。本来是想讲另外一道题目的(UVa12171，例题 6-18)，但是那道题目提到了 floodfill，那么，就先把这个 floodfill 这个知识点给讲了吧。\u003c/p\u003e","title":"UVa572"},{"content":"思来想去，还是把 CSDN 直接屏蔽掉吧。\n首先，安装 ublacklist，\n然后，找到 options(选项)，\n直接写一个模糊匹配的规则即可，\n1*://*.csdn.net/* ","permalink":"http://localhost:1313/posts/block-csdn-when-using-google-search/","summary":"\u003cp\u003e思来想去，还是把 CSDN 直接屏蔽掉吧。\u003c/p\u003e\n\u003cp\u003e首先，安装 \u003ca href=\"https://chromewebstore.google.com/detail/ublacklist/pncfbmialoiaghdehhbnbhkkgmjanfhe\"\u003eublacklist\u003c/a\u003e，\u003c/p\u003e\n\u003cp\u003e然后，找到 options(选项)，\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/zB7B3QvD/image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接写一个模糊匹配的规则即可，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-txt\" data-lang=\"txt\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e*://*.csdn.net/*\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"谷歌搜索屏蔽CSDN"},{"content":"前言 这篇博客是关于一些关于阅读《算法竞赛入门经典·第 2 版》的一些小贴士。\n老手自不必说，本博客针对的是刚接触这本书的一些新手。\n为什么要读这一本书？\n因为经典。首先作者的实力相当深厚，其次是选取的题目非常纯粹，都是 UVa 的题目，而我们也知道，UVa 的很多题目都是 acm 的原题，所以，题目的严谨性和质量有一定的保证，作为我们学习过程中的例题简直再合适不过。\n那么，下面就讲一些我认为需要讲的点。\n首先是前置条件，完整地、有体系地入门过数据结构。大概需要的程度是掌握 70% 的机械工业出版社的那本《数据结构与算法分析 C 语言描述》的内容。第一版和第二版都可以。这里插一句，一定要中英文放在一起看，为什么？因为如果你刚接触这本书，那么，你也就是大学低年级的水平，你的英文水平、专业词汇的水平还不够直接阅读英文原文，所以最好中英文放在一起看，中文觉得别扭的地方，翻开英文看看，记录一下不顺的地方，然后，把翻译得不好的地方放到网上供大家赏玩，让出版社蒙羞，注意，一定要有理有据，不然，和“秀才造反，三年不成，空谈误国”道理是一样的。\n然后，一些必须放在身边的辅助的工具。\n源码 第一，是源码，例题的代码在这个仓库：\nhttps://github.com/aoapc-book/aoapc-bac2nd\n这个例题的代码是刘汝佳亲自写的，代码质量有保证，不晦涩，很亲民，稍微多挠几下脑瓜，基本都可以搞懂。\n习题的代码在这个仓库：\nhttps://github.com/sukhoeing/aoapc-bac2nd-keys\n这个是陈锋写的，我个人觉得写得不如刘汝佳，不能够做到鞭辟入里。当然，代码本身的正确性和简洁性是毋庸置疑的，这个也没的黑。\n关于书的获取 这本书太有名了，随便谷歌一下即可获取。\n要看原题描述 然后，因为书中的题目全部选自 UVa，所以，阅读每一个例题的时候，最好把 UVa 的英文原题的 pdf 摆在旁边，这个 pdf 可以到 UVa 官网获取，也可以到 vjudge 中去获取，这个也可以自行搜索(千万不要使用百度、必应国内版)即可。基本上输入题目的序号，就能找到其题目的链接的。比如，有些题目的链接：\nUVa442(UVa 官网): https://onlinejudge.org/index.php?option=com_onlinejudge\u0026Itemid=8\u0026page=show_problem\u0026problem=383 UVa442(vjudge): https://vjudge.net/problem/UVA-442 当然，UVa 也提供了一份题单，我个人觉得没有必要，遇到的时候，直接搜索一把即可，基本上前两个结果就是我们想要的。\n跑测试用例 这里一定要借助 udebug 这个网站，输入题号，即可检索到大量的测试用例。便于我们在实际去跑一个题目的代码时去排查 bug。\n因为有时候作者给出的代码不一定是完全正确的，以及，在我们自己去做额外的题目时，这时候就需要我们自己去利用测试用例排查了。\n重定向标准输入 因为书里的题目都是 acm 模式，所以，我们自己在写题目的时候，肯定是要重定向标准输入到文件的，这样我们只需要把测试用例粘贴到文件中，然后，程序就可以从文件中读取测试用例了。\n输出倒是不用重定向，直接输出到控制台我们也可以很容易观察。\n如何提交代码 建议直接到 vjudge 中去提交，反正也是调用官方的 api。因为官网实在有点慢，难免，当然也理解，毕竟为爱发电。\n关于例题的阅读 有些人喜欢去空想，硬想，你以为你是天才？随便翻开书中一道简单的 BFS 的题目，我们可以测试一下，自己在不看任何题解的情况下，需要花费多少时间解决。\n编程没有天才，只有一些喜欢装逼的废柴。剩下的唯有多看多写多练。\n很多时候，我们看到很多人可以凭空想出来，那么，我们也可以猜一猜，他们的题量是多少。而最初的题量，就是来自于对例题的理解。\n我们听老师上课讲解题目，不也是相当于是看例题、看题解的过程吗？\n所以，我这里更建议大家直接把书上的所有例题理解即可。不用尝试自己去做。等把所有的例题都吃透了，甚至是琢磨了两三遍，那么，我们就可以尝试去自己写书上的习题了，这时候，有了知识储备，再去尝试独立思考，那么，必定事半而功倍.。\n阅读的笔记？ 关于笔记，我们在理解题目和题解的时候，对于每一个题目，我们只需要弄清几个问题即可：\n这样做的正确性书上给证明了吗？如果给了，理解简要的证明，也就理解了正确性。 如果没有给证明，我们就要自己想明白其中的正确性。 算法的时间复杂度/空间复杂度的理解和简要证明。 对于理解题意，也不必钻入细节，只要识别出题目的意图即可，因为，即使 UVa 的题目已经算是比较严谨了，却也依然有人力不可完全细察之处的缺漏。 最重要的一点，识别作者给出的代码的每一处意图。只有如此，我们才能在自己做题目的时候运用自如。 这样一套下来，其实，搞懂一个例题，不比我们写一道力扣中等题所花费的时间少，不过，却也必然比我们在没有任何/太多知识和题量储备的情况下去硬想力扣的题目所花费的时间要少得多。\n而看懂一道题的收获，必然也是不少的，因为，这书中的大部分题目都是力扣的困难级别的。\n","permalink":"http://localhost:1313/posts/some-tips-for-reading-aoapc-bac2nd/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e这篇博客是关于一些关于阅读《算法竞赛入门经典·第 2 版》的一些小贴士。\u003c/p\u003e\n\u003cp\u003e老手自不必说，本博客针对的是刚接触这本书的一些新手。\u003c/p\u003e\n\u003cp\u003e为什么要读这一本书？\u003c/p\u003e\n\u003cp\u003e因为经典。首先作者的实力相当深厚，其次是选取的题目非常纯粹，都是 UVa 的题目，而我们也知道，UVa 的很多题目都是 acm 的原题，所以，题目的严谨性和质量有一定的保证，作为我们学习过程中的例题简直再合适不过。\u003c/p\u003e","title":"《算法竞赛入门经典·第 2 版》的一些阅读小贴士"},{"content":"题目链接：https://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\n对应算法导论的 33.4。\n主要是有几个问题。\n1、分治是如何进行切分的？\n我是比较朴素地直接一分为二，不让在中间的分割线上既可以包含在左半部分也包含在右半部分。而且，中间的线上的点是先从上面的部分切起，保证这一点的做法是，把点集按照 x 坐标排序的同时，如果 x 相等，那么，再按 y 排序。\n2、真的是 O(nlogn) 吗？\n是的。不信你就去用主方法再推一遍。\n3、为什么可以是 5 而不是 7？\n因为我前面的切分保证了分割线上没有重复的点。\n4、如何保证每一次递归额外所花费的时间是 O(n)？\n对 Y 切割后进行排序使用 set，那么，基本可以保证每一次查询是 O(1) 的时间复杂度。而构建 set 的插入操作也是这个时间复杂度。不过，正如我们学习数据结构的时候知道，有些极端情况会退化成 O(n) 的，但是，这个极端情况也是可以通过进一步优化 set 的内部构造来解决的。所以，这里按下不表，单就做题而言，使用 Python 内置的 set 就可以了。\n5、为什么只用 X 和 Y 就可以了？\n因为 P 其实本来就用不到，书上是为了事无巨细地讲明白才如此冗余。\n6、对于中间条带的点的暴力循环，其时间复杂度是 O(n)？\n当然是的，5n 也是 O(n)，不是吗？\n其实，我以前在上课的时候，也写过一篇[笔记](https://fanlumaster.github.io/2021/05/03/《算法导论》寻找最近点对问题的 Python 实现)。\n代码见仓库。\n","permalink":"http://localhost:1313/posts/closest-pair-of-points-in-linearithmic-time/","summary":"\u003cp\u003e题目链接：\u003ca href=\"https://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\"\u003ehttps://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e对应算法导论的 33.4。\u003c/p\u003e\n\u003cp\u003e主要是有几个问题。\u003c/p\u003e\n\u003cp\u003e1、分治是如何进行切分的？\u003c/p\u003e\n\u003cp\u003e我是比较朴素地直接一分为二，不让在中间的分割线上既可以包含在左半部分也包含在右半部分。而且，中间的线上的点是先从上面的部分切起，保证这一点的做法是，把点集按照 x 坐标排序的同时，如果 x 相等，那么，再按 y 排序。\u003c/p\u003e","title":"寻找最近点对"},{"content":"愚蠢的人自然要自己为其付出代价。多说无益。\n人们当然愿意相信他们已经相信过的东西。\n很多东西其实是无意义的。比如，视频的封面、视频的播放量、视频的夸张的标题、视频的字幕等等等等。\n真正重要的是内容。无论是否有人愿意去看。\n","permalink":"http://localhost:1313/posts/the-foolish-must-pay-the-price-for-their-own-thoughts/","summary":"\u003cp\u003e愚蠢的人自然要自己为其付出代价。多说无益。\u003c/p\u003e\n\u003cp\u003e人们当然愿意相信他们已经相信过的东西。\u003c/p\u003e\n\u003cp\u003e很多东西其实是无意义的。比如，视频的封面、视频的播放量、视频的夸张的标题、视频的字幕等等等等。\u003c/p\u003e","title":"The Foolish Must Pay the Price for Their Own Thoughts"},{"content":"理解 题意比较简单，时间长没有碰数学者或许需要一两分钟回想一下矩阵的乘法。\n可以看一下同济大学的线代教材中给出的矩阵的相乘的公式，\n看一下输入和输出，\n输入\n这里有个术语：EBNF，这是编译原理里面的一个很简单的一个范式，上过课的应该都有印象，如果需要，再去翻一下书即可。\n注意这个条件，\n1Expression = Matrix | \u0026#34;(\u0026#34; Expression Expression \u0026#34;)\u0026#34; 可以推出，括号里面只可以出现一对单独的矩阵，也就是两个单独的矩阵，e.g. (AB)，或者，一个矩阵加上另一对括号括起来的矩阵，e.g. (A(AB))，以此类推。因此，我们可以在遇到右括号的时候，一次出栈两个栈中的元素，\n1else if (expr[i] == \u0026#39;)\u0026#39;) { 2 Matrix m2 = s.top(); 3 s.pop(); 4 Matrix m1 = s.top(); 5 s.pop(); 6 ... 7} 输出\n理解一下题目中的例子即可。\n代码 1#include \u0026lt;cstdio\u0026gt; 2#include \u0026lt;cctype\u0026gt; 3#include \u0026lt;stack\u0026gt; 4#include \u0026lt;iostream\u0026gt; 5#include \u0026lt;string\u0026gt; 6 7using namespace std; 8 9struct Matrix { 10 int a, b; 11 Matrix(int a = 0, int b = 0) : a(a), b(b) {} 12} m[26]; 13 14stack\u0026lt;Matrix\u0026gt; s; 15 16int main(int argc, char *argv[]) { 17 int n; 18 cin \u0026gt;\u0026gt; n; 19 for (int i = 0; i \u0026lt; n; i++) { 20 string name; 21 cin \u0026gt;\u0026gt; name; 22 int k = name[0] - \u0026#39;A\u0026#39;; 23 cin \u0026gt;\u0026gt; m[k].a \u0026gt;\u0026gt; m[k].b; 24 } 25 string expr; 26 while (cin \u0026gt;\u0026gt; expr) { 27 int len = expr.length(); 28 bool error = false; 29 int ans = 0; 30 for (int i = 0; i \u0026lt; len; i++) { 31 if (isalpha(expr[i])) 32 s.push(m[expr[i] - \u0026#39;A\u0026#39;]); 33 else if (expr[i] == \u0026#39;)\u0026#39;) { 34 Matrix m2 = s.top(); 35 s.pop(); 36 Matrix m1 = s.top(); 37 s.pop(); 38 if (m1.b != m2.a) { 39 error = true; 40 break; 41 } 42 ans += m1.a * m2.a * m2.b; 43 s.push(Matrix(m1.a, m2.b)); 44 } 45 } 46 if (error) 47 cout \u0026lt;\u0026lt; \u0026#34;error\\n\u0026#34;; 48 else 49 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 50 } 51 return 0; 52} ","permalink":"http://localhost:1313/posts/uva442/","summary":"UVa210 解题思路及代码解析","title":"UVa442"},{"content":"关于 B 站的 sonnycalcr 这个帐号的事情，就在这个博客里面说。\n今天与一位 B 站的网友私信时，我犯了一个习惯主义错误：一杯奶茶解决问题。\n这好吗？我以前从来没有意识到这个问题。以前的习惯是，给一些同学或者朋友看问题，往往会附加一个条件，那就是，请喝奶茶，或者请吃饭(当然，是学校的食堂)。人都是有所求的，不可能无缘无故帮助别人，这十块或者二十块以内非真实的金钱的交易，大概就和中学时代的一袋方便面讲解一道题类似。\n几块钱的问题本不值得拿出来一说，毕竟现在很多程序员以大厂作为炫耀的条件，以月薪 30k，40k，80k 这种作为一种说辞：难道还有人的薪资低于 20k 吗？\n但是，学生毕竟是学生。\n关于我个人的经济状况：\n因为房子是自己的，所以每个月的消耗也不过是一些脑力、电力、水、气这些。所以，经济状况，至少两年内不用考虑。如果稍微顺利一点，那就是一坤年。如果再幸运一点，那估计就要把单位换成 10 年这个 unit 了。\n总结：既然你也是群众的一员，那就不能拿群众一针一线。朋友同学除外。\n","permalink":"http://localhost:1313/posts/one-cup-of-tea/","summary":"\u003cp\u003e关于 B 站的 sonnycalcr 这个帐号的事情，就在这个博客里面说。\u003c/p\u003e\n\u003cp\u003e今天与一位 B 站的网友私信时，我犯了一个习惯主义错误：一杯奶茶解决问题。\u003c/p\u003e\n\u003cp\u003e这好吗？我以前从来没有意识到这个问题。以前的习惯是，给一些同学或者朋友看问题，往往会附加一个条件，那就是，请喝奶茶，或者请吃饭(当然，是学校的食堂)。人都是有所求的，不可能无缘无故帮助别人，这十块或者二十块以内非真实的金钱的交易，大概就和中学时代的一袋方便面讲解一道题类似。\u003c/p\u003e","title":"一杯奶茶引起的质疑"},{"content":"《算法竞赛入门经典》(第二版) 第 6 章例题 6-2。\n题意 这一题的题面较短，其中英文原题也比较容易理解，所以，我们直接分析题意和代码。\n本题的题意是右边有一列火车向左开，一列火车可以有很多个车厢，单个车厢来到岔路口的时候，可以选择直接进入 B 轨道，也可以选择在 Station 里面暂存一下，但是 Station 相当于是一个 stack，所以，遵循后进先出的规则。\n题目的要求就是，在这样的规则之下，判断给定的序列是否是合法的。\n具体我们看几个输入和输出的样例即可。\n代码 需要说明一点是，书上给出的代码是有误的，实际提交到 OJ 无法通过。我这里讲解的是我修改之后 AC 的代码。\n1// UVa514 Rails 2#include \u0026lt;cstdio\u0026gt; 3#include \u0026lt;stack\u0026gt; 4#include \u0026lt;string\u0026gt; 5 6using namespace std; 7const int MAXN = 1000 + 10; 8 9int n, target[MAXN]; 10 11int main() { 12 // 重定向输入数据，省去我们手动输入的繁琐 13 string relativePathToCurrentCFile = \u0026#34;./data/UVa514/input2.txt\u0026#34;; 14 // relativePathToCurrentCFile = \u0026#34;./data/UVa210/input3.txt\u0026#34;; 15 freopen(string(\u0026#34;./ch06\u0026#34; + relativePathToCurrentCFile.substr(1, relativePathToCurrentCFile.size() - 1)).c_str(), \u0026#34;r\u0026#34;, stdin); 16 17 while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1) { // 读取 N 18 if (n == 0) { 19 break; 20 } 21 while (true) { 22 scanf(\u0026#34;%d\u0026#34;, \u0026amp;target[1]); // 读取序列的第一个数 23 if (target[1] == 0) { // 如果是 0，那么，说明当前这个样例结束了 24 printf(\u0026#34;\\n\u0026#34;); 25 break; 26 } 27 for (int i = 2; i \u0026lt;= n; i++) // 继续读入 28 scanf(\u0026#34;%d\u0026#34;, \u0026amp;target[i]); 29 30 stack\u0026lt;int\u0026gt; s; // 利用 stack 来进行模拟处理 31 int A = 1, B = 1; 32 int ok = 1; 33 while (B \u0026lt;= n) { 34 if (A == target[B]) { // 当前的车厢和 target 在 B 这个位置所要求的车厢是相同的，那么不用经过 station 直接进入左边的轨道即可 35 A++; 36 B++; 37 } else if (!s.empty() \u0026amp;\u0026amp; s.top() == target[B]) { // 栈的顶部符合条件 38 s.pop(); 39 B++; 40 } else if (A \u0026lt;= n) // 目前没有符号条件的，就入栈 41 s.push(A++); 42 else { // 越界了都没有找到 43 ok = 0; 44 break; 45 } 46 } 47 printf(\u0026#34;%s\\n\u0026#34;, ok ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); 48 } 49 } 50 51 return 0; 52} ","permalink":"http://localhost:1313/posts/uva514/","summary":"\u003cp\u003e《算法竞赛入门经典》(第二版) 第 6 章例题 6-2。\u003c/p\u003e\n\u003ch2 id=\"题意\"\u003e题意\u003c/h2\u003e\n\u003cp\u003e这一题的题面较短，其中英文原题也比较容易理解，所以，我们直接分析题意和代码。\u003c/p\u003e\n\u003cp\u003e本题的题意是右边有一列火车向左开，一列火车可以有很多个车厢，单个车厢来到岔路口的时候，可以选择直接进入 B 轨道，也可以选择在 Station 里面暂存一下，但是 Station 相当于是一个 stack，所以，遵循后进先出的规则。\u003c/p\u003e","title":"UVa514"},{"content":"首先，放我在 v 站的质疑的帖子，基本信息都在这个里面了。\nhttps://www.v2ex.com/t/1072947\n惯例，先叠甲：我卑怯、胆小、狡猾、懦弱（EVA 真嗣语）。\n还有该死的好奇心，不，纯粹是我要当正义的伙伴！(卫宫士郎语)\n要是我输，我 TM 直播吃键盘(开玩笑，但是肯定会道歉的，而且是郑重道歉)。\n我呢，就来发出一点不同的声音，因为我看见评论区的意见的一致的，而刚好我也有些疑问。\n那么，这个视频的主体内容就是读评论了，不过，不是读在该 UP 视频下的评论。\n也可以看一看我自己对于争论的态度，我不反对，声音当然是越多越好，信息越多，越有利于大家判断。\nhttps://www.bilibili.com/video/BV1BsYSe1EGY/?spm_id_from=333.999.0.0\u0026vd_source=452591e6eeff36707902db6872a46580\n我其实不太讨厌培训班的人，因为他们好歹可以把成体系的知识传授给大家，而且，挣钱就挣钱，卖课就卖课，不寒碜。\n最后，本视频应该不涉及违规内容，而且我自己认为应该算是合理的一种质疑？如果大家认为我是在蹭热度，忌妒人家导致人红是非多，我权且接受，大家都来攻击我吧。\n再最后，本人逻辑极差，表达内容可能有失偏颇的地方，希望大家海涵。以及，我自己的代码水平极差，大家随便喷。\n希望审核放过。\n","permalink":"http://localhost:1313/posts/questioning-a-bilibili-up-dhwass/","summary":"\u003cp\u003e首先，放我在 v 站的质疑的帖子，基本信息都在这个里面了。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.v2ex.com/t/1072947\"\u003ehttps://www.v2ex.com/t/1072947\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e惯例，先叠甲：我卑怯、胆小、狡猾、懦弱（EVA 真嗣语）。\u003c/p\u003e\n\u003cp\u003e还有该死的好奇心，不，纯粹是我要当正义的伙伴！(卫宫士郎语)\u003c/p\u003e","title":"简要质疑一下 DHwass 的编程水平"},{"content":"这一集视频我们来看一下第二章的第一节。从这一集视频开始，我决定只讲代码和我认为需要挑出来讲解的难点/细节，对于难点和细节，我决定以提出问题和解决问题的形式来呈现。关于代码，基本只讲书上出现过的代码，实在有需要我再自己补充代码。毕竟基础知识的话，我觉得书上写的已经足够详细了，我再复述一遍没什么太多的意义，所以，大家看书的话，常看常新呀，总之就是一定要常看。\n因为代码是更加直观的东西，并且，我们最终都是要去实际地写代码的。所以，我这里将着重去讲解书上出现的每一处代码，我认为能够理解代码，并且把这些代码实际应用到我们实际的项目中去，这才是真正有意义的事情。\n如果我们能做到完全理解书上的这些代码，做到看到这些代码时心中有底，我觉得那就是胜利。同时，如果习题里面有涉及代码的部分，我们也不会错过。\n尽量做到：一切都在代码中。这样，如果有人问，你读过这本书吗？我们可以很有底气地说，读过，毕竟，代码全都掌握了，难道还不算读过吗？\n这里还要额外多说一点，就是，从这一章开始，我在视频中演示代码所使用的编辑器将换到 neovim + neovide 这样一个组合，然后，在 Windows 平台下，我会使用 pwsh 也就是 powershell 脚本来进行自动化编译和运行，而在 Linux 中，我将使用 shell 脚本来自动化编译和运行。当然，构建工具使用的肯定是 cmake。\n那么，就直接看代码吧。\n说明：代码的命名规范依然以英文原版书中出现的代码的页码为指导原则。\nPart1 英文原书 p32,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int i = 1; 6 int j = 2; 7 i = i + j; 8 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 9 10 return 0; 11} 个人对英文原书 32 页补充代码，custom_p32.cpp,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // bool 类型，通常大小为 1 个字节 6 bool boolean = true; 7 std::cout \u0026lt;\u0026lt; \u0026#34;bool: \u0026#34; \u0026lt;\u0026lt; boolean \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(boolean) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 8 9 // char 类型，8 bits 10 char character = \u0026#39;A\u0026#39;; 11 std::cout \u0026lt;\u0026lt; \u0026#34;char: \u0026#34; \u0026lt;\u0026lt; character \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(character) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 12 13 // wchar_t 类型，宽字符，16 bits 或 32 bits，取决于平台 14 wchar_t wide_character = L\u0026#39;A\u0026#39;; 15 std::wcout \u0026lt;\u0026lt; \u0026#34;wchar_t: \u0026#34; \u0026lt;\u0026lt; wide_character \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(wide_character) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 16 17 // char16_t 类型，16 bits Unicode 字符 18 char16_t unicode_16 = u\u0026#39;A\u0026#39;; 19 std::wcout \u0026lt;\u0026lt; \u0026#34;char16_t: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;wchar_t\u0026gt;(unicode_16) \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(unicode_16) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 20 21 // char32_t 类型，32 bits Unicode 字符 22 char32_t unicode_32 = U\u0026#39;A\u0026#39;; 23 std::wcout \u0026lt;\u0026lt; \u0026#34;char32_t: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;wchar_t\u0026gt;(unicode_32) \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(unicode_32) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 24 25 // short 整数类型，16 bits 26 short short_integer = 16; 27 std::cout \u0026lt;\u0026lt; \u0026#34;short: \u0026#34; \u0026lt;\u0026lt; short_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(short_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 28 29 // int 整数类型，通常至少为 32 bits，但某些系统上可能为 16 bits 30 int integer = 26; 31 std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 32 33 // long 整数类型，通常为 32 bits 34 long long_integer = 36; 35 std::cout \u0026lt;\u0026lt; \u0026#34;long: \u0026#34; \u0026lt;\u0026lt; long_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(long_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 36 37 // long long 整数类型，64 bits 38 long long long_long_integer = 46LL; 39 std::cout \u0026lt;\u0026lt; \u0026#34;long long: \u0026#34; \u0026lt;\u0026lt; long_long_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(long_long_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 40 41 // float 单精度浮点数，精度为 6 位有效数字 42 float single_precision = 3.1f; 43 std::cout \u0026lt;\u0026lt; \u0026#34;float: \u0026#34; \u0026lt;\u0026lt; single_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(single_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; FLT_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 44 45 // double 双精度浮点数，精度为 10 位有效数字 46 double double_precision = 3.14; 47 std::cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; double_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(double_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; DBL_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 48 49 // long double 扩展精度浮点数，通常与 double 相同，但某些系统上可能有更高精度 50 long double extended_precision = 3.1415L; 51 std::cout \u0026lt;\u0026lt; \u0026#34;long double: \u0026#34; \u0026lt;\u0026lt; extended_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(extended_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; LDBL_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 52 53 return 0; 54} 关于这些基本类型，如果有时间的话，推荐大家去看《深入理解计算机系统(第三版)》这本书，英文名是：Computer Systems: A Programmer\u0026rsquo;s Perspective (3rd Edition)，也就是大名鼎鼎的 CSAPP。就拿浮点数来说，这个是我当时完整看过的，所以能够安心地给出评价，那就是如果你想理解浮点数真正的构造及原理，那么，可以抽空看一下这本书。\n那么，如果仅仅停留在本书需要理解的程度，那么，我们就像上面这样写几行代码就可以了解怎么去使用了，\n使用微软的 MSVC 编译器运行的结果如下，\n1bool: 1 (size: 1 bytes) 2char: A (size: 1 bytes) 3wchar_t: A (size: 2 bytes) 4char16_t: A (size: 2 bytes) 5char32_t: A (size: 4 bytes) 6short: 16 (size: 2 bytes) 7int: 26 (size: 4 bytes) 8long: 36 (size: 4 bytes) 9long long: 46 (size: 8 bytes) 10float: 3.1 (size: 4 bytes, precision: 6 significant digits) 11double: 3.14 (size: 8 bytes, precision: 15 significant digits) 12long double: 3.1415 (size: 8 bytes, precision: 15 significant digits) 这里为什么有些尺寸感觉和书上有差异呢？因为书上写的是标准规定的只是最小尺寸，然后在此基础上编译器可以自由发挥。\nPart2 类型转换 p35,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 bool b = 42; // b is true 6 std::cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 7 int i = b; // i has value 1 8 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 9 i = 3.14; // i has value 3 10 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 11 double pi = i; // pi has value 3.0 12 std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; 13 unsigned char c = -1; // assuming 8-bit chars, c has value 255 14 std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; 15 std::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(c) \u0026lt;\u0026lt; std::endl; 16 signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined 17 std::cout \u0026lt;\u0026lt; c2 \u0026lt;\u0026lt; std::endl; 18 std::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(c2) \u0026lt;\u0026lt; std::endl; 19 return 0; 20} p36_1,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int i = 42; 6 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 7 if (i) // condition will evaluate as true 8 i = 0; 9 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 10 return 0; 11} p36_2,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u = 10; 6 int i = -42; 7 std::cout \u0026lt;\u0026lt; i + i \u0026lt;\u0026lt; std::endl; // prints -84 8 std::cout \u0026lt;\u0026lt; u + i \u0026lt;\u0026lt; std::endl; // if 32-bit ints, prints 4294967264 9 10 return 0; 11} 这里书上的解释有点问题，英文原版里面是让我们去看上面的案例，这里中文翻译多给了一些解释，但是这个解释不太能够让人理解，我们还是按照上面的取模的解释来。而对于给负数取模，我们可以把其想象成反方向拨动时钟，然后，从 0 到指针之间的距离就是我们所求的取模后的余数。\np37_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u1 = 42, u2 = 10; 6 std::cout \u0026lt;\u0026lt; u1 - u2 \u0026lt;\u0026lt; std::endl; // ok: result is 32 7 std::cout \u0026lt;\u0026lt; u2 - u1 \u0026lt;\u0026lt; std::endl; // ok: but the result will wrap around 8 9 return 0; 10} p37_02,\n1// 这里需要看一下中文版 p11 也的练习题第 2 题 2#include \u0026lt;iostream\u0026gt; 3 4int main(int argc, char *argv[]) 5{ 6 for (int i = 10; i \u0026gt;= 0; --i) 7 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 8 9 return 0; 10} 按：这里可以到 1.4.1 节(英文 p13)的练习那里去看一下。\np37_03,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 /* 6 // WRONG: u can never be less than 0; the condition will always succeed 7 for (unsigned u = 10; u \u0026gt;= 0; --u) 8 std::cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; std::endl; 9 */ 10 return 0; 11} p37_04,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u = 11; // start the loop one past the first element we want to print 6 while (u \u0026gt; 0) 7 { 8 --u; // decrement first, so that the last iteration will print 0 9 std::cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; std::endl; 10 } 11 12 return 0; 13} Part3 字面值常量 p38_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int a = 20; // 十进制 6 int b = 024; // 八进制 7 int c = 0x14; // 十六进制 8 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; 9 return 0; 10} p38_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 double a = 3.14159; 6 double b = 3.14159E0; 7 double c = 0.; 8 double d = 0e0; 9 double e = .001; 10 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; std::endl; 11 return 0; 12} p39_01,\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3 4int main() 5{ 6 char a = \u0026#39;a\u0026#39;; 7 std::string b = \u0026#34;Hello World!\u0026#34;; 8 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 9 return 0; 10} p39_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // multiline string literal 6 std::cout \u0026lt;\u0026lt; \u0026#34;a really, really long string literal \u0026#34; 7 \u0026#34;that spans two lines\u0026#34; \u0026lt;\u0026lt; std::endl; 8 return 0; 9} p39_03,\n1#include \u0026lt;cstdio\u0026gt; 2#include \u0026lt;iostream\u0026gt; 3 4int main() 5{ 6 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\nWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 7 std::cout \u0026lt;\u0026lt; \u0026#34;Name\\tAge\u0026#34; \u0026lt;\u0026lt; std::endl; 8 std::cout \u0026lt;\u0026lt; \u0026#34;\\a\u0026#34; \u0026lt;\u0026lt; std::endl; 9 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\vWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 10 std::cout \u0026lt;\u0026lt; \u0026#34;Helloo\\b World\u0026#34; \u0026lt;\u0026lt; std::endl; 11 std::cout \u0026lt;\u0026lt; \u0026#34;He said, \\\u0026#34;Hello!\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; std::endl; 12 std::cout \u0026lt;\u0026lt; \u0026#34;C:\\\\Program Files\u0026#34; \u0026lt;\u0026lt; std::endl; 13 std::cout \u0026lt;\u0026lt; \u0026#34;What\\?\u0026#34; \u0026lt;\u0026lt; std::endl; 14 std::cout \u0026lt;\u0026lt; \u0026#34;It\\\u0026#39;s a cat\u0026#34; \u0026lt;\u0026lt; std::endl; 15 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\rWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 16 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\fWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 17 getchar(); 18 return 0; 19} p39_04,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints a newline 6 std::cout \u0026lt;\u0026lt; \u0026#34;\\tHi!\\n\u0026#34;; // prints a tab followd by \u0026#34;Hi!\u0026#34; and a newline 7 return 0; 8} p39_05,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#34;\\7\u0026#34;; // 在一些环境下会发出提示音，和 \\a 相同 6 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\12World\u0026#34;; // 输出： 7 // Hello 8 // World 9 // 实际效果等同于 \\n 10 11 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\40World\u0026#34;; // 输出：Hello World （插入一个空格） 12 13 char str[] = \u0026#34;Hello\\0World\u0026#34;; 14 std::cout \u0026lt;\u0026lt; str; // 输出：Hello （由于\\0表示字符串结束，World部分不会被输出） 15 16 std::cout \u0026lt;\u0026lt; \u0026#34;\\115\u0026#34;; // 输出：M 17 18 std::cout \u0026lt;\u0026lt; \u0026#34;\\x4d\u0026#34;; // 输出：M 19 return 0; 20} p40_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#34;Hi \\x4dO\\115!\\n\u0026#34;; // prints Hi MOM! followed by a newline 6 std::cout \u0026lt;\u0026lt; \u0026#39;\\115\u0026#39; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints M followed by a newline 7 return 0; 8} p40_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // 1. L\u0026#39;a\u0026#39; - wide character literal (wchar_t) 6 wchar_t wideChar = L\u0026#39;a\u0026#39;; 7 std::wcout \u0026lt;\u0026lt; L\u0026#34;Wide character literal: \u0026#34; \u0026lt;\u0026lt; wideChar \u0026lt;\u0026lt; std::endl; 8 9 // 2. u8\u0026#34;hi!\u0026#34; - UTF-8 string literal 10 const char *utf8String = u8\u0026#34;hi!\u0026#34;; 11 std::cout \u0026lt;\u0026lt; \u0026#34;UTF-8 string literal: \u0026#34; \u0026lt;\u0026lt; utf8String \u0026lt;\u0026lt; std::endl; 12 13 // 3. 42ULL - unsigned long long literal 14 unsigned long long ullValue = 42ULL; 15 std::cout \u0026lt;\u0026lt; \u0026#34;Unsigned long long literal: \u0026#34; \u0026lt;\u0026lt; ullValue \u0026lt;\u0026lt; std::endl; 16 17 // 4. 1E-3F - single-precision floating-point literal (float) 18 float floatValue = 1E-3F; 19 std::cout \u0026lt;\u0026lt; \u0026#34;Single-precision floating-point literal: \u0026#34; \u0026lt;\u0026lt; floatValue \u0026lt;\u0026lt; std::endl; 20 21 // 5. 3.14159L - extended-precision floating-point literal (long double) 22 long double longDoubleValue = 3.14159L; 23 std::cout \u0026lt;\u0026lt; \u0026#34;Extended-precision floating-point literal: \u0026#34; \u0026lt;\u0026lt; longDoubleValue \u0026lt;\u0026lt; std::endl; 24 25 return 0; 26} p41,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() { 4 5 bool test = false; 6 std::cout \u0026lt;\u0026lt; test \u0026lt;\u0026lt; std::endl; 7 return 0; 8} ","permalink":"http://localhost:1313/posts/cpp-primer-ch02-1/","summary":"\u003cp\u003e这一集视频我们来看一下第二章的第一节。从这一集视频开始，我决定只讲代码和我认为需要挑出来讲解的难点/细节，对于难点和细节，我决定以提出问题和解决问题的形式来呈现。关于代码，基本只讲书上出现过的代码，实在有需要我再自己补充代码。毕竟基础知识的话，我觉得书上写的已经足够详细了，我再复述一遍没什么太多的意义，所以，大家看书的话，常看常新呀，总之就是一定要常看。\u003c/p\u003e","title":"C++ Primer 第五版 2.1  笔记"},{"content":"本节主要的内容只有一份代码，就是标题所说的书店程序，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item total; // variable to hold data for the next transaction 6 // read the first transaction and ensure that there are data to process 7 if (std::cin \u0026gt;\u0026gt; total) 8 { 9 Sales_item trans; // variable to hold the running sum 10 // read and process the remaining transactions 11 while (std::cin \u0026gt;\u0026gt; trans) 12 { 13 // if we’re still processing the same book 14 if (total.isbn() == trans.isbn()) 15 total += trans; // update the running total 16 else 17 { 18 // print results for the previous book 19 std::cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; std::endl; 20 total = trans; // total now refers to the next book 21 } 22 } 23 std::cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; std::endl; // print the last transaction 24 } 25 else 26 { 27 // no input! warn the user 28 std::cerr \u0026lt;\u0026lt; \u0026#34;No data?!\u0026#34; \u0026lt;\u0026lt; std::endl; 29 return -1; // indicate failure 30 } 31 return 0; 32} 33 34/* input: 350-201-70353-X 4 24.99 360-201-82470-1 4 45.39 370-201-88954-4 2 15.00 380-201-88954-4 5 12.00 390-201-88954-4 7 12.00 400-201-88954-4 2 12.00 410-399-82477-1 2 45.39 420-399-82477-1 3 45.39 430-201-78345-X 3 20.00 440-201-78345-X 2 25.00 45*/ 可能有同志会注意到这个程序在读取输入的时候，最后可能需要先回车一下，然后按下 Ctrl + Z 然后再回车，才能使程序接收到 EOF(end of file) 信号，这个问题我们只需要知道如何去规避即可，如果想刨根究底，那么，也没有问题，推荐去看以下两个链接，主要是第二个链接，\nhttps://stackoverflow.com/questions/1782080/what-is-eof-in-the-c-programming-language https://stackoverflow.com/questions/5655112/why-do-i-require-multiple-eof-ctrlz-characters ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-6/","summary":"\u003cp\u003e本节主要的内容只有一份代码，就是标题所说的书店程序，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026#34;Sales_item.h\u0026#34;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eSales_item\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// variable to hold data for the next transaction\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// read the first transaction and ensure that there are data to process\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eSales_item\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// variable to hold the running sum\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// read and process the remaining transactions\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e// if we’re still processing the same book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisbn\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisbn\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// update the running total\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e18\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e// print results for the previous book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e19\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e20\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// total now refers to the next book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e21\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e22\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e23\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// print the last transaction\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e24\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e25\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e26\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e27\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// no input! warn the user\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e28\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecerr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;No data?!\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e29\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// indicate failure\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e30\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e31\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e32\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e33\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e34\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/* input:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e35\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-70353-X 4 24.99\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e36\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-82470-1 4 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e37\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 2 15.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e38\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 5 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e39\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 7 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e40\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 2 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e41\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-399-82477-1 2 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e42\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-399-82477-1 3 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e43\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-78345-X 3 20.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e44\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-78345-X 2 25.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e45\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可能有同志会注意到这个程序在读取输入的时候，最后可能需要先回车一下，然后按下 Ctrl + Z 然后再回车，才能使程序接收到 EOF(end of file) 信号，这个\u003ca href=\"https://stackoverflow.com/questions/31261483/why-ctrl-z-does-not-trigger-eof\"\u003e问题\u003c/a\u003e我们只需要知道如何去规避即可，如果想刨根究底，那么，也没有问题，推荐去看以下两个链接，主要是第二个链接，\u003c/p\u003e","title":"C++ Primer 第五版 1.6 书店程序 笔记"},{"content":"这一集我们简要介绍一下类这个知识点。\n所谓的类，我们可以把它想象成一个内置的类型一样的物件，然后，和内置类型不同的点在于，类需要我们自己去设计和定义。\n这一小节主要是让我们看一下如何简单地使用一个类。\nPart1 Sales_item 类 那么，接下来接直接看代码，看一下如何简单地使用 Sales_item 这个类，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3 4int main() 5{ 6 Sales_item book; 7 8 // read ISBN, number of copies sold, and sales price 9 std::cin \u0026gt;\u0026gt; book; 10 // write ISBN, number of copies sold, total revenue, and average price 11 std::cout \u0026lt;\u0026lt; book \u0026lt;\u0026lt; std::endl; 12 13 return 0; 14} 这里插一句，书中的代码也可以直接到配套网站去下载，\nhttps://www.informit.com/store/c-plus-plus-primer-9780321714114\n书上有些没有给出的代码，但是配套代码给出了，那么，对于这一部分，我们就去到配套代码那里给取过来。比如，我们这里的代码想要跑通，就得把 Sales_item.h 这个头文件给复制过来。\n然后，是第二份代码，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item item1, item2; 6 std::cin \u0026gt;\u0026gt; item1 \u0026gt;\u0026gt; item2; // read a pair of transactions 7 std::cout \u0026lt;\u0026lt; item1 + item2 \u0026lt;\u0026lt; std::endl; // print their sum 8 return 0; 9} 按：关于书上提到的重定向操作，在 Windows 的命令行提示符和 Linux 系统的 shell 中，确实可以像下面这样，\n1addItems \u0026lt; infile \u0026gt; outfile 但是，在 PowerShell 中，我们得用另一种语法，\n1Get-Content .\\input.txt | addItems.exe \u0026gt; .\\output.txt Part2 成员函数 然后，是成员函数的简单使用，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item item1, item2; 6 std::cin \u0026gt;\u0026gt; item1 \u0026gt;\u0026gt; item2; 7 // first check that item1 and item2 represent the same book 8 if (item1.isbn() == item2.isbn()) 9 { 10 std::cout \u0026lt;\u0026lt; item1 + item2 \u0026lt;\u0026lt; std::endl; 11 return 0; // indicate success 12 } 13 else 14 { 15 std::cerr \u0026lt;\u0026lt; \u0026#34;Data must refer to same ISBN\u0026#34; \u0026lt;\u0026lt; std::endl; 16 return -1; // indicate failure 17 } 18} 19} ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-5/","summary":"\u003cp\u003e这一集我们简要介绍一下类这个知识点。\u003c/p\u003e\n\u003cp\u003e所谓的类，我们可以把它想象成一个内置的类型一样的物件，然后，和内置类型不同的点在于，类需要我们自己去设计和定义。\u003c/p\u003e","title":"C++ Primer 第五版 1.5 类简介 笔记"},{"content":"如何让你的 VSCode 更加地 sexual？这是一个有意思的的话题，而让光标具有动画效果，可以让其更加赏心悦目，进而提升编写代码的幸福感。\n那么，今天就来介绍一下可以让 VSCode 具有光标动画的插件，只需要安装两个插件，\nApc Customize UI++ VSCode Animations 然后按照官方的文档来操作即可。它们的官方仓库的地址如下，\nhttps://github.com/drcika/apc-extension https://github.com/BrandonKirbyson/VSCode-Animations ","permalink":"http://localhost:1313/posts/vscode-make-caret-or-cursor-animations/","summary":"\u003cp\u003e如何让你的 VSCode 更加地 sexual？这是一个有意思的的话题，而让光标具有动画效果，可以让其更加赏心悦目，进而提升编写代码的幸福感。\u003c/p\u003e\n\u003cp\u003e那么，今天就来介绍一下可以让 VSCode 具有光标动画的插件，只需要安装两个插件，\u003c/p\u003e","title":"VSCode 使光标具有动画效果"},{"content":"这一集视频我们主要来看一下 C++ Primer 1.4 节。\n主要是对几个常用的控制流的语句进行说明，包括，\nwhile 循环 for 循环 读取输入 if 语句 我们这里的讲解主要是对书上示例的代码进行相应的解析，对于大家容易理解的知识点，就不去花费多余的时间来说明。删繁就简，同时，不漏疑难点。\nPart1 while 循环 首先是 while 语句，核心是理解这样一句话，\nwhile 语句反复执行一段代码，直至给定条件为假为止。\n直接看书中的示例代码，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0, val = 1; 5 // keep executing the while as long as val is less than or equal to 10 6 while (val \u0026lt;= 10) 7 { 8 sum += val; // assigns sum + val to sum 9 ++val; // add 1 to val 10 } 11 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 12 return 0; 13} Part2 for 循环 然后是 for 语句，我们更加常用的一种循环语句，\n比如，书上的例子是从 1 加到 10，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0; 5 // sum values from1 through 10 inclusive 6 for (int val = 1; val \u0026lt;= 10; ++val) 7 sum += val; // equivalent to sum = sum + val 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} for 循环后面如果不加花括号，那么，for 循环中只会执行一条语句，\n1#include \u0026lt;iostream\u0026gt; 2int main() { 3 int sum = 0; 4 // sum values from1 through 10 inclusive 5 for (int val = 1; val \u0026lt;= 10; ++val) 6 sum += val; // equivalent to sum = sum + val 7 sum += 100; 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} 11// output: 155 我们再来看加了花括号的效果，\n1#include \u0026lt;iostream\u0026gt; 2int main() { 3 int sum = 0; 4 // sum values from1 through 10 inclusive 5 for (int val = 1; val \u0026lt;= 10; ++val) { 6 sum += val; // equivalent to sum = sum + val 7 sum += 100; 8 } 9 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 10 return 0; 11} 12// output: 1055 Part3 读取输入 读取输入数据。\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0, value = 0; 5 // read until end-of-file, calculating a running total of all values read 6 while (std::cin \u0026gt;\u0026gt; value) 7 sum += value; // equivalent to sum = sum + value 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum is: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} 从键盘输入文件结束符(EOF, end of file)这里，书上说的是在 Windows 下，输入文件结束符的方法是敲 Ctrl + Z，然后按回车键，但是在上面这个程序中无法体现，因为我们只要输入的不是一个 int 值，循环就会结束，比如，我们输入 Ctrl + D 然后回车也是可以的。所以，我们可以单独写一个程序来验证一下这个文件结束符，\n1// 测试一下 Windows 下 Ctrl + Z 然后回车是否是 EOF 2#include \u0026lt;cstdio\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4 5int main() 6{ 7 int x; 8 if ((x = std::cin.get()) == EOF) 9 { 10 std::cout \u0026lt;\u0026lt; \u0026#34;Here is an EOF.\u0026#34; \u0026lt;\u0026lt; std::endl; 11 } 12 return 0; 13} 同时，这一小节中，书上还介绍了编写程序时会导致的一些编译错误，这里具体演示一下，\n语法错误 类型错误 声明错误 首先是语法错误，\n然后是类型错误，比如，\n1int a = \u0026#34;this is a string\u0026#34;; 然后是声明错误，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int v1 = 0, v2 = 0; 5 std::cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; v2; // error: uses \u0026#34;v\u0026#34; not \u0026#34;v1\u0026#34; 6 // error: cout not defined; should be std::cout 7 cout \u0026lt;\u0026lt; v1 + v2 \u0026lt;\u0026lt; std::endl; 8 return 0; 9} Part4 if 1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 // currVal is the number we’re counting; we’ll read new values into val 5 int currVal = 0, val = 0; 6 // read first number and ensure that we have data to process 7 if (std::cin \u0026gt;\u0026gt; currVal) 8 { 9 int cnt = 1; // store the count for the current value we’re processing 10 while (std::cin \u0026gt;\u0026gt; val) 11 { // read the remaining numbers 12 if (val == currVal) // if the values are the same 13 ++cnt; // add 1 to cnt 14 else 15 { // otherwise, print the count for the previous value 16 std::cout \u0026lt;\u0026lt; currVal \u0026lt;\u0026lt; \u0026#34; occurs \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; std::endl; 17 currVal = val; // remember the new value 18 cnt = 1; // reset the counter 19 } 20 } // while loop ends here 21 // remember to print the count for the last value in the file 22 std::cout \u0026lt;\u0026lt; currVal \u0026lt;\u0026lt; \u0026#34; occurs \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; std::endl; 23 } // outermost if statement ends here 24 return 0; 25} 26// input: 42 42 42 42 42 55 55 62 100 100 100 ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-4/","summary":"\u003cp\u003e这一集视频我们主要来看一下 C++ Primer 1.4 节。\u003c/p\u003e\n\u003cp\u003e主要是对几个常用的控制流的语句进行说明，包括，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewhile 循环\u003c/li\u003e\n\u003cli\u003efor 循环\u003c/li\u003e\n\u003cli\u003e读取输入\u003c/li\u003e\n\u003cli\u003eif 语句\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们这里的讲解主要是对书上示例的代码进行相应的解析，对于大家容易理解的知识点，就不去花费多余的时间来说明。删繁就简，同时，不漏疑难点。\u003c/p\u003e","title":"C++ Primer 第五版 1.4 控制流 笔记"},{"content":"《算法竞赛入门经典》(第二版) 第 6 章例题 6-1。\n题目描述 英文描述 Programs executed concurrently on a uniprocessor system appear to be executed at the same time, but in reality the single CPU alternates between the programs, executing some number of instructions from each program before switching to the next. You are to simulate the concurrent execution of up to ten programs on such a system and determine the output that they will produce.\nThe program that is currently being executed is said to be running, while all programs awaiting execution are said to be ready. A program consists of a sequence of no more than 25 statements, one per line, followed by an end statement. The statements available are listed below.\nA variable is any single lowercase alphabetic character and a constant is an unsigned decimal number less than 100. There are only 26 variables in the computer system, and they are shared among the programs. Thus assignments to a variable in one program affect the value that might be printed by a different program. All variables are initially set to zero.\nEach statement requires an integral number of time units to execute. The running program is permitted to continue executing instructions for a period of time called its quantum. When a program’s time quantum expires, another ready program will be selected to run. Any instruction currently being executed when the time quantum expires will be allowed to complete.\nPrograms are queued first-in-first-out for execution in a ready queue. The initial order of the ready queue corresponds to the original order of the programs in the input file. This order can change, however, as a result of the execution of lock and unlock statements.\nThe lock and unlock statements are used whenever a program wishes to claim mutually exclusive access to the variables it is manipulating. These statements always occur in pairs, bracketing one or more other statements. A lock will always precede an unlock, and these statements will never be nested. Once a program successfully executes a lock statement, no other program may successfully execute a lock statement until the locking program runs and executes the corresponding unlock statement. Should a running program attempt to execute a lock while one is already in effect, this program will be placed at the end of the blocked queue. Programs blocked in this fashion lose any of their current time quantum remaining. When an unlock is executed, any program at the head of the blocked queue is moved to the head of the ready queue. The first statement this program will execute when it runs will be the lock statement that previously failed. Note that it is up to the programs involved to enforce the mutual exclusion protocol through correct usage of lock and unlock statements. (A renegade program with no lock/unlock pair could alter any variables it wished, despite the proper use of lock/unlock by the other programs.)\nInput\nThe input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.\nThe first line of the input file consists of seven integers separated by spaces. These integers specify (in order): the number of programs which follow, the unit execution times for each of the five statements (in the order given above), and the number of time units comprising the time quantum. The remainder of the input consists of the programs, which are correctly formed from statements according to the rules described above.\nAll program statements begin in the first column of a line. Blanks appearing in a statement should be ignored. Associated with each program is an identification number based upon its location in the input data (the first program has ID = 1, the second has ID = 2, etc.).\nOutput\nFor each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.\nYour output will contain of the output generated by the print statements as they occur during the simulation. When a print statement is executed, your program should display the program ID, a colon, a space, and the value of the selected variable. Output from separate print statements should appear on separate lines.\nSample Input\n3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end Sample Output\n1: 3 2: 3 3: 17 3: 9 1: 9 1: 9 2: 8 2: 8 3: 21 3: 21 题目全文·中文翻译 在单处理器系统上并发执行的程序看起来像是同时执行的，但实际上单个 CPU 在多个程序之间交替执行，在切换到下一个程序之前，每个程序执行一定数量的指令。你需要模拟最多十个程序在这种系统上的并发执行，并确定它们将产生的输出。\n当前正在执行的程序称为“运行中”，而所有等待执行的程序称为“就绪”。一个程序由不超过 25 条语句的序列组成，每行一条语句，最后以一个结束语句结尾。可用的语句列在下面。\n一个变量是任何单个的小写字母字符，常量是小于 100 的无符号十进制数。系统中只有 26 个变量(按：也就是 26 个英文字母)，并且这些变量在所有程序中共享。因此，一个程序中对变量的赋值会影响其他程序可能打印的值。所有变量初始值均为零。\n每条语句的执行都需要一个整数量的时间单位。运行中的程序被允许在一个称为“时间片”的时间段内继续执行指令。当程序的时间片耗尽时，将选择另一个就绪程序来运行。当时间片到期时，正在执行的指令会被允许完成。\n程序按照先进先出的顺序排队执行，就绪队列的初始顺序与输入文件中的程序顺序相对应。然而，由于锁（lock）和解锁（unlock）语句的执行，这一顺序可能发生变化。\n当一个程序希望对其操作的变量进行互斥访问时，会使用锁和解锁语句。这些语句总是成对出现，包围一个或多个其他语句。锁语句总是先于解锁语句执行，并且这些语句不会嵌套。一旦程序成功执行锁语句，其他程序在锁定程序运行并执行相应的解锁语句之前，无法成功执行锁语句。如果一个正在运行的程序在已有锁生效时尝试执行锁语句，该程序将被放置到阻塞队列的末尾。以这种方式被阻塞的程序会失去当前剩余的时间片。当解锁语句执行时，阻塞队列头部的程序会被移到就绪队列的头部。该程序在运行时执行的第一条语句将是之前失败的锁语句。需要注意的是，互斥协议的实施依赖于程序通过正确使用锁和解锁语句来实现。（一个不遵循锁/解锁规则的流氓程序仍然可以随意修改任何变量，尽管其他程序正确使用了锁/解锁语句。）\n输入\n输入以一行包含单个正整数的行开始，表示接下来要处理的测试用例数量，每个测试用例如以下所述。该行后有一行空行，两个连续输入之间也有一行空行。\n输入文件的第一行由七个用空格分隔的整数组成。这些整数按顺序指定：后续程序的数量、五条语句的单位执行时间（按上述顺序）、以及构成时间片的时间单位数。输入的其余部分由程序组成，这些程序根据上述规则正确由语句组成。\n所有程序语句都从行的第一列开始。语句中的空格应被忽略。每个程序都有一个与其在输入数据中的位置相关的标识号（第一个程序的 ID = 1，第二个程序的 ID = 2，以此类推）。\n输出\n对于每个测试用例，输出必须遵循以下描述。两个连续测试用例的输出之间应有一个空行。\n你的输出应包含在模拟过程中由 print 语句生成的输出。当 print 语句被执行时，程序应显示程序 ID、一个冒号、一个空格，以及被选变量的值。不同 print 语句的输出应分别显示在不同的行上。\n输入样例\n3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end 输出样例\n1: 3 2: 3 3: 17 3: 9 1: 9 1: 9 2: 8 2: 8 3: 21 3: 21 注意：这里的输入样例是有问题的，修正后如下：\n1 3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end 思路分析 核心的思路就是模拟。所需要使用的数据结构是队列。普通队列和双端队列都需要。\n好吧，其实这题的关键是理解题意。看懂输入输出要干什么就可以了。\n我们先来看输入，\n第一行的 1 表示有接下来有一个 case 需要我们去处理，然后接下来的下一行是空行，这是固定的格式要求，然后，下一行是\n13 1 1 1 1 1 1 其中，3 表示接下来有 3 个 program 要并行运行。然后，\n第一个 1：赋值(Assignment)语句花费的时间。 第二个 1：输出(Output)语句花费的时间。 第三个 1：锁(lock)语句花费的时间。 第四个 1：解锁(unlock)语句花费的时间。 第五个 1：结束(end)语句花费的时间。 最后的 1 表示：cpu 会分配的时间片的长短。\n关于对题目的理解，有个地方需要注意一下，\n当时间片到期时，正在执行的指令会被允许完成。\n比如某个语句(指令)执行主要 4 个单位的时间，但是当前被分配的时间片只剩 2 个单位了，没关系，这个语句依旧会被执行。\n书中还提出了一个问题：本题不会出现越界错误，为什么？这是因为在执行插入到队首这个动作之前，队首的元素已经被 pop 出来进行处理了，所以队首总是空着一个位置的，这时如果想要插入一个元素到队首，自然不会发生越界的情况。\n那么，本题的思路，说起来其实很简单：\n先把所有的程序按照输入的顺序放入 ready 队列中； 然后，逐个从队列中 pop 出程序进行处理。 具体的处理过程如下，\n如果当前这次时间片用完了，但是程序还没有执行完，那么，记录当前执行到的位置，再将程序放入 ready 队列中； 当前运行到了程序结尾，此程序生命周期结束，无需额外操作； 如果遇到了 lock 语句，那么，根据当前是否有其他程序上了锁来进行处理； 如果已经被上锁，那么，将当前程序放入 block 队列，时间片如果还没用完，那么，也作废了； 如果还没有被上锁，那么，进行上锁操作(这里其实就是设置以下 locked 这个全局变量)，然后还是正常执行； 如果遇到了 unlock， 如果阻塞队列不为空，出队一个元素，然后，入队到 ready 的队首； 接下来还是正常运行。 代码分析 代码分析就全部在注释里面了。如果觉得不够清晰，那就再听一听我视频里面的讲解。\n主要就三个部分。\n全局变量定义 1const int maxlinecnt = 1000; // 最多 1000 行，这是一个大致的数量 2const int linecharcnt = 10; // 每一行的字符串长度不会超过 10(按：这是推断出来的，我们假定程序中没有过多的空格，否则这里就还需要再调整) 3 4deque\u0026lt;int\u0026gt; readyQ; // ready 队列 5queue\u0026lt;int\u0026gt; blockQ; // 存放被阻塞的程序的队列 6int n; // 会参与并行运行的程序的数量 7int quantum; // 时间片长度 8int c[5]; // 每个语句所需的运行时间 9int var[26]; // 最多 26 个变量 10int ip[maxlinecnt]; // ip[pid]是程序pid的当前行号。所有程序都存在prog数组，更类似真实的情况，代码也更短 11bool locked; // 是否已经被锁住 12char prog[maxlinecnt][linecharcnt]; // 存储所有程序的指令，每个程序的每条指令都是一行字符串 主要的模拟函数 1void run(int pid) { 2 int q = quantum; 3 while (q \u0026gt; 0) { 4 char *p = prog[ip[pid]]; // 取出 pid 号程序中当前该运行的那一行 5 switch (p[2]) { // 根据第 3 个字符来判断 6 case \u0026#39;=\u0026#39;: // 赋值 7 var[p[0] - \u0026#39;a\u0026#39;] = isdigit(p[5]) ? (p[4] - \u0026#39;0\u0026#39;) * 10 + p[5] - \u0026#39;0\u0026#39; : p[4] - \u0026#39;0\u0026#39;; 8 q -= c[0]; 9 break; 10 case \u0026#39;i\u0026#39;: // 打印 11 printf(\u0026#34;%d: %d\\n\u0026#34;, pid + 1, var[p[6] - \u0026#39;a\u0026#39;]); 12 q -= c[1]; 13 break; 14 case \u0026#39;c\u0026#39;: // lock 15 if (locked) { 16 blockQ.push(pid); // 放入阻塞队列 17 return; 18 } 19 locked = true; 20 q -= c[2]; 21 break; 22 case \u0026#39;l\u0026#39;: // unlock 23 locked = false; 24 if (!blockQ.empty()) { 25 int pid2 = blockQ.front(); 26 blockQ.pop(); 27 readyQ.push_front(pid2); 28 } 29 q -= c[3]; 30 break; 31 case \u0026#39;d\u0026#39;: // end 32 return; 33 } 34 ip[pid]++; 35 } 36 readyQ.push_back(pid); 37} main 函数 主要是做一些数据的读入操作。\n1int main() { 2 // 重定向输入数据，省去我们手动输入的繁琐 3 string relativePathToCurrentCFile = \u0026#34;./data/UVa210/input1.txt\u0026#34;; 4 // relativePathToCurrentCFile = \u0026#34;./data/UVa210/input3.txt\u0026#34;; 5 freopen(string(\u0026#34;./ch06\u0026#34; + relativePathToCurrentCFile.substr(1, relativePathToCurrentCFile.size() - 1)).c_str(), \u0026#34;r\u0026#34;, stdin); 6 7 int T; // input 数据中 case 的数量 8 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 9 while (T--) { // 分别处理每一个 case 10 scanf(\u0026#34;%d %d %d %d %d %d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;c[0], \u0026amp;c[1], \u0026amp;c[2], \u0026amp;c[3], \u0026amp;c[4], \u0026amp;quantum); 11 memset(var, 0, sizeof(var)); 12 13 int line = 0; 14 for (int i = 0; i \u0026lt; n; i++) { 15 fgets(prog[line++], maxlinecnt, stdin); // 按行读取数据 16 ip[i] = line - 1; 17 while (prog[line - 1][2] != \u0026#39;d\u0026#39;) 18 fgets(prog[line++], linecharcnt, stdin); 19 readyQ.push_back(i); // 把 id 为 i 的程序入队 20 } 21 22 locked = false; // 初始值为 false 23 while (!readyQ.empty()) { 24 int pid = readyQ.front(); 25 readyQ.pop_front(); 26 run(pid); 27 } 28 if (T) 29 printf(\u0026#34;\\n\u0026#34;); 30 } 31 return 0; 32} ","permalink":"http://localhost:1313/posts/uva210/","summary":"UVa210 解题思路及代码解析","title":"UVa210"},{"content":"这一集视频我们主要来看一下 C++ Primer 1.3 节。\n从这一集视频开始，我将继续采取挑取核心重点的形式来进行解说。如果是很简单的东西，那么会简单带过，如果是需要注意或者不容易理解的细节，那么，也绝对不会漏掉。这样一来，可以一定程度上保证信息密度。整体会结合我记录的笔记来和大家讲解。当然，书中所给出的每一处示例代码，都不会跳过，这一点也请大家放心。\n并且，从这一节开始，我们将采用 CMake 来作为我们代码的构建工具，这样，我们就可以进一步把精力集中在语言学习本身了。\n这一节介绍了 C++ 的注释，内容很少。需要理解的地方，就两个点，\n单行注释 多行注释 这里，仔细看书上的示例代码，理解一下就好。\n1#include \u0026lt;iostream\u0026gt; 2/* 3 * Simple main function: 4 * Read two numbers and write their sum 5 */ 6int main() { 7 // 提示用户输入两个数 8 std::cout \u0026lt;\u0026lt; \u0026#34;Enter two numbers:\u0026#34; \u0026lt;\u0026lt; std::endl; 9 int v1 = 0, v2 = 0; // 保存我们读入的输入数据的变量 10 std::cin \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2; // 读取输入数据 11 std::cout \u0026lt;\u0026lt; \u0026#34;The sum of \u0026#34; \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; v2 \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; v1 + v2 \u0026lt;\u0026lt; std::endl; 12 return 0; 13} 然后，对于单行注释，大家放心去用即可：单行注释以双斜线（//）开始，以换行符结束。// 后面可以接任何的字符，那么，当然也包括 // 本身。\n对于多行注释，也就是用注释界定符的这个注释，需要注意一下不能嵌套。我们实际看一个例子就明白了。\n1// 不能像下面这样有嵌套，会报错 2/* 3 * 注释对 /* */ 不能嵌套 4 * “不能嵌套”几个字会被认为是源码 5 * 像剩余程序一样处理 6 */ 7int main() 8{ 9 return 0; 10} 需要注意一点，/* */ 形式的注释也可以用于单行注释。这里我们也来看一个例子，\n1int main() 2{ 3 /* 也可以用作单行注释 */ 4 return 0; 5} ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-3/","summary":"\u003cp\u003e这一集视频我们主要来看一下 C++ Primer 1.3 节。\u003c/p\u003e\n\u003cp\u003e从这一集视频开始，我将继续采取挑取核心重点的形式来进行解说。如果是很简单的东西，那么会简单带过，如果是需要注意或者不容易理解的细节，那么，也绝对不会漏掉。这样一来，可以一定程度上保证信息密度。整体会结合我记录的笔记来和大家讲解。当然，书中所给出的每一处示例代码，都不会跳过，这一点也请大家放心。\u003c/p\u003e","title":"C++ Primer 第五版 1.3 注释简介 笔记"},{"content":"本文假定读者的 Linux 环境为 Arch Linux + KDE。\nKitty 重要程度：必装。\n直接命令行安装，\n1yay -S kitty fish 重要程度：必装。\n直接命令行安装，\n1yay -S fish kitty 和 fish 安装好之后，其实就基本可以使用了。\ngcc 重要程度：必装。\n直接命令行安装，\n1yay -S gcc CMake 重要程度：必装。\n直接命令行安装，\n1yay -S cmake VSCode 重要程度：必装。\n直接命令行安装，\n1yay -S visual-studio-code-bin 安装好之后，安装几个插件，\nclangd CMake 然后，可以把 VSCode 的默认的 shell 设置成 fish。这个直接在 settings.json 配置文件中加一行配置即可，\n1\u0026#34;terminal.integrated.defaultProfile.linux\u0026#34;: \u0026#34;fish\u0026#34;, 然后，就可以新建一个项目试一下使用了。\n如果有遇到 cmake 插件让选择编译器的，记得选择 gcc，\nNeovim 首先，安装一些必要的软件，\n1yay -S nodejs 2yay -S npm 3yay -S p7zip 4yay -S bottom 5yay -S fastfetch 6yay -S fd 7yay -S gitui 8yay -S grep 9yay -S ripgrep 10yay -S starship 然后，在命令行中复制我的 neovim 配置，\n1git clone https://github.com/fanlumaster/lazyvim-archlinux.git ~/.config/nvim 然后，运行 neovim，\n1nvim 然后，在 nvim 中使用 mason 安装 clangd，\n1:MasonInstall clangd 这样一来，环境差不多就配置好了。\n对于 Linux 用户，我想对命令行应该都不陌生，所以，就不去讲配置 starship 这种比较简单的操作了。\n","permalink":"http://localhost:1313/posts/cpp-coding-environment-configuration-linux-version/","summary":"\u003cp\u003e本文假定读者的 Linux 环境为 Arch Linux + KDE。\u003c/p\u003e\n\u003ch2 id=\"kitty\"\u003eKitty\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e直接命令行安装，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eyay -S kitty\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"fish\"\u003efish\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e直接命令行安装，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eyay -S fish\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ekitty 和 fish 安装好之后，其实就基本可以使用了。\u003c/p\u003e","title":"Linux 系统下的 C++ 编程环境配置"},{"content":"Windows Terminal 重要程度：必装。\n到微软的应用商店中找到 Windows Terminal 和 Windows Terminal Perivew(预览版) 任意选择一个即可。\nPowershell7.0+ 重要程度：必装。\n下载地址：https://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\n选择这个 msi 文件进行下载，然后安装，一路默认下一步即可,\n安装好了之后，可以在 Windows Terminal 中设置一下默认启动 powershell7。\nCMake 重要程度：必装。\n前提：解决了网络的问题。\n首先，通过 scoop 安装 cmake。\n如果还没有安装 scoop，请先到 scoop 的官网安装。\n然后，执行安装命令，\n1scoop install cmake Visual Studio 篇 重要程度：必装。\n因为是需要 C++ 编译套件，所以把使用C++的桌面开发勾选上即可。需要勾选的选项，直接看我下面的截图，\nVisual Studio 直接在初始界面创建 CMake 项目即可。\nVSCode 篇 重要程度：选装。\n来到VSCode官网界面进行下载。\n下载好之后，直接一路下一步，全部按默认的来，因为现在已经 2024 年了，大家的 C 盘没有 1T 也至少 512GB 起步了，不差空间。\n安装好之后，安装几个插件，\nC/C++ CMake 然后，可以把 VSCode 的默认的 shell 设置成 powershell7。\n安装好之后，就可以写简单的 C++ 程序测试一下了。\n1#include \u0026lt;iostream\u0026gt; 2 3int main(int, char**){ 4 std::cout \u0026lt;\u0026lt; \u0026#34;哟西！\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 5} CLion 篇 重要程度：选装。\n来到官网下载安装。\n大家可以自行使用破解或者试用。\n之后新建一个项目就可以开始编写代码了。\nNeovim 篇 重要程度：选装。\n安装 Neovim，\n1scoop install neovim 安装一些常用的软件，\n1scoop install neovide 2scoop install 7zip 3scoop install bottom 4scoop install btop 5scoop install fastfetch 6scoop install fd 7scoop install gitui 8scoop install grep 9scoop install gsudo 10scoop install make 11scoop install nodejs 12scoop install ripgrep 13scoop install starship 14scoop install vcredist2022 15scoop install which 然后到 pwsh(即 powershell)复制我的 neovim 配置，\n1git clone https://github.com/fanlumaster/FanyLazyvim.git $env:LOCALAPPDATA\\nvim 然后，打开 neovim 等待其自动下载插件，配置一会儿即可，\n1nvim 然后，在 nvim 中使用 mason 安装 clangd，\n1:MasonInstall clangd 这样一来，环境差不多就配置好了。\n然后，还可以稍微配置一下 powershell，这里就简单设置一下 starship，\n1nvim $PROFILE 1Invoke-Expression (\u0026amp;starship init powershell) 参考：\n1、https://www.lazyvim.org/installation\n","permalink":"http://localhost:1313/posts/cpp-coding-environment-configuration-windows-version/","summary":"\u003ch2 id=\"windows-terminal\"\u003eWindows Terminal\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e到微软的应用商店中找到 Windows Terminal 和 Windows Terminal Perivew(预览版) 任意选择一个即可。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/VmjKSpKC/image.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"powershell70\"\u003ePowershell7.0+\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e下载地址：\u003ca href=\"https://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\"\u003ehttps://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e选择这个 msi 文件进行下载，然后安装，一路默认下一步即可,\u003c/p\u003e","title":"Windows 系统下的 C++ 编程环境配置"},{"content":"Hey 朋友们，今天我们来聊一期系列介绍的视频。\n谈一谈我接下来将要在 B 站投稿的 C++ Primer 第五版的系列视频。\n名字叫：【大学生】《C++ Primer》精读精讲\n面向人群 大学生。尤其是大一大二的学生。不限于计算机相关专业，不限文理科。计算机领域是相当包容的。因为是相当于入门课程，所以可能会比较啰唆，甚至是照本宣科，所以，高年级的同学可能没有那么多时间来观看，以及，以高年级同学的知识储备来讲，可能内容偏基础。\n我希望大家准备的东西 一台电脑。无论是运行 Windows11/10 还是 Linux 的电脑，都可以。 畅通的网络，即可以流畅地访问 Google、GitHub、Stackoverflow 等等。限于某些原因，我无法在这里给大家讲解这部分的内容，但相信大家在网上应该可以找到对应的材料，实在不行，让身边的小伙伴手把手教一下请他/她吃顿饭也成。 为什么想要出这一个系列的视频 《C++ Primer》这本书用来打基础是相当好的，但是，这本书有一个缺点，也是我认为的惟一的缺点，那就是，有那么一丢丢阅读的门槛。我相信，很多人都听说过这本书，也读过这本书，但是，真正能把这本书读完的，十中无一。我以前也没有读完，最近重新捡起来读，花费了一个月，每天大概读四五个小时，最终是把这本书读完了。也正是因为仔细读了一遍下来，才知道这本书确实是真正地好书，也就促成了我录这个视频来分享交流的契机。\n所以，我这一系列的视频，就是为了打破这个门槛。让初入校园或者刚接触编程或者刚接触 C++ 的同学能够破除阻碍，读下这本书，从而为自己的爱好打下一个良好的基础。\n使用的教材以及获取方式 教材当时是视频标题的这本《C++ Primer》第五版啦。这本书是十年前出版的，但是，我读完之后，发现其中的内容鞭辟入里，放在今天一点也不过时，同时，结合国内外的评论，发现大家的看法也都是类似的，那就是，推荐。\n豆瓣上的评分：https://book.douban.com/subject/10505113/。\n获取方式如下，\n英文版：\nhttps://zhjwpku.com/assets/pdf/books/C++.Primer.5th.Edition_2013.pdf 中文版：\nC++ Primer 中文版·第五版 或者，有条件的直接到微信读书开一个会员即可。 也可以到以下网站去检索一下：\nzlibrary 安娜的档案 我讲解的方式 对于重要的文本，逐字逐句讲解，不落下。 对于书中出现的示例代码，一个不落，全部拓展成完整的可以运行的源文件进行测试。并且，全部在视频中手动编写、编译(包括借助 IDE)、运行。代码编排的顺序大概以英文版的页码为主。 有时候可能会结合其他材料，比如：网上的技术博客、cppreference 网站、GitHub 讨论区、stackoverflow、reddit 论坛的讨论等等。 对于习题，尽量全部讲解，但是更新的速度可能比主要的章节要慢一些。视频主要的节奏还是以非习题的主体部分为主。 我的想法还是，以代码为主，希望大家能够跟我一起边看边敲。有我的视频在，大家在编写、编译、调试、运行代码的过程中，基本上是不会有什么问题的，这样就可以把精力集中在学习编程语言本身这个事情上来。\n这里还是要多说一点，就是，我讲解的内容只能保证尽量通俗，大家额外该看的资料肯定是不能少的。也希望大家多多给我提意见，我会不断改进，有好的建议我会做成补充视频的形式，供大家参考。\n我演示编写代码的工具 编译套件 命令行或者 CMake。对于演示和学习而言，这两者足够简单并且够用。\nCMake 现在也是编写 C++ 大型项目的主流工具，不过，我们在学习的过程中只会用到很简单很简单的一小部分。\n具体到编译器，那么，在 Windows 中使用微软家的 MSVC 编译套件系列；在 Linux 中使用 gcc/g++ 套件。\n操作系统 Windows11 Arch Linux KDE(wayland) 代码编辑器/IDE 主要是 Neovim + Neovide。然后借助 Powershell 脚本或者 shell 脚本来自动化 CMake 的编译过程，然后运行。\n我的 Neovim 配置是公开的，我把它们放在了我另一个 GitHub 帐号中：\nWindows 中的 Neovim 配置：https://github.com/fanlumaster/FanyLazyvim Linux 中的 Neovim 配置：https://github.com/fanlumaster/lazyvim-archlinux 会介绍 VSCode、Visual Studio、CLion 的使用，大家随意使用。\n我自己除了在前期的编程环境配置视频中会使用 IDE 以外，后期应该都会使用 neovim 来进行代码编写。对于代码调试，在 Windows 端我会使用 Visual Studio 或者 VSCode；在 Linux 我会使用 gdb 或者 VSCode。\n终端工具 或者，大家也可以称其为命令行工具。\nWindows 下，建议使用 Windows Terminal + Powershell7 Linux 下，建议使用 Kitty + fish 大家可能会有的一些疑问 有课时的顾虑吗？ 当然没有，这里不是大学，不是正式的老师，不用恪守严格的规则。所以，我个人对课时不设限制，不会有大学老师所说的因为课时压缩等等原因而去跳过一些内容。所以，书中所有的内容都会涉及。\n收费吗？可以转载吗？ 我都放在 B 站了(条件允许也会同步到 Youtube)，那当然是不会收费。并且，以后也不会收费。整本书的讲解都不会收费。我争取把整本书讲完，希望能够得到大家的支持。\n不管是视频还是博客，任何形式的转载、下载都是可以的，包括商业、非商业。当然，一定要注明出处哈。\n视频涉及到的文档和代码材料在哪里？ 所有的文稿都会放在我这个博客里面。并且在每个视频的简介里面附上 url 地址。\n视频中所涉及的代码材料，我都会放在我当前的这个 GitHub 中。\nup 主会讲解其他的编程语言或者算法题吗？ 大概率会。比如，我还有一些书想录制一些视频讲一下，比如，《流畅的 Python》第二版、《C 程序设计语言》K\u0026amp;R 第二版等。\n对于数据结构和算法相关，我也想录制一些《算法竞赛入门经典》第二版、《数据结构与算法分析 C 语言描述》这类的视频。\n总之，如果时间没有问题的话，我不打算给自己的题材设限。\n会有一些小项目之类的视频吗？ 会有的。目前的想法是先把一门完整的编程语言讲完，后续会录制项目相关视频。\n当然，希望大家不要有太多的期待。因为我并不会整一些培训班的项目，可能顶多就是一些小游戏、或者像是在屏幕中显示键盘按下的按键、中文输入法开发这样的小众的项目。这也和我录制这些视频的初衷相吻合，我录制视频的目的并非是面向找工作，而且希望大家真的能够为了自己喜欢的编程奉献一点时间。\n可以私信问 up 问题吗？ 当然可以，不过，更建议以评论的方式留言，这样，我漏掉的时候还会有其他朋友来帮助回答。\n欢迎多多评论。无论是在 B 站还是我这个博客下面。\n声明 本人水平有限，欢迎随便喷。可以在视频的评论区吐槽，可以在博客的评论区留言，如果有理有据，那当然是更好啦，承诺：遇到错误，一定修正。\n以及，有时间会做字幕，没空的时候就不加字幕了，望担待。\n好，本期视频的前言就介绍到这里，下一期视频，我们将讲解 Windows 和 Linux 系统中 C++ 编程环境的搭建。\n","permalink":"http://localhost:1313/posts/bilibili-cpp-primer-0-1-preface/","summary":"\u003cp\u003eHey 朋友们，今天我们来聊一期系列介绍的视频。\u003c/p\u003e\n\u003cp\u003e谈一谈我接下来将要在 B 站投稿的 C++ Primer 第五版的系列视频。\u003c/p\u003e\n\u003cp\u003e名字叫：【大学生】《C++ Primer》精读精讲\u003c/p\u003e\n\u003ch2 id=\"面向人群\"\u003e面向人群\u003c/h2\u003e\n\u003cp\u003e大学生。尤其是大一大二的学生。不限于计算机相关专业，不限文理科。计算机领域是相当包容的。因为是相当于入门课程，所以可能会比较啰唆，甚至是照本宣科，所以，高年级的同学可能没有那么多时间来观看，以及，以高年级同学的知识储备来讲，可能内容偏基础。\u003c/p\u003e","title":"Bilibili C++ Primer 精读精讲 ch0-1 前言"},{"content":"编程体验 CS 相关的同学比较感兴趣。\n首先看编程语言。\n简单起见，就稍微看一下 C++ 和 Python 这两门语言在 Arch + KDE 上的表现如何。\n然后，看编程工具。同时我们想要看一下代码的提示功能如何。\nNeovim: 弄潮儿，Neovide VSCode Godot 然后，是终端，\nkitty 日常工具 输入法 pdf 阅读工具 浏览器 goldendict 音乐体验 telegram ","permalink":"http://localhost:1313/posts/is-arch-kde-wayland-good-for-daily-use/","summary":"\u003ch2 id=\"编程体验\"\u003e编程体验\u003c/h2\u003e\n\u003cp\u003eCS 相关的同学比较感兴趣。\u003c/p\u003e\n\u003cp\u003e首先看编程语言。\u003c/p\u003e\n\u003cp\u003e简单起见，就稍微看一下 C++ 和 Python 这两门语言在 Arch + KDE 上的表现如何。\u003c/p\u003e\n\u003cp\u003e然后，看编程工具。同时我们想要看一下代码的提示功能如何。\u003c/p\u003e","title":"Arch Linux KDE 适合我们作为一个日常的操作系统去使用吗？"},{"content":"前言 首先，建议大家读一下原题目，题目的内容这里就不放了，大家可以到这个地址去下载: https://vjudge.net/problem/UVA-12569，有些人可能说英文不太好，那么，也没关系，除了查字典，现在还可以使用这个翻译插件：沉浸式翻译，总之，现在英语语言层面的问题是不会有问题的。\n为什么我建议大家读原题目呢？虽然我们大家接触到这个题目可能都是通过刘汝佳的这本《算法竞赛入门经典》才选择去看的，但是，书中给出的描述都是很略的，简单讲一点，题目很重要的输入和输出样例数据，书上一般都是没有的，其他的细节更不必说。大概就这样。\n然后，我们来详细研究一下 UVa12569 这道题的思路和解析。\n这道题整体的思路是 BFS。然后代码参考(可能有我的微小调整)的是《算法竞赛入门经典-习题与解答》的配套代码，GitHub 地址为：https://github.com/sukhoeing/aoapc-bac2nd-keys。\n此外，如果我们想要更多的测试数据，这个 udebug 的网站也是必不可少的：https://www.udebug.com。本题的测试数据地址为：https://www.udebug.com/UVa/12569。\n同时，我的代码托管在了这个地址：https://github.com/sonnycalcr/aoapc-homework。\n首先，这道题很多人可能觉得简单，我说一下我的观点：对于初学者或者算法初阶的同学来讲，这道题还是有很多值得学习的部分的。\n接下来，我挑一些关键的代码讲一下，更详细的解释在代码的注释里面。\n注意，在具体看/写代码之前，我们首先要明确一个点，题目中的编号是从 1 开始递增的，而下面我们的程序都是从 0 开始递增的。\nPart1 先看数据结构，一个是 Node，\n1struct Node { 2 int from, to; 3 Node *next; 4}; Node 是表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点，主要是用来在 State 类型中表示 path，也就是当前的状态是由上一个状态从 from 移动了机器人/石头到 to 而转化过来的。\nPart2 再看 State，\n1struct State { 2 Node *path; // 路径 3 int g; // 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 \u0026lt;= n \u0026lt;= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头 4 int len; // 路径长度，到了当前状态已经经历的长度 5 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 6 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } // 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头 7 inline void setRock(size_t i, bool val = true) { // 设置位置 i 上是否有石头 8 if (val) 9 g |= 1 \u0026lt;\u0026lt; (i + 4); // 位或操作来把第(i + 4)位来置 1 10 else 11 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); // 先取反，再用与操作来把第(i + 4)位来置 0 12 } 13 // 机器人的位置操作 14 inline int getP() const { return g \u0026amp; 15; } // 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置 15 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } // 设置机器人的位置，这里先右移再左移 4 位清除原有的数据 16}; 所谓的 State，就是当前的局面，由以下几个维度的数据构成，\npath 是路径，上面讲过了，其中保存了上一个状态转变到当前状态是移动了哪一个编号，然后又是移动到了哪一个编号，同时 next 指向了上一次状态的 path。 g 代表了整体的状态，其中，前 4 位(分别是：0, 1, 2, 3)二进制值作为一个整体可以转化成十进制，表示了当前机器人在哪个编号的位置；然后再往左取 16 位二进制 bit 位，其中每一位都代表了一个编号，比如，0 号位置的 bit 位是 (0 + 4)，也就是第 4 位，如果这一位为 1，则表示树中编号为 0 的位置上有石头，反之则没有，其它的编号依此类推。 len 表示从最原始的状态来到了当前的状态，一共走了多少步。 理解了上面的几个成员变量，就不难理解之后的几个成员函数了。\nPart3 我们再看输出运算符的重载，\n1// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的 2ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 3 if (p == NULL) 4 return os; 5 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; // 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号 6 return os; 7} 这里我们要注意，因为 Node 实际上是用来表示 State 中的 path 的，所以，并且，我们是到了最后成功到达终点时(看代码 109 行)直接打印最终的那个 State 的 path 的，而每一个 path 指向的又是上一个 State 的 path，所以，这个输出重载就达到了输出从初始的状态移动到最终目标的全部路径的目的。\nPart4 然后，我们看一下尝试移动机器人或者石头的思路，在这之前，我们先再来看一下全局变量，\n1const int MAXN = 16; // 节点的最大数量是 16，根据题目中的条件得来 2vector\u0026lt;int\u0026gt; G[MAXN]; // 图的邻接矩阵表示，题目中简化成了树(无环图) 3MemPool\u0026lt;Node\u0026gt; pool; // 链表节点分配，用 MemPool 比较好管理内存 4// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置 5// O: 每一个石头的位置编号 6// VIS: 表示某个位置是否已经 visited 过了 7int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 这个注释比较清晰了，就不多讲了。然后，让我们进入正题，来看 tryMove 这个函数，\n1// 尝试移动在点 from 上的物体(机器人或者石头) 2void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 3 int rp = s.getP(); // 获取当前状态下机器人的位置编号 4 for (auto to : G[from]) { 5 if ((to == rp) || s[to]) // to 和当前状态的机器人位置重合或者 to 的位置上有机器人 6 continue; 7 int ng = s.g; 8 if (from == rp) 9 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; // 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置 10 else 11 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); // 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置 12 if (VIS[ng]) 13 continue; // 新的状态已经访问过 14 VIS[ng] = 1; // 标记访问 15 // 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node 16 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 17 } 18} 因为 G 是邻接矩阵，我们可以利用这个特点来进行 for 循环，遍历与 from 顶点所邻接的几个顶点，尝试去移动到这些位置，然后就是一系列的细节处理，看注释比较容易理解。\nPart5 下面我们来看最终的核心的代码，\n1// bfs 2void solve() { 3 // 定义并初始化原始的状态 4 State s; 5 _for(i, 0, m) s.setRock(O[i]); 6 s.setP(S); 7 queue\u0026lt;State\u0026gt; q; 8 q.push(s); 9 VIS[s.g] = 1; // 标记当前机器人和石头的状态已经被访问过 10 // bfs 一层一层地遍历 11 while (!q.empty()) { 12 const State \u0026amp;st = q.front(); 13 int rp = st.getP(); 14 if (rp == T) { // 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数 15 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 16 return; 17 } 18 tryMove(st, rp, q); // 尝试移动机器人 19 _for(i, 0, n) if (st[i]) tryMove(st, i, q); // 尝试移动石头 20 q.pop(); 21 } 22 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; // 无法到达目的地 23} 这里就是一个纯粹的 bfs，我们定义好了原始的状态之后，然后利用队列这个数据结构一圈一圈地往外进行波纹扩散性地遍历，队列中从前往后存放的分别是第 1 圈、第 2 圈\u0026hellip;的数据，而且队列是先进先出(FIFO, First In First Out)，所以，我们可以暴力地遍历所有的情况，并且，可以保证，一旦第一次得到了想要的结果，那么，这个结果就是我们最终想要的结果。\n完整的代码和注释 以上就是关键的代码和解释了。其他的东西没什么好讲的。关于数据的输入和处理，上面也没有细讲，直接看注释即可。\n下面就是完整的代码和详细的注释：\n1#include \u0026lt;cmath\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4#include \u0026lt;queue\u0026gt; 5#include \u0026lt;vector\u0026gt; 6#include \u0026lt;fstream\u0026gt; 7 8#define _for(i, a, b) for (int i = (a); i \u0026lt; (b); ++i) 9 10using namespace std; 11 12int readint() { 13 int x; 14 cin \u0026gt;\u0026gt; x; 15 return x; 16} 17 18template \u0026lt;typename T\u0026gt; struct MemPool { 19 vector\u0026lt;T *\u0026gt; buf; 20 T *createNew() { 21 buf.push_back(new T()); 22 return buf.back(); 23 } 24 25 void dispose() { 26 for (int i = 0; i \u0026lt; buf.size(); i++) 27 delete buf[i]; 28 buf.clear(); 29 } 30}; 31 32const int MAXN = 16; // 节点的最大数量是 16 33 34struct Node { // 表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点 35 int from, to; 36 Node *next; 37}; 38 39struct State { 40 Node *path; // 路径 41 int g; // 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 \u0026lt;= n \u0026lt;= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头 42 int len; // 路径长度，到了当前状态已经经历的长度 43 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 44 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } // 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头 45 inline void setRock(size_t i, bool val = true) { // 设置位置 i 上是否有石头 46 if (val) 47 g |= 1 \u0026lt;\u0026lt; (i + 4); // 位或操作来把第(i + 4)位来置 1 48 else 49 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); // 先取反，再用与操作来把第(i + 4)位来置 0 50 } 51 // 机器人的位置操作 52 inline int getP() const { return g \u0026amp; 15; } // 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置 53 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } // 设置机器人的位置，这里先右移再左移 4 位清除原有的数据 54}; 55 56vector\u0026lt;int\u0026gt; G[MAXN]; // 图的邻接矩阵表示，题目中简化成了树(无环图) 57MemPool\u0026lt;Node\u0026gt; pool; // 链表节点分配，用 MemPool 比较好管理内存 58// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置 59// O: 每一个石头的位置编号 60// VIS: 表示某个位置是否已经 visited 过了 61int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 62Node *newNode(Node *next = NULL, int u = -1, int v = -1) { 63 Node *p = pool.createNew(); 64 p-\u0026gt;next = next, p-\u0026gt;from = u, p-\u0026gt;to = v; 65 return p; 66} 67 68// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的 69ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 70 if (p == NULL) 71 return os; 72 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; // 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号 73 return os; 74} 75 76// 尝试移动在点 from 上的物体(机器人或者石头) 77void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 78 int rp = s.getP(); // 获取当前状态下机器人的位置编号 79 for (auto to : G[from]) { 80 if ((to == rp) || s[to]) // to 和当前状态的机器人位置重合或者 to 的位置上有机器人 81 continue; 82 int ng = s.g; 83 if (from == rp) 84 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; // 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置 85 else 86 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); // 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置 87 if (VIS[ng]) 88 continue; // 新的状态已经访问过 89 VIS[ng] = 1; // 标记访问 90 // 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node 91 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 92 } 93} 94 95// bfs 96void solve() { 97 // 定义并初始化原始的状态 98 State s; 99 _for(i, 0, m) s.setRock(O[i]); 100 s.setP(S); 101 queue\u0026lt;State\u0026gt; q; 102 q.push(s); 103 VIS[s.g] = 1; // 标记当前机器人和石头的状态已经被访问过 104 // bfs 一层一层地遍历 105 while (!q.empty()) { 106 const State \u0026amp;st = q.front(); 107 int rp = st.getP(); 108 if (rp == T) { // 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数 109 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 110 return; 111 } 112 tryMove(st, rp, q); // 尝试移动机器人 113 _for(i, 0, n) if (st[i]) tryMove(st, i, q); // 尝试移动石头 114 q.pop(); 115 } 116 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; // 无法到达目的地 117} 118 119int main() { 120 // 重定向标准输入到文件 121 string relativePathToCurrentCppFile = \u0026#34;./data/UVa12569/input1.txt\u0026#34;; 122 // relativePathToCurrentCppFile = \u0026#34;./data/UVa12569/input2.txt\u0026#34;; 123 // 因为我们是在根目录下执行编译出来的可执行文件的 124 ifstream inputFile(\u0026#34;./ch07\u0026#34; + relativePathToCurrentCppFile.substr(1, relativePathToCurrentCppFile.size() - 1)); 125 if (!inputFile.is_open()) { 126 cerr \u0026lt;\u0026lt; \u0026#34;Failed to open input data file.\u0026#34; \u0026lt;\u0026lt; endl; 127 return 2; 128 } 129 streambuf *cinbuf = cin.rdbuf(); // save original buf 130 cin.rdbuf(inputFile.rdbuf()); 131 132 int K = readint(); // 读取 case 的数量，为了和 case 关键字区分，一般用 Kase 或者 K 来表示 case 133 for (int t = 1; t \u0026lt;= K; t++) { 134 memset(VIS, 0, sizeof(VIS)); // 初始化置 0 135 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; S \u0026gt;\u0026gt; T; // 读入 n m S T 136 --S; // 程序用到的编号要减 1 137 --T; // 同上 138 cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; 139 _for(i, 0, m) O[i] = readint() - 1; // 读入石头的编号，编号是从给的数据减 1 而得来 140 _for(i, 0, n) G[i].clear(); // 清除之前的数据 141 142 // 构建邻接矩阵 143 _for(i, 0, n - 1) { // 读入 n - 1 条边 144 int u = readint() - 1, v = readint() - 1; // 每一个顶点的编号都要减 1 145 G[u].push_back(v); 146 G[v].push_back(u); 147 } 148 149 solve(); 150 pool.dispose(); // 释放内存 151 cout \u0026lt;\u0026lt; endl; 152 } 153 154 // 恢复标准输入 155 cin.rdbuf(cinbuf); 156 return 0; 157} 纯净的代码 由于上面的代码我为了自己测试方便进行标准输入流重定向的处理，是不能直接提交的，所以，我在下面提供一份纯净的可以用于提交验证的代码，这里同时去除了所有的注释，因为中文字符似乎不被接受，\n1#include \u0026lt;cmath\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4#include \u0026lt;queue\u0026gt; 5#include \u0026lt;vector\u0026gt; 6 7#define _for(i, a, b) for (int i = (a); i \u0026lt; (b); ++i) 8 9using namespace std; 10 11int readint() { 12 int x; 13 cin \u0026gt;\u0026gt; x; 14 return x; 15} 16 17template \u0026lt;typename T\u0026gt; struct MemPool { 18 vector\u0026lt;T *\u0026gt; buf; 19 T *createNew() { 20 buf.push_back(new T()); 21 return buf.back(); 22 } 23 24 void dispose() { 25 for (int i = 0; i \u0026lt; buf.size(); i++) 26 delete buf[i]; 27 buf.clear(); 28 } 29}; 30 31const int MAXN = 16; 32 33struct Node { 34 int from, to; 35 Node *next; 36}; 37 38struct State { 39 Node *path; 40 int g; 41 int len; 42 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 43 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } 44 inline void setRock(size_t i, bool val = true) { 45 if (val) 46 g |= 1 \u0026lt;\u0026lt; (i + 4); 47 else 48 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); 49 } 50 51 inline int getP() const { return g \u0026amp; 15; } 52 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } 53}; 54 55vector\u0026lt;int\u0026gt; G[MAXN]; 56MemPool\u0026lt;Node\u0026gt; pool; 57 58int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 59Node *newNode(Node *next = NULL, int u = -1, int v = -1) { 60 Node *p = pool.createNew(); 61 p-\u0026gt;next = next, p-\u0026gt;from = u, p-\u0026gt;to = v; 62 return p; 63} 64 65ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 66 if (p == NULL) 67 return os; 68 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; 69 return os; 70} 71 72void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 73 int rp = s.getP(); 74 for (auto to : G[from]) { 75 if ((to == rp) || s[to]) 76 continue; 77 int ng = s.g; 78 if (from == rp) 79 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; 80 else 81 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); 82 if (VIS[ng]) 83 continue; 84 VIS[ng] = 1; 85 86 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 87 } 88} 89 90void solve() { 91 92 State s; 93 _for(i, 0, m) s.setRock(O[i]); 94 s.setP(S); 95 queue\u0026lt;State\u0026gt; q; 96 q.push(s); 97 VIS[s.g] = 1; 98 99 while (!q.empty()) { 100 const State \u0026amp;st = q.front(); 101 int rp = st.getP(); 102 if (rp == T) { 103 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 104 return; 105 } 106 tryMove(st, rp, q); 107 _for(i, 0, n) if (st[i]) tryMove(st, i, q); 108 q.pop(); 109 } 110 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; 111} 112 113int main() { 114 int K = readint(); 115 for (int t = 1; t \u0026lt;= K; t++) { 116 memset(VIS, 0, sizeof(VIS)); 117 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; S \u0026gt;\u0026gt; T; 118 --S; 119 --T; 120 cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; 121 _for(i, 0, m) O[i] = readint() - 1; 122 _for(i, 0, n) G[i].clear(); 123 124 _for(i, 0, n - 1) { 125 int u = readint() - 1, v = readint() - 1; 126 G[u].push_back(v); 127 G[v].push_back(u); 128 } 129 130 solve(); 131 pool.dispose(); 132 cout \u0026lt;\u0026lt; endl; 133 } 134 135 return 0; 136} 当然，这个代码也是可以在我的 GitHub 仓库中找到的。\n参考 1、《算法竞赛入门经典》第二版\n2、https://github.com/sukhoeing/aoapc-bac2nd-keys\n","permalink":"http://localhost:1313/posts/uva12569/","summary":"UVa12569 解题思路及代码解析","title":"UVa12569"},{"content":"这篇博客主要来聊一聊我在 Windows 端使用的终端和 Shell 软件。\n按：本篇博客大致上只是一个提纲，更详细的内容和使用体验在我的 B 站视频中，毕竟这东西不如直接用视频的形式展示出来比较直观。\n终端 Windows Terminal. Alacritty，这个之前使用过，后来放弃了。 Shell Windows 平台下也就是 pwsh7 这个软件了。其实也没什么太多好讲的，就简单介绍一下我目前使用的一些和终端相关的软件吧。\nPowerShell 7.0+ $PROFILE starship fastfetch scoop Neovim，关于 Neovim 的配置相关后面的视频中会讲，当前只是讲一下它的使用。 一些常用的命令。\n1ls 2cls 3cd 4cp 5tree 6Get-Command 如果想要一些快捷的命令的话，那么，可以去定制 pwsh 的配置文件，比如，去定制一些命令别名、函数之类。\n然后，还有一个小技巧，就是在 Neovim 中使用 pwsh，比较方便我们去复制一些内容。\n","permalink":"http://localhost:1313/posts/personal-likes-terminal-and-shell-in-windows/","summary":"\u003cp\u003e这篇博客主要来聊一聊我在 Windows 端使用的终端和 Shell 软件。\u003c/p\u003e\n\u003cp\u003e按：本篇博客大致上只是一个提纲，更详细的内容和使用体验在我的 B 站视频中，毕竟这东西不如直接用视频的形式展示出来比较直观。\u003c/p\u003e","title":"终端和 Shell 的使用之 Windows 篇"},{"content":"几个月前也简单安装过 Hyprland，在 nixos 发行版上。只是由于当时时间不够，就没有怎么深入去配置，导致最终的使用体验其实比较糟糕。所以最终是放弃了体验。\n最近时间比较多，刚好我的 KDE 出了点问题，所以，直接重装，WM(Windows Manager) 也换成了 hyprland，最终的体验还行。这里就简单分享一些我认为简易配置一下就可以获得的体验。\n提前说一下我的个人建议：好看，但不推荐。目前有太多的问题。\n按：本文更多面向的是 CS 专业在读学生，如果是非 CS 专业，但是对 CS 感兴趣、有实践的同学，那就更加 perfect 了。\n基本的使用的效果 就是一些平铺效果，这个没什么好说的。\n高分屏的适配 按照默认的配置来，其实还行。\n基本的编程软件 Kitty fish Neovim Neovide VSCode starship 这几个体验起来其实还行，只有 VSCode 需要开启 wayland 的标志，不然，缩放很有问题。\n美化和主题 暗色模式很有问题。比如，使用 dolphin，起界面调起来有一番难度。整个系统想要调整成暗色模式也很有难度。\n常用的工具 ags，标题栏和一些小组件的美化和定制。 rofi，这里我使用的 wayland 的版本，rofi-wayland，但是有一个问题：不能输入中文。 fcitx5，大部分应用是可以正常使用的。 chrome，开启了 wayland 的 flag 之后，使用起来还行。 edge，和 chrome 类似。 firefox，如果缩小到屏幕的 1/32，那么，缩放会出问题。 telegram，很不稳定。启动的时间长，缩放有一定问题，输入法偶尔失灵。 obs-studio，这个录屏的软件还是挺好用的。 很多缺失的工具 比如，截图软件，其实没有好用的。\n总结 我个人给出的结论是，不推荐使用这个系统。我们在使用一个系统的时候，其实是有很多事情要做的，因此，必须要有足够多的软件来支持，这一点 KDE 就做得非常好，而 hyprland 毕竟是一个年轻的 WM，所以，它在很多方面都有欠缺，因此，如果要作为我们的主系统的话，那么，它是很不合适的。不过，如果，仅仅是用来编写代码的副操作系统，大家大可以尝试一番，它的理念，也就是平铺式桌面的里面是相当优秀的。\n之前(大概是前天)也是因为 KDE 的 chrome 浏览器会导致 fcitx5 卡死，才一气之下换到了 hyprland，现在发现问题好像可以解决了。KDE 中的 chrome 默认使用的 x11 协议，那么，换成 wayland 其实就可以解决输入法的问题了。\n","permalink":"http://localhost:1313/posts/arch-linux-trying-hyprland/","summary":"\u003cp\u003e几个月前也简单安装过 Hyprland，在 nixos 发行版上。只是由于当时时间不够，就没有怎么深入去配置，导致最终的使用体验其实比较糟糕。所以最终是放弃了体验。\u003c/p\u003e","title":"Arch Linux Trying Hyprland"},{"content":"如何给 Kitty 设置主题呢？这个问题其实很简单，因为像这样成熟的 terminal 模拟器，必然有人在网上已经整理好了相关的 themes，通常只需要我们去 clone 一下就可以使用了。Kitty 就是如此。\n","permalink":"http://localhost:1313/posts/how-to-set-themes-for-kitty/","summary":"\u003cp\u003e如何给 Kitty 设置主题呢？这个问题其实很简单，因为像这样成熟的 terminal 模拟器，必然有人在网上已经整理好了相关的 themes，通常只需要我们去 clone 一下就可以使用了。Kitty 就是如此。\u003c/p\u003e","title":"How to Set Themes for Kitty"},{"content":"追根溯源，也就是速度、易用性和便携性。\n以前我是使用 Hexo 来建站的，而且，放到 Github 上面的是 hexo 最终渲染好的 html 文件之类，我现在发现这样特别笨重，尤其是在有多台 pc 的情况下，如果想要在不同的设备和操作系统之间进行写作，那么，这无疑是一件困难的事情。而且，每一次渲染造成的文件改动是很多的，这个在一定程度上是不利于版本管理的。而 Hugo 就很好地做到了这一点，利用 Github Actions 实现了文章与最终构建出来的产物进行分离，这样一来，我只需要把 markdown 文件托管到 Github 上面就可以了。对于 Hexo，我觉得应该也是可以做到这一点的，之所以没有去尝试，一方面懒了，另一方面，人总是想要尝试一点新鲜的东西，所以，这就转到了 Hugo。\n我之前其实建立过好多个基于 Github Pages 网站，其中，写得最多的，是这个站点，也是因为写得文章实在是有点多了，所以，hexo 在速度这一块的弊病就显现出来了，毕竟是基于 nodejs 的嘛。此外，我在之前的博客中使用的图床是 imgur，评论使用的是 disqus，这俩可谓是反面意义的卧龙凤雏了，速度都奇慢无比。有时候，imgur 的图片甚至加载不出来，应该是全球的服务器不够用。在速度这个层面上，postimage 和 Github Discussion 就要好很多，非常多。基本上只要搭了个梯子，那么，速度是没问题的。Hugo 本身由于 go 语言本身的性能，速度是相当快的，而且，在 Windows 上的表现比 Linux 中的表现差不了多少。目测 500 篇文章的生成速度应该可以保持在 5s 以内。\n","permalink":"http://localhost:1313/posts/why-i-build-another-github-pages-website/","summary":"\u003cp\u003e追根溯源，也就是速度、易用性和便携性。\u003c/p\u003e\n\u003cp\u003e以前我是使用 Hexo 来建站的，而且，放到 Github 上面的是 hexo 最终渲染好的 html 文件之类，我现在发现这样特别笨重，尤其是在有多台 pc 的情况下，如果想要在不同的设备和操作系统之间进行写作，那么，这无疑是一件困难的事情。而且，每一次渲染造成的文件改动是很多的，这个在一定程度上是不利于版本管理的。而 Hugo 就很好地做到了这一点，利用 Github Actions 实现了文章与最终构建出来的产物进行分离，这样一来，我只需要把 markdown 文件托管到 Github 上面就可以了。对于 Hexo，我觉得应该也是可以做到这一点的，之所以没有去尝试，一方面懒了，另一方面，人总是想要尝试一点新鲜的东西，所以，这就转到了 Hugo。\u003c/p\u003e","title":"谈一谈我为什么重新建立了一个 Github Pages 个人网站"},{"content":"前言 之前四五年的时间里也算写过五六百篇博客。以前的 Hexo 顶不住博客数量的压力了，所以，切到 Hugo 试一下。\n涉及工具 除了搭建博客和介绍如何使用这个博客框架这样一个流程本身，还包含了对 PaperMod 这个主题的一些细节的定制。\n本文涉及到的工具或者网站：\nhugo papermod github postimage giscus neovim/vscode git flaticon 为什么 这里主要解释一下为什么要选择这样一个组合。\n选择 hugo 纯粹是因为快。 选择 PaperMod 这个主题是因为它的 star 数量挺高的，不过，比起 hexo 的主题生态还是差得太远了，文档也相当简陋。不过，没办法，这已经算是最好的一档了。 博客选择托管在 github pages 上面是因为稳定，而且没有限制，基本上没有内容审查。我之前也使用 hexo 配合 github 搭建过静态博客，之前写过大概几百篇博客，从来没有遇到过内容审查，当然，也从来没有想过写一些很敏感的东西。 图床选择的是 postiamge，这个是免费的，类似的还有 imgur，但是 imgur 的图片加载速度在一些地方实在是堪忧甚至经常加载不出来，只好换上另一个有很多年头的网站了，正因为年纪大，所以给人的感觉是稳定。 评论使用 giscus 是因为快，因为也是使用 github 的服务，利用的是 github discussion，所以，比 discus 之类的小厂要快。稳定性倒是差不多。以及，github 的用户是比较多的，所以会更方便大家评论交流，这一点很重要。 neovim/vscode 是用来编辑配置用的，编辑工具/IDE这一点见仁见智。 git 不用多说了。 flaticon 是用来挑选网站的 favicon 的。 总结一下，就是几个词儿：免费、快、稳。\n安装 首先，安装 hugo，在 Windows 中，推荐使用 scoop 来安装预编译的二进制版本，\n1scoop install hugo-extended 安装完之后，执行命令看一下版本信息，\n1hugo version 看到类似下面的输出，就说明安装成功了，\n使用 创建博客 然后，我们就使用 hugo 在本地创建一个站点，也就是一个博客，\n按：这里可以参考 hugo 官网的指导。\n1hugo new site SonnyCalcr 然后，\n1cd SonnyCalcr 2tree . /f 可以看到默认创建的一些文件和目录，\n然后，我们先将此目录初始化成 git 仓库，\n1git init 2git add . 3git commit -m \u0026#34;first commit\u0026#34; 添加 PaperMod 主题 1git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 可以看到，这个命令执行完之后新增的内容，其实就是往 thems 目录下添加了一个主题，而 .gitmodules 则是记录了添加的这个主题的模块的信息，\n然后，我们可以再看 PaperMod 这个主题里面都有些什么文件，从下面的命令的输出可以看到，基本上就是一些 html、css 和 js 文件，毕竟是主题嘛，\n1❯ tree .\\themes\\PaperMod\\ /f 2Folder PATH listing for volume Windows 3Volume serial number is B867-6B94 4C:\\HDISK\\HUGO\\SONNYCALCR\\THEMES\\PAPERMOD 5│ go.mod 6│ LICENSE 7│ README.md 8│ theme.toml 9│ 10├───.github 11│ │ PULL_REQUEST_TEMPLATE.md 12│ │ 13│ ├───ISSUE_TEMPLATE 14│ │ bug_report.md 15│ │ config.yml 16│ │ proposal.md 17│ │ 18│ └───workflows 19│ gh-pages.yml 20│ 21├───assets 22│ ├───css 23│ │ ├───common 24│ │ │ 404.css 25│ │ │ archive.css 26│ │ │ footer.css 27│ │ │ header.css 28│ │ │ main.css 29│ │ │ post-entry.css 30│ │ │ post-single.css 31│ │ │ profile-mode.css 32│ │ │ search.css 33│ │ │ terms.css 34│ │ │ 35│ │ ├───core 36│ │ │ license.css 37│ │ │ reset.css 38│ │ │ theme-vars.css 39│ │ │ zmedia.css 40│ │ │ 41│ │ ├───extended 42│ │ │ blank.css 43│ │ │ 44│ │ └───includes 45│ │ chroma-mod.css 46│ │ chroma-styles.css 47│ │ scroll-bar.css 48│ │ 49│ └───js 50│ fastsearch.js 51│ fuse.basic.min.js 52│ license.js 53│ 54├───i18n 55│ ar.yaml 56│ be.yaml 57│ bg.yaml 58│ bn.yaml 59│ ca.yaml 60│ ckb.yaml 61│ cs.yaml 62│ da.yaml 63│ de.yaml 64│ el.yaml 65│ en.yaml 66│ eo.yaml 67│ es.yaml 68│ fa.yaml 69│ fr.yaml 70│ he.yaml 71│ hi.yaml 72│ hr.yaml 73│ hu.yaml 74│ id.yaml 75│ it.yaml 76│ ja.yaml 77│ ko.yaml 78│ ku.yaml 79│ mn.yaml 80│ ms.yaml 81│ nl.yaml 82│ no.yaml 83│ oc.yaml 84│ pa.yaml 85│ pl.yaml 86│ pnb.yaml 87│ pt.yaml 88│ ro.yaml 89│ ru.yaml 90│ sk.yaml 91│ sv.yaml 92│ sw.yaml 93│ th.yaml 94│ tr.yaml 95│ uk.yaml 96│ uz.yaml 97│ vi.yaml 98│ zh-tw.yaml 99│ zh.yaml 100│ 101├───images 102│ screenshot.png 103│ tn.png 104│ 105└───layouts 106 │ 404.html 107 │ robots.txt 108 │ 109 ├───partials 110 │ │ anchored_headings.html 111 │ │ author.html 112 │ │ breadcrumbs.html 113 │ │ comments.html 114 │ │ cover.html 115 │ │ edit_post.html 116 │ │ extend_footer.html 117 │ │ extend_head.html 118 │ │ footer.html 119 │ │ head.html 120 │ │ header.html 121 │ │ home_info.html 122 │ │ index_profile.html 123 │ │ post_canonical.html 124 │ │ post_meta.html 125 │ │ post_nav_links.html 126 │ │ share_icons.html 127 │ │ social_icons.html 128 │ │ svg.html 129 │ │ toc.html 130 │ │ translation_list.html 131 │ │ 132 │ └───templates 133 │ │ opengraph.html 134 │ │ schema_json.html 135 │ │ twitter_cards.html 136 │ │ 137 │ └───_funcs 138 │ get-page-images.html 139 │ 140 ├───shortcodes 141 │ collapse.html 142 │ figure.html 143 │ inTextImg.html 144 │ ltr.html 145 │ rawhtml.html 146 │ rtl.html 147 │ 148 └───_default 149 │ archives.html 150 │ baseof.html 151 │ index.json 152 │ list.html 153 │ rss.xml 154 │ search.html 155 │ single.html 156 │ terms.html 157 │ 158 └───_markup 159 render-image.html 然后，可以添加一下 .gitignore 文件，我这里就直接照抄 PaperMod 的作者部署的那个网站的文件了，\n1# Compiled Object files, Static and Dynamic libs (Shared Objects) 2*.o 3*.a 4*.so 5 6# Folders 7_obj 8_test 9 10# Architecture specific extensions/prefixes 11*.[568vq] 12[568vq].out 13 14*.cgo1.go 15*.cgo2.c 16_cgo_defun.c 17_cgo_gotypes.go 18_cgo_export.* 19 20_testmain.go 21 22*.exe 23*.test 24 25/public 26.DS_Store 27.hugo_build.lock 28resources/_gen/ 其实这里主要就是把 public 目录给排除掉，这个会在网页部署的时候自动生成。\n接下来就是正式的主题配置了。\n配置 PaperMod 主题 配置好之后相较于默认效果的一些改进 支持 giscus 进行评论，且主题支持明暗切换。 支持 mathjax，但是如果数学块公式中有超过三个花括号，那么，需要将整个数学公式包括外围的 $$ 符号都用 div 标签包裹起来。 代码字体自定义为 Jetbrains Mono。代码的亮色主题为 tokyo-night-light，暗色主题为 github-dark。 移动端隐藏返回顶部的按钮。 一些自定义 css 的效果，如字体大小、链接颜色、目录上的悬浮的鼠标图标等等。 主要就是上面几点，因为文档写得不详细，所以配置上面的内容花费了一些时间和工夫。\n一些基本信息的配置 首先，把博客根目录下的 hugo.toml 文件改成 hugo.yaml，因为 PaperMod 给出的配置文件就是 yaml 格式的，所以，这里改一下文件格式，就省去了我们再去将 yaml 的配置内容转为 toml 的麻烦，\n1Rename-Item .\\hugo.toml hugo.yaml 然后，配置一下基本信息，基本上每一个选项我都打上了注释，\n1baseURL: \u0026#34;https://sonnycalcr.github.io/\u0026#34; # 主站的 URL 2title: SonnyCalcr\u0026#39;s Blog # 站点标题 3copyright: \u0026#34;[©2024 SonnyCalcr\u0026#39;s Blog](https://sonnycalcr.github.io/)\u0026#34; # 网站的版权声明，通常显示在页脚 4theme: PaperMod # 主题 5languageCode: zh-cn # 语言 6 7enableInlineShortcodes: true # shortcode，类似于模板变量，可以在写 markdown 的时候便捷地插入，官方文档中有一个视频讲的很通俗 8hasCJKLanguage: true # 是否有 CJK 的字符 9enableRobotsTXT: true # 允许生成 robots.txt 10buildDrafts: false # 构建时是否包括草稿 11buildFuture: false # 构建未来发布的内容 12buildExpired: false # 构建过期的内容 13enableEmoji: true # 允许 emoji 14pygmentsUseClasses: true 15defaultContentLanguage: zh # 顶部首先展示的语言界面 16defaultContentLanguageInSubdir: false # 是否要在地址栏加上默认的语言代码 配置导航栏 1languages: 2 zh: 3 languageName: \u0026#34;中文\u0026#34; # 展示的语言名 4 weight: 1 # 权重 5 taxonomies: # 分类系统 6 category: categories 7 tag: tags 8 # https://gohugo.io/content-management/menus/#define-in-site-configuration 9 menus: 10 main: 11 - name: 首页 12 pageRef: / 13 weight: 4 # 控制在页面上展示的前后顺序 14 - name: 归档 15 pageRef: archives/ 16 weight: 5 17 - name: 分类 18 pageRef: categories/ 19 weight: 10 20 - name: 标签 21 pageRef: tags/ 22 weight: 10 23 - name: 搜索 24 pageRef: search/ 25 weight: 20 26 - name: 关于 27 pageRef: about/ 28 weight: 21 配置归档 在 content 目录下新建 archives.md 文件，内容如下，\n1--- 2title: \u0026#34;归档\u0026#34; 3layout: \u0026#34;archives\u0026#34; 4url: \u0026#34;/archives/\u0026#34; 5summary: archives 6--- 配置分类和标签 在 hugo 中，这俩是一样的。上面配置好了 taxonomies 之后，我们在博客的 front matter 中加上相关信息即可，就拿本篇博客举例，\n1title = \u0026#39;Hugo + PaperMod + Github Pages 搭建一个完善的个人博客(以 Windows11 为例)\u0026#39; 2date = 2024-08-04T03:25:53+08:00 3categories = [\u0026#34;通用技术\u0026#34;] 4tags = [\u0026#34;博客搭建\u0026#34;, \u0026#34;Bilibili\u0026#34;] 然后执行一下 hugo server 就可以在浏览器中预览一下效果了。\n配置搜索 要在 output 中加上 JSON，\n1# https://github.com/adityatelange/hugo-PaperMod/wiki/Features#search-page 2outputs: 3 home: 4 - HTML # 生成的静态页面 5 - RSS # 这个其实无所谓 6 - JSON # necessary for search, 这里的配置修改好之后，一定要重新生成一下 然后，在 content 目录下新建一个 search.md 文件，\n1--- 2title: \u0026#34;搜索\u0026#34; # in any language you want 3layout: \u0026#34;search\u0026#34; # necessary for search 4summary: \u0026#34;search\u0026#34; 5placeholder: \u0026#34;搜索\u0026#34; 6--- 然后是搜索的一些个性化设置，\n1params: 2 # 搜索 3 fuseOpts: 4 isCaseSensitive: false # 是否大小写敏感 5 shouldSort: true # 是否排序 6 location: 0 7 distance: 1000 8 threshold: 0.4 9 minMatchCharLength: 0 10 # limit: 10 # refer: https://www.fusejs.io/api/methods.html#search 11 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] 12 includeMatches: true 这样以来，搜索就可以正常工作了，\n配置关于页面 新建两个文件，一个是 layouts\\_default 目录下下的 about.html，\n1{{- define \u0026#34;main\u0026#34; }} 2 3\u0026lt;header class=\u0026#34;page-header\u0026#34;\u0026gt; 4 \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; 5 {{- if .Description }} 6 \u0026lt;div class=\u0026#34;post-description\u0026#34;\u0026gt; 7 {{ .Description }} 8 \u0026lt;/div\u0026gt; 9 {{- end }} 10 \u0026lt;/header\u0026gt; 11 12\u0026lt;section\u0026gt; 13 \u0026lt;br\u0026gt; 14 {{ .Content }} 15\u0026lt;/section\u0026gt; 16 17{{- end }}{{/* end main */}} 另一个是 content 目录下的 about.md,\n1--- 2title: \u0026#34;关于\u0026#34; 3layout: \u0026#34;about\u0026#34; 4url: \u0026#34;/about/\u0026#34; 5summary: about 6--- 7 8这里就可以写一些关于的相关信息了。 配置评论 这里的评论使用了 giscus 插件。\n先在 layouts\\partials 下新建一个 comments.html 文件，\n1\u0026lt;div id=\u0026#34;tw-comment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 2\u0026lt;script\u0026gt; 3 // 默认是暗色，根目录下的配置中的主题默认也是暗色 4 const getStoredTheme = () =\u0026gt; localStorage.getItem(\u0026#34;pref-theme\u0026#34;) === \u0026#34;light\u0026#34; ? \u0026#34;{{ .Site.Params.giscus.lightTheme }}\u0026#34; : \u0026#34;{{ .Site.Params.giscus.darkTheme }}\u0026#34;; 5 const setGiscusTheme = () =\u0026gt; { 6 const sendMessage = (message) =\u0026gt; { 7 const iframe = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); 8 if (iframe) { 9 iframe.contentWindow.postMessage({giscus: message}, \u0026#39;https://giscus.app\u0026#39;); 10 } 11 } 12 sendMessage({setConfig: {theme: getStoredTheme()}}) 13 } 14 15 document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { 16 const giscusAttributes = { 17 \u0026#34;src\u0026#34;: \u0026#34;https://giscus.app/client.js\u0026#34;, 18 \u0026#34;data-repo\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repo }}\u0026#34;, 19 \u0026#34;data-repo-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repoId }}\u0026#34;, 20 \u0026#34;data-category\u0026#34;: \u0026#34;{{ .Site.Params.giscus.category }}\u0026#34;, 21 \u0026#34;data-category-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.categoryId }}\u0026#34;, 22 \u0026#34;data-mapping\u0026#34;: \u0026#34;{{ .Site.Params.giscus.mapping }}\u0026#34;, 23 \u0026#34;data-strict\u0026#34;: \u0026#34;{{ .Site.Params.giscus.strict }}\u0026#34;, 24 \u0026#34;data-reactions-enabled\u0026#34;: \u0026#34;{{ .Site.Params.giscus.reactionsEnabled }}\u0026#34;, 25 \u0026#34;data-emit-metadata\u0026#34;: \u0026#34;{{ .Site.Params.giscus.emitMetadata }}\u0026#34;, 26 \u0026#34;data-input-position\u0026#34;: \u0026#34;{{ .Site.Params.giscus.inputPosition }}\u0026#34;, 27 \u0026#34;data-theme\u0026#34;: getStoredTheme(), 28 \u0026#34;data-lang\u0026#34;: \u0026#34;{{ .Site.Params.giscus.lang }}\u0026#34;, 29 \u0026#34;data-loading\u0026#34;: \u0026#34;lazy\u0026#34;, 30 \u0026#34;crossorigin\u0026#34;: \u0026#34;anonymous\u0026#34;, 31 }; 32 33 // 动态创建 giscus script 34 const giscusScript = document.createElement(\u0026#34;script\u0026#34;); 35 Object.entries(giscusAttributes).forEach( 36 ([key, value]) =\u0026gt; giscusScript.setAttribute(key, value)); 37 document.querySelector(\u0026#34;#tw-comment\u0026#34;).appendChild(giscusScript); 38 39 // 页面主题变更后，变更 giscus 主题 40 const themeSwitcher = document.querySelector(\u0026#34;#theme-toggle\u0026#34;); 41 if (themeSwitcher) { 42 themeSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); 43 } 44 const themeFloatSwitcher = document.querySelector(\u0026#34;#theme-toggle-float\u0026#34;); 45 if (themeFloatSwitcher) { 46 themeFloatSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); 47 } 48 }); 49\u0026lt;/script\u0026gt; 然后，根据 giscus 官网的指导，最后生成一份代码，\n然后，把相应的字段提取到配置中，\n1params: 2 # 评论的设置 3 giscus: 4 repo: \u0026#34;sonnycalcr/sonnycalcr.github.io\u0026#34; 5 repoId: \u0026#34;xxxxxx\u0026#34; 6 category: \u0026#34;Announcements\u0026#34; 7 categoryId: \u0026#34;xxxxx\u0026#34; 8 mapping: \u0026#34;pathname\u0026#34; 9 strict: \u0026#34;0\u0026#34; 10 reactionsEnabled: \u0026#34;1\u0026#34; 11 emitMetadata: \u0026#34;0\u0026#34; 12 inputPosition: \u0026#34;bottom\u0026#34; 13 lightTheme: \u0026#34;light\u0026#34; 14 darkTheme: \u0026#34;dark\u0026#34; 15 lang: \u0026#34;zh-CN\u0026#34; 16 crossorigin: \u0026#34;anonymous\u0026#34; 这样就可以正常使用了。\n配置数学公式 这里使用的是 mathjax。\n我们需要添加两个文件，一个是 layouts\\partials 下的 mathjax.html 文件，如下，\n1\u0026lt;script type=\u0026#34;text/javascript\u0026#34; 2 async 3 src=\u0026#34;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; 4MathJax.Hub.Config({ 5 tex2jax: { 6 inlineMath: [[\u0026#39;$\u0026#39;,\u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;,\u0026#39;\\\\)\u0026#39;]], 7 displayMath: [[\u0026#39;$$\u0026#39;,\u0026#39;$$\u0026#39;], [\u0026#39;\\[\\[\u0026#39;,\u0026#39;\\]\\]\u0026#39;]], 8 processEscapes: true, 9 processEnvironments: true, 10 skipTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;], 11 TeX: { equationNumbers: { autoNumber: \u0026#34;AMS\u0026#34; }, 12 extensions: [\u0026#34;AMSmath.js\u0026#34;, \u0026#34;AMSsymbols.js\u0026#34;] } 13 } 14}); 15 16MathJax.Hub.Queue(function() { 17 // Fix \u0026lt;code\u0026gt; tags after MathJax finishes running. This is a 18 // hack to overcome a shortcoming of Markdown. Discussion at 19 // https://github.com/mojombo/jekyll/issues/199 20 var all = MathJax.Hub.getAllJax(), i; 21 for(i = 0; i \u0026lt; all.length; i += 1) { 22 all[i].SourceElement().parentNode.className += \u0026#39; has-jax\u0026#39;; 23 } 24}); 25\u0026lt;/script\u0026gt; 26 27\u0026lt;style\u0026gt; 28code.has-jax { 29 font: inherit; 30 font-size: 100%; 31 background: inherit; 32 border: inherit; 33 color: #515151; 34} 35\u0026lt;/style\u0026gt; 另一个是 layouts\\partials 下的 extend_head.html 文件，\n1{{- /* Head custom content area start */ -}} 2{{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} 3{{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} 4{{ partial \u0026#34;mathjax.html\u0026#34; . }} 5{{- /* Head custom content area end */ -}} 到这里，数学公式就可以正常使用了，我们来写一点数学公式试一下，\n1行内数学公式：$a^2 + b^2 = c^2$。 2 3块公式， 4 5$$ 6a^2 + b^2 = c^2 7$$ 8 9\u0026lt;div\u0026gt; 10$$ 11\\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} 12$$ 13\u0026lt;/div\u0026gt; 渲染出来的效果如下，\n行内数学公式：$a^2 + b^2 = c^2$。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n$$ \\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} $$ 上面的第二个公式之所以要用 div 包裹起来，是因为这里的数学公式如果有超过了三对花括号，那么，其解析和转义就会出问题，这个和 hugo 有关目前折中的方案就是上面这种在外面套一层 div。\n给代码换个字体 先到谷歌字体 中找一款开源字体，我这里选用的是 Jetbrains Mono，然后复制其信息到 layouts\\partials\\extend_head.html 中，\n1\u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; 2\u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; 3\u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 然后，新建一个 assets\\css\\extended\\blank.css 文件，添加样式如下，\n1.post-content pre, 2code { 3 font-family: \u0026#34;JetBrains Mono\u0026#34;, monospace; 4 font-size: 1rem; 5 line-height: 1.2; 6} 这样就可以生效了，如果发现不生效，可以重新执行一下 hugo server 试试。\n代码明暗样式切换 我这里使用的不是 highlightjs，而是 hugo 推荐的 chroma，这样的话，我们先建立一个 assets\\css\\extended\\chroma-styles-overrides.css 文件，\n然后，执行一下命令生成你想要的样式，\n1hugo gen chromastyles --style=tokyonight-day \u0026gt; syntax.css 然后，把 syntax.css 中的内容复制到 chroma-styles-overrides.html 文件中，如果是暗色主题，那么，生成的样式则要包裹在 .dark {} 里面，我这里生成了两个样式，白天的样式是 tokyonight-day，黑暗的样式是 github-dark，同时，要记得将生成的样式中有些空缺的部分给补上默认的颜色，我这里白天的颜色补的是黑色，夜晚的颜色补的是白色，不然代码的样式会出问题，我这里完整的样式如下，\n1/* Background */ .bg { color:#3760bf;background-color:#e1e2e7; } 2/* PreWrapper */ .chroma { color:#3760bf;background-color:#e1e2e7; } 3/* Other */ .chroma .x { color: #000 } 4/* Error */ .chroma .err { color:#c64343 } 5/* CodeLine */ .chroma .cl { color: #000 } 6/* LineLink */ .chroma .lnlinks { outline:none;text-decoration:none;color:inherit } 7/* LineTableTD */ .chroma .lntd { vertical-align:top;padding:0;margin:0;border:0; } 8/* LineTable */ .chroma .lntable { border-spacing:0;padding:0;margin:0;border:0; } 9/* LineHighlight */ .chroma .hl { background-color:#a1a6c5 } 10/* LineNumbersTable */ .chroma .lnt { white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6172b0 } 11/* LineNumbers */ .chroma .ln { white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6172b0 } 12/* Line */ .chroma .line { display:flex; } 13/* Keyword */ .chroma .k { color:#9854f1 } 14/* KeywordConstant */ .chroma .kc { color:#8c6c3e } 15/* KeywordDeclaration */ .chroma .kd { color:#9d7cd8 } 16/* KeywordNamespace */ .chroma .kn { color:#007197 } 17/* KeywordPseudo */ .chroma .kp { color:#9854f1 } 18/* KeywordReserved */ .chroma .kr { color:#9854f1 } 19/* KeywordType */ .chroma .kt { color:#0db9d7 } 20/* Name */ .chroma .n { color: #000 } 21/* NameAttribute */ .chroma .na { color:#2e7de9 } 22/* NameBuiltin */ .chroma .nb { color:#587539 } 23/* NameBuiltinPseudo */ .chroma .bp { color:#587539 } 24/* NameClass */ .chroma .nc { color:#b15c00 } 25/* NameConstant */ .chroma .no { color:#b15c00 } 26/* NameDecorator */ .chroma .nd { color:#2e7de9;font-weight:bold } 27/* NameEntity */ .chroma .ni { color:#007197 } 28/* NameException */ .chroma .ne { color:#8c6c3e } 29/* NameFunction */ .chroma .nf { color:#2e7de9 } 30/* NameFunctionMagic */ .chroma .fm { color:#2e7de9 } 31/* NameLabel */ .chroma .nl { color:#587539 } 32/* NameNamespace */ .chroma .nn { color:#8c6c3e } 33/* NameOther */ .chroma .nx { color: #000 } 34/* NameProperty */ .chroma .py { color:#8c6c3e } 35/* NameTag */ .chroma .nt { color:#9854f1 } 36/* NameVariable */ .chroma .nv { color: #000 } 37/* NameVariableClass */ .chroma .vc { color: #000 } 38/* NameVariableGlobal */ .chroma .vg { color: #000 } 39/* NameVariableInstance */ .chroma .vi { color: #000 } 40/* NameVariableMagic */ .chroma .vm { color: #000 } 41/* Literal */ .chroma .l { color: #000 } 42/* LiteralDate */ .chroma .ld { color: #000 } 43/* LiteralString */ .chroma .s { color:#587539 } 44/* LiteralStringAffix */ .chroma .sa { color:#9d7cd8 } 45/* LiteralStringBacktick */ .chroma .sb { color:#587539 } 46/* LiteralStringChar */ .chroma .sc { color:#587539 } 47/* LiteralStringDelimiter */ .chroma .dl { color:#2e7de9 } 48/* LiteralStringDoc */ .chroma .sd { color:#a1a6c5 } 49/* LiteralStringDouble */ .chroma .s2 { color:#587539 } 50/* LiteralStringEscape */ .chroma .se { color:#2e7de9 } 51/* LiteralStringHeredoc */ .chroma .sh { color:#a1a6c5 } 52/* LiteralStringInterpol */ .chroma .si { color:#587539 } 53/* LiteralStringOther */ .chroma .sx { color:#587539 } 54/* LiteralStringRegex */ .chroma .sr { color:#007197 } 55/* LiteralStringSingle */ .chroma .s1 { color:#587539 } 56/* LiteralStringSymbol */ .chroma .ss { color:#587539 } 57/* LiteralNumber */ .chroma .m { color:#8c6c3e } 58/* LiteralNumberBin */ .chroma .mb { color:#8c6c3e } 59/* LiteralNumberFloat */ .chroma .mf { color:#8c6c3e } 60/* LiteralNumberHex */ .chroma .mh { color:#8c6c3e } 61/* LiteralNumberInteger */ .chroma .mi { color:#8c6c3e } 62/* LiteralNumberIntegerLong */ .chroma .il { color:#8c6c3e } 63/* LiteralNumberOct */ .chroma .mo { color:#8c6c3e } 64/* Operator */ .chroma .o { color:#587539;font-weight:bold } 65/* OperatorWord */ .chroma .ow { color:#587539;font-weight:bold } 66/* Punctuation */ .chroma .p { color: #000 } 67/* Comment */ .chroma .c { color:#a1a6c5;font-style:italic } 68/* CommentHashbang */ .chroma .ch { color:#a1a6c5;font-style:italic } 69/* CommentMultiline */ .chroma .cm { color:#a1a6c5;font-style:italic } 70/* CommentSingle */ .chroma .c1 { color:#a1a6c5;font-style:italic } 71/* CommentSpecial */ .chroma .cs { color:#a1a6c5;font-style:italic } 72/* CommentPreproc */ .chroma .cp { color:#a1a6c5;font-style:italic } 73/* CommentPreprocFile */ .chroma .cpf { color:#a1a6c5;font-weight:bold;font-style:italic } 74/* Generic */ .chroma .g { color: #000 } 75/* GenericDeleted */ .chroma .gd { color:#c64343;background-color:#e9e9ed } 76/* GenericEmph */ .chroma .ge { font-style:italic } 77/* GenericError */ .chroma .gr { color:#c64343 } 78/* GenericHeading */ .chroma .gh { color:#8c6c3e;font-weight:bold } 79/* GenericInserted */ .chroma .gi { color:#587539;background-color:#e9e9ed } 80/* GenericOutput */ .chroma .go { color: #000 } 81/* GenericPrompt */ .chroma .gp { color: #000 } 82/* GenericStrong */ .chroma .gs { font-weight:bold } 83/* GenericSubheading */ .chroma .gu { color:#8c6c3e;font-weight:bold } 84/* GenericTraceback */ .chroma .gt { color:#c64343 } 85/* GenericUnderline */ .chroma .gl { text-decoration:underline } 86/* TextWhitespace */ .chroma .w { color: #000 } 87 88.dark { 89 /* Background */ .bg { color:#e6edf3;background-color:#0d1117; } 90 /* PreWrapper */ .chroma { color:#e6edf3;background-color:#0d1117; } 91 /* Other */ .chroma .x { color: #fff } 92 /* Error */ .chroma .err { color:#f85149 } 93 /* CodeLine */ .chroma .cl { color: #fff } 94 /* LineLink */ .chroma .lnlinks { outline:none;text-decoration:none;color:inherit } 95 /* LineTableTD */ .chroma .lntd { vertical-align:top;padding:0;margin:0;border:0; } 96 /* LineTable */ .chroma .lntable { border-spacing:0;padding:0;margin:0;border:0; } 97 /* LineHighlight */ .chroma .hl { background-color:#6e7681 } 98 /* LineNumbersTable */ .chroma .lnt { white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679 } 99 /* LineNumbers */ .chroma .ln { white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6e7681 } 100 /* Line */ .chroma .line { display:flex; } 101 /* Keyword */ .chroma .k { color:#ff7b72 } 102 /* KeywordConstant */ .chroma .kc { color:#79c0ff } 103 /* KeywordDeclaration */ .chroma .kd { color:#ff7b72 } 104 /* KeywordNamespace */ .chroma .kn { color:#ff7b72 } 105 /* KeywordPseudo */ .chroma .kp { color:#79c0ff } 106 /* KeywordReserved */ .chroma .kr { color:#ff7b72 } 107 /* KeywordType */ .chroma .kt { color:#ff7b72 } 108 /* Name */ .chroma .n { color: #fff } 109 /* NameAttribute */ .chroma .na { color: #fff } 110 /* NameBuiltin */ .chroma .nb { color: #fff } 111 /* NameBuiltinPseudo */ .chroma .bp { color: #fff } 112 /* NameClass */ .chroma .nc { color:#f0883e;font-weight:bold } 113 /* NameConstant */ .chroma .no { color:#79c0ff;font-weight:bold } 114 /* NameDecorator */ .chroma .nd { color:#d2a8ff;font-weight:bold } 115 /* NameEntity */ .chroma .ni { color:#ffa657 } 116 /* NameException */ .chroma .ne { color:#f0883e;font-weight:bold } 117 /* NameFunction */ .chroma .nf { color:#d2a8ff;font-weight:bold } 118 /* NameFunctionMagic */ .chroma .fm { color: #fff } 119 /* NameLabel */ .chroma .nl { color:#79c0ff;font-weight:bold } 120 /* NameNamespace */ .chroma .nn { color:#ff7b72 } 121 /* NameOther */ .chroma .nx { color: #fff } 122 /* NameProperty */ .chroma .py { color:#79c0ff } 123 /* NameTag */ .chroma .nt { color:#7ee787 } 124 /* NameVariable */ .chroma .nv { color:#79c0ff } 125 /* NameVariableClass */ .chroma .vc { color: #fff } 126 /* NameVariableGlobal */ .chroma .vg { color: #fff } 127 /* NameVariableInstance */ .chroma .vi { color: #fff } 128 /* NameVariableMagic */ .chroma .vm { color: #fff } 129 /* Literal */ .chroma .l { color:#a5d6ff } 130 /* LiteralDate */ .chroma .ld { color:#79c0ff } 131 /* LiteralString */ .chroma .s { color:#a5d6ff } 132 /* LiteralStringAffix */ .chroma .sa { color:#79c0ff } 133 /* LiteralStringBacktick */ .chroma .sb { color:#a5d6ff } 134 /* LiteralStringChar */ .chroma .sc { color:#a5d6ff } 135 /* LiteralStringDelimiter */ .chroma .dl { color:#79c0ff } 136 /* LiteralStringDoc */ .chroma .sd { color:#a5d6ff } 137 /* LiteralStringDouble */ .chroma .s2 { color:#a5d6ff } 138 /* LiteralStringEscape */ .chroma .se { color:#79c0ff } 139 /* LiteralStringHeredoc */ .chroma .sh { color:#79c0ff } 140 /* LiteralStringInterpol */ .chroma .si { color:#a5d6ff } 141 /* LiteralStringOther */ .chroma .sx { color:#a5d6ff } 142 /* LiteralStringRegex */ .chroma .sr { color:#79c0ff } 143 /* LiteralStringSingle */ .chroma .s1 { color:#a5d6ff } 144 /* LiteralStringSymbol */ .chroma .ss { color:#a5d6ff } 145 /* LiteralNumber */ .chroma .m { color:#a5d6ff } 146 /* LiteralNumberBin */ .chroma .mb { color:#a5d6ff } 147 /* LiteralNumberFloat */ .chroma .mf { color:#a5d6ff } 148 /* LiteralNumberHex */ .chroma .mh { color:#a5d6ff } 149 /* LiteralNumberInteger */ .chroma .mi { color:#a5d6ff } 150 /* LiteralNumberIntegerLong */ .chroma .il { color:#a5d6ff } 151 /* LiteralNumberOct */ .chroma .mo { color:#a5d6ff } 152 /* Operator */ .chroma .o { color:#ff7b72;font-weight:bold } 153 /* OperatorWord */ .chroma .ow { color:#ff7b72;font-weight:bold } 154 /* Punctuation */ .chroma .p { color: #fff } 155 /* Comment */ .chroma .c { color:#8b949e;font-style:italic } 156 /* CommentHashbang */ .chroma .ch { color:#8b949e;font-style:italic } 157 /* CommentMultiline */ .chroma .cm { color:#8b949e;font-style:italic } 158 /* CommentSingle */ .chroma .c1 { color:#8b949e;font-style:italic } 159 /* CommentSpecial */ .chroma .cs { color:#8b949e;font-weight:bold;font-style:italic } 160 /* CommentPreproc */ .chroma .cp { color:#8b949e;font-weight:bold;font-style:italic } 161 /* CommentPreprocFile */ .chroma .cpf { color:#8b949e;font-weight:bold;font-style:italic } 162 /* Generic */ .chroma .g { color: #fff } 163 /* GenericDeleted */ .chroma .gd { color:#ffa198;background-color:#490202 } 164 /* GenericEmph */ .chroma .ge { font-style:italic } 165 /* GenericError */ .chroma .gr { color:#ffa198 } 166 /* GenericHeading */ .chroma .gh { color:#79c0ff;font-weight:bold } 167 /* GenericInserted */ .chroma .gi { color:#56d364;background-color:#0f5323 } 168 /* GenericOutput */ .chroma .go { color:#8b949e } 169 /* GenericPrompt */ .chroma .gp { color:#8b949e } 170 /* GenericStrong */ .chroma .gs { font-weight:bold } 171 /* GenericSubheading */ .chroma .gu { color:#79c0ff } 172 /* GenericTraceback */ .chroma .gt { color:#ff7b72 } 173 /* GenericUnderline */ .chroma .gl { text-decoration:underline } 174 /* TextWhitespace */ .chroma .w { color:#6e7681 } 175} 我在上面提到的生成的样式中空缺的部分，可以看一下下面的样例，\n要记得把他们的颜色都补上。\n然后，修改一下配置即可，\n1params: 2 assets: 3 disableHLJS: true 4markup: 5 goldmark: 6 renderer: 7 unsafe: true # 可以 unsafe，有些 html 标签和样式可能需要 8 highlight: 9 anchorLineNos: false # 不要给行号设置锚标 10 codeFences: true # 代码围栏 11 noClasses: false # TODO: 不知道干啥的，暂时没必要了解，不影响展示 12 lineNos: true # 代码行 13 lineNumbersInTable: false # 不要设置成 true，否则如果文章开头是代码的话，摘要会由一大堆数字(即代码行号)开头文章 14 # 这里设置 style 没用，得自己加 css 15 # style: \u0026#34;github-dark\u0026#34; 16 # style: monokai 修改网页的 favicon 先到 flaticon 网站中找一个 icon 图片，然后放到 static 目录下，\n然后，修改配置，\n1params: 2 # 设置网站的标签页的图标，即 favicon 3 assets: 4 favicon: \u0026#34;favicon.png\u0026#34; 5 favicon16x16: \u0026#34;favicon.png\u0026#34; 6 favicon32x32: \u0026#34;favicon.png\u0026#34; 7 apple_touch_icon: \u0026#34;favicon.png\u0026#34; 8 safari_pinned_tab: \u0026#34;favicon.png\u0026#34; 其他一些小的样式修改 这个就直接看我的代码仓库就可以了，修改的基本都是 css，代码都在 assets 目录下，\n部署到 Github Pages 这里其实有两种方式，一种是直接建立一个以 username.github.io 为名的 Github 仓库，然后，进行部署，另一种是在此基础上新建一个普通的项目，然后可以挂到 username.github.io 域名的后面。\n我们这里就选用简单的第一种比较直接的方式。\n新建一个仓库，没有什么好说的，然后把我们当前的这个仓库和远程仓库关联起来，然后推送过去。然后按照 Hugo 的文档指导来操作即可。\n对于官方给出的 .github/workflows/hugo.yaml， 把其中的分支名改一下即可，或者同时把其中的 Hugo 的版本信息改成和本地的一致也可以。之后，每次推送就可以看到 Github 在部署了。\n一些常用的 Hugo 命令 其实可能只有两个需要我们去记忆或者说熟悉，\nhugo new content content/posts/xxxxx.md hugo server 一些不足 PaperMod 的搜索十分简陋。但是，问题倒也不大。从好的方面来讲，该分享的内容是不影响分享的，而且，正式因为搜索不太好用，所以对个人的隐私可能反而会友好一点。\n附录 参考：\nhttps://pengfeixc.com/blogs/developer-handbook/git-submodules 添加 About 页面 修改字体 https://developer.mozilla.org/en-US/docs/Web/CSS/cursor https://cursor.in/ https://github.com/francoischalifour/medium-zoom https://shaohanyun.top/posts/env/hugo_mathjax/ ","permalink":"http://localhost:1313/posts/build-a-blog-using-hugo-papermod-github-pages/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e之前四五年的时间里也算写过五六百篇博客。以前的 Hexo 顶不住博客数量的压力了，所以，切到 Hugo 试一下。\u003c/p\u003e\n\u003ch3 id=\"涉及工具\"\u003e涉及工具\u003c/h3\u003e\n\u003cp\u003e除了搭建博客和介绍如何使用这个博客框架这样一个流程本身，还包含了对 PaperMod 这个主题的一些细节的定制。\u003c/p\u003e","title":"Hugo + PaperMod + Github Pages 搭建一个完善的个人博客(以 Windows11 为例)"},{"content":"\n正在尝试一种自由的生活。\n自由的生活，也是独居的生活。幽居于楚地的一隅。\n困的时候睡，睡够了然后醒。饿了的时候做饭、吃饭。不饿的时候看书、听歌、写一点无聊的东西。身体康健的时候锻炼，微恙的时候蛰伏。\n过往的生活大致说得过去。没有心理问题，没有身体问题，没有原生家庭问题等等。读过一个还算不错的大学，在一个还算不错的公司短暂地上过班。\n最后，我有一个朋友。\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"题意 https://onlinejudge.org/external/3/340.pdf https://onlinejudge.org/external/4/401.pdf 理解分析 这两道题比较直接，都是用字符数组来进行解决。\n","permalink":"http://localhost:1313/posts/uva401-and-uva340/","summary":"\u003ch2 id=\"题意\"\u003e题意\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/3/340.pdf\"\u003ehttps://onlinejudge.org/external/3/340.pdf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/4/401.pdf\"\u003ehttps://onlinejudge.org/external/4/401.pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"理解分析\"\u003e理解分析\u003c/h2\u003e\n\u003cp\u003e这两道题比较直接，都是用字符数组来进行解决。\u003c/p\u003e","title":"UVa401 and UVa340"},{"content":"配套的书是这本：\u0026lt;\n如何看自己当前的 Kotlin 的版本？\n在 build.gradle.kts 中，\n1// Top-level build file where you can add configuration options common to all sub-projects/modules. 2plugins { 3 alias(libs.plugins.android.application) apply false 4 alias(libs.plugins.kotlin.android) apply false 5 alias(libs.plugins.kotlin.compose) apply false 6} 我们点进第二行的版本中去查看即可。现在 Kotlin 的版本为 2.0.0.\n如何看 Jetpack Compose 的版本？\nhttps://developer.android.com/develop/ui/compose/compiler\n也是类似的道理，现在 Jetpack Compose 的版本为 2.0.0.\n书上是建议我们使用 Jetpack Compose v1.2.1，这里我们不听他的，我们直接用最新版，遇到不兼容的地方，就直接去解决就行。\n我们这里可以先把代码 clone 一份下来备用，\n1git clone https://github.com/kodecocodes/jet-materials.git 如何阅读这本书？\n直接从开头然后按照顺序读下去即可。\n开发环境的搭建。\n安装 Android Studio 即可。\n对于测试的设备，直接使用手头的安卓手机。\n","permalink":"http://localhost:1313/posts/jetpack-compose-by-tutorials-2nd-cn-version/before-you-begin/","summary":"\u003cp\u003e配套的书是这本：\u0026lt;\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如何看自己当前的 Kotlin 的版本？\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e在 build.gradle.kts 中，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eandroid\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eapplication\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekotlin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eandroid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekotlin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecompose\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们点进第二行的版本中去查看即可。现在 Kotlin 的版本为 2.0.0.\u003c/p\u003e","title":"在你开始之前"},{"content":"很多朋友在使用 Hyprland/Wayland 的时候，可能会遇到这样一个问题，那就是 Chrome、VSCode 和 Obsidian 这类基于 chromium 的软件的界面字体和 UI 比较模糊，不够 sharp 和清晰。那么，我这里简要介绍我常用的两种方法。\n一种是像 VSCode/Chrome 这种可以直接加 flags 的，那么，我们直接在在配置目录中新建一个 code-flags.conf 然后加上一些启动参数即可，\n1--ozone-platform-hint=wayland 2--enable-wayland-ime 对于 Chrome，我们则需要写一个 chrome-flags.conf，\n1--enable-features=UseOzonePlatform 2--ozone-platform=wayland 3--enable-wayland-ime 然后是一些我们不知道其 flags 文件怎么命名的软件，比如，Obsidian 和 Jetbrains 家的软件，那么，我们可以直接自制一份我们自己的 desktop file 来覆盖系统默认的，这里拿 Obsidian 举例，我们去 /usr/share/applications 下去复制一份 obsidian.desktop 文件到 ~/.local/share/applications/ 下面，然后在 Exec 那一行加一些启动参数即可，\n1Exec=/usr/bin/obsidian %U --enable-features=UseOzonePlatform --ozone-platform=wayland --enable-wayland-ime Jetbrains 家的软件也是一样，加一下它们提供的 wayland 相关的参数即可，\n1Exec=intellij-idea-ultimate-edition %u -Dawt.toolkit.name=WLToolkit ","permalink":"http://localhost:1313/posts/resolve-wayland-or-hyprland-chrome-and-jetrains-scale-issue/","summary":"\u003cp\u003e很多朋友在使用 Hyprland/Wayland 的时候，可能会遇到这样一个问题，那就是 Chrome、VSCode 和 Obsidian 这类基于 chromium 的软件的界面字体和 UI 比较模糊，不够 sharp 和清晰。那么，我这里简要介绍我常用的两种方法。\u003c/p\u003e","title":"解决 Hyprland/Wayland 下 Chrome/Chromium 系列软件和 Jetbrains 系列软件的缩放和输入法使用的问题"},{"content":"题意理解 https://onlinejudge.org/external/10/1025.pdf\n这里要我们求的输出是：最少等待时间。什么是最少等待时间呢？就是在车站逗留的时间。\n解题思路 用 $d(i, j)$ 表示时刻 i，Mario 在车站 j 最少还需要等待多少时间。 边界条件是：$d(T, n) = 0$，表示在 T 时刻，Mario 已经在 n 站台了。其他的 d(T, i) 为正无穷。 对于其他的普通的情况，也就是 d(i, j)，可以有 3 种决策： 1、等 1 个时间单位 2、搭乘往右开的车(如果有) 3、搭乘往左开的车(如果有) 代码理解 这里状态转移方程比较直观，其实就是最内层的 for 循环中的处理过程。因为我们的边界条件是 T 时刻，所以，对于时刻 i，我们从 T - 1 开始遍历。\n这里一定要明确，$dp[i, j]$ 表示的是时刻 i，在车站 j 最少还需要等待多少时间。\n1dp[i][j] = dp[i+1][j] + 1; // 等待一个时间单位 表示，从 dp[i][j] 状态来到 dp[i+1][j]，是在 j 站台等待了一个时间单位。并且，最终来到了 i + 1 时刻。\n1dp[i][j] = min(dp[i][j], dp[i+t[j]][j+1]); // 右 表示，从 dp[i][j] 状态来到 dp[i+t[j]][j+1] 状态，是在往右的列车上花费了 t[j] 个时间单位，并且，最终来到了 i + t[j] 时刻和 j + 1 站台。这个过程中，没有等待。\n1dp[i][j] = min(dp[i][j], dp[i+t[j-1]][j-1]); // 左 表示，从 dp[i][j] 状态来到 dp[i+t[j-1]][j-1] 状态，是在往左的列车上花费了 t[j-1] 个时间单位(因为题意说，两个站台之间列车往左往右花费的时间是一样的)，并且，最终来到了 i + t[j - 1] 时刻和 j - 1 站台。这个过程中，也没有等待。\n注意：这里为什么一次只让列车走一个站台呢？是因为一次走多个站台的情况也被我们这种挨个处理的方式给囊括了，便于我们去处理所有的情况。比如，我想坐列车一次往右走两个站台，那么，其实在我走完一个站台的时候，会有三种决策，那么，其中，直接向右走的决策就和一次走两个站台的那种情况是相等了。\n","permalink":"http://localhost:1313/posts/uva1025/","summary":"\u003ch2 id=\"题意理解\"\u003e题意理解\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://onlinejudge.org/external/10/1025.pdf\"\u003ehttps://onlinejudge.org/external/10/1025.pdf\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这里要我们求的输出是：最少等待时间。什么是最少等待时间呢？就是在车站逗留的时间。\u003c/p\u003e\n\u003ch2 id=\"解题思路\"\u003e解题思路\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e用 $d(i, j)$ 表示时刻 i，Mario 在车站 j 最少还需要等待多少时间。\u003c/li\u003e\n\u003cli\u003e边界条件是：$d(T, n) = 0$，表示在 T 时刻，Mario 已经在 n 站台了。其他的 d(T, i) 为正无穷。\u003c/li\u003e\n\u003cli\u003e对于其他的普通的情况，也就是 d(i, j)，可以有 3 种决策：\n\u003cul\u003e\n\u003cli\u003e1、等 1 个时间单位\u003c/li\u003e\n\u003cli\u003e2、搭乘往右开的车(如果有)\u003c/li\u003e\n\u003cli\u003e3、搭乘往左开的车(如果有)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"代码理解\"\u003e代码理解\u003c/h2\u003e\n\u003cp\u003e这里状态转移方程比较直观，其实就是最内层的 for 循环中的处理过程。因为我们的边界条件是 T 时刻，所以，对于时刻 i，我们从 T - 1 开始遍历。\u003c/p\u003e","title":"UVa1025"},{"content":"这两道题是整本书中出现的第一道和第二道 UVa 的题目。\nhttps://onlinejudge.org/external/2/272.pdf https://onlinejudge.org/external/100/10082.pdf 先看 UVa272，这里需要注意两点，\ngetchar =\u0026gt; 这里之所以使用 getchar，是因为如果使用 scanf 来读取输入的话，那么，像 TAB、空格这样的字符就会被当成分隔符而无法读入； EOF 是什么？EOF 表示一个文件的结束，如果是读取一个文件，那么，读取到文件尾时，就会读取到 EOF。更详细的内容可以看：https://stackoverflow.com/questions/4358728/end-of-file-eof-in-c。我们在使用命令行的时候，可以使用 Ctrl + D(在 Linux 系统下) 来手动触发 EOF。 额外说一句，第 46 页，\n如果用“scanf(\u0026quot;%d\u0026quot;, \u0026amp;n)”读取整数 n，则要是在输入 123 后多加了一个空格，用 getchar 读取的将是这个空格，\n这里的意思是先调用 scanf，然后调用 getchar，并不是上来就只调用 getchar。\n再看 UVa10082，思路也是一样，毕竟是开篇的题目，所以比较简单。\n好，那么这两道题所用到的知识点就是这个 getchar 了。\n然后，下面是代码时间，写代码的时候，注意一下题目的输入数据的格式即可。\n","permalink":"http://localhost:1313/posts/uva272-and-uva10082/","summary":"\u003cp\u003e这两道题是整本书中出现的第一道和第二道 UVa 的题目。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/2/272.pdf\"\u003ehttps://onlinejudge.org/external/2/272.pdf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/100/10082.pdf\"\u003ehttps://onlinejudge.org/external/100/10082.pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e先看 UVa272，这里需要注意两点，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egetchar =\u0026gt; 这里之所以使用 getchar，是因为如果使用 scanf 来读取输入的话，那么，像 TAB、空格这样的字符就会被当成分隔符而无法读入；\u003c/li\u003e\n\u003cli\u003eEOF 是什么？EOF 表示一个文件的结束，如果是读取一个文件，那么，读取到文件尾时，就会读取到 EOF。更详细的内容可以看：\u003ca href=\"https://stackoverflow.com/questions/4358728/end-of-file-eof-in-c\"\u003ehttps://stackoverflow.com/questions/4358728/end-of-file-eof-in-c\u003c/a\u003e。我们在使用命令行的时候，可以使用 Ctrl + D(在 Linux 系统下) 来手动触发 EOF。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e额外说一句，第 46 页，\u003c/p\u003e","title":"UVa272 and UVa10082"},{"content":"这里以 Windows11 为例。\n这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\n这个可以写的东西不多，就直接看视频吧。\n插件：\nC/C++ CMake Tools CMake(LSP) 首先，我们先手动地配置一个 C/C++ 项目。\n全手动。即，从命令行编译一个 C++ 文件。\n然后，如果你想省事儿，那么，可以试一下我的模板，\nhttps://github.com/fanlumaster/LinuxCppTemplate\n不过呢，我建议每个人还是自己给自己建立一个模板，这样用起来才放心、熟悉。\n最后，如果大家想更多从实际上手的角度来理解 CMake 的使用，我斗胆推荐一下这本 Modern CMake for C++，刚好前段时间刚出了第二版，很新。如果仅仅是想入个门，那么，读一下第一章也可以有不少收获。\n关于 debug 的配置，可以参考 cmake 插件给出的配置，\nhttps://github.com/microsoft/vscode-cmake-tools/blob/main/docs/debug-launch.md\n因为是在 Windows 平台，所以，就使用 msvc 比较好。\n","permalink":"http://localhost:1313/posts/configure-vscode-cmake-c-cpp-windows/","summary":"\u003cp\u003e这里以 Windows11 为例。\u003c/p\u003e\n\u003cp\u003e这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\u003c/p\u003e\n\u003cp\u003e这个可以写的东西不多，就直接看视频吧。\u003c/p\u003e\n\u003cp\u003e插件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC/C++\u003c/li\u003e\n\u003cli\u003eCMake Tools\u003c/li\u003e\n\u003cli\u003eCMake(LSP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先，我们先手动地配置一个 C/C++ 项目。\u003c/p\u003e","title":"Windows 配置 VSCode + CMake + C/C++ 开发环境"},{"content":"这里以 Arch Linux 为例。\n这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\n这个可以写的东西不多，就直接看视频吧。\n插件：\nC/C++ CMake Tools CMake(LSP) 首先，我们先手动地配置一个 C/C++ 项目。\n全手动。即，从命令行编译一个 C++ 文件。\n然后，如果你想省事儿，那么，可以试一下我的模板，\nhttps://github.com/fanlumaster/LinuxCppTemplate\n不过呢，我建议每个人还是自己给自己建立一个模板，这样用起来才放心、熟悉。\n最后，如果大家想更多从实际上手的角度来理解 CMake 的使用，我斗胆推荐一下这本 Modern CMake for C++，刚好前段时间刚出了第二版，很新。如果仅仅是想入个门，那么，读一下第一章也可以有不少收获。\n下下期视频(大概率)，我将带大家看一个真实的世界中使用 VSCode + C/C++ 插件 + CMake 插件大型项目：Hyprland。\n","permalink":"http://localhost:1313/posts/configure-vscode-cmake-c-cpp-linux/","summary":"\u003cp\u003e这里以 Arch Linux 为例。\u003c/p\u003e\n\u003cp\u003e这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\u003c/p\u003e\n\u003cp\u003e这个可以写的东西不多，就直接看视频吧。\u003c/p\u003e\n\u003cp\u003e插件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC/C++\u003c/li\u003e\n\u003cli\u003eCMake Tools\u003c/li\u003e\n\u003cli\u003eCMake(LSP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先，我们先手动地配置一个 C/C++ 项目。\u003c/p\u003e","title":"Linux 配置 VSCode + CMake + C/C++ 开发环境"},{"content":"或许也可以让 chatgpt 的访问更加丝滑。\n起因是在看 react 的官方教程时，发现有一张图片无法访问，对，就是下面这张，\n其实我最近两年的 imgur 的访问一直比较有问题，有时候需要换很多个节点才能尝试出来一个可以正常加载 imgur 图片的 ip，而有时候甚至会全军覆没。\n今天实在忍不了了，所以，就在网上找了一下有没有好的方法可以实现 imgur 的图片的正常访问，因为这个图床(图片托管网站)用到的地方挺多的，比如，像上面的 reactjs 的官网都会用到，还有 v 站也是默认会渲染 imgur 的图片，我自己的博客之前也是用 imgur 比较多，现在则换成了访问更加顺畅的 postimage，不过，我还有很多图片没有迁移过去，所以，解决 imgur 这个图床的问题迫在眉睫。找了一圈，发现还是用 warp 套一层比较合适。\n那么，具体是怎么操作呢？\n经过我的尝试，发现使用第三方开源的 cli 而非是 cloudflare 的官方 cli 在 Arch 上的体验是更加丝滑的，具体可以参考 Reddit 的这个帖子，\nhttps://www.reddit.com/r/CloudFlare/comments/q0hqj4/warpcli_is_not_working/\n具体来讲，就是先安装几个依赖，\n1yay -S cloudflare-warp-bin wireguard-dkms openresolv wireguard-tools wgcf 这里在安装完毕之后，不要忘记 reboot 一下。\n然后，来到一个临时的目录，依次执行，\n1wgcf register 2wgcf generate 3cp ./wgcf-profile.conf /etc/wireguard/ 然后，\n1wg-quick up wgcf-profile 然后，就可以查看一下 warp 的状态了，\n1curl https://www.cloudflare.com/cdn-cgi/trace/ 我这里的输出为，\n1fl=412f42 2h=www.cloudflare.com 3ip=2a09:bac5:55fd:1028::19c:2a 4ts=1729814011.542 5visit_scheme=https 6uag=curl/8.10.1 7colo=SIN 8sliver=none 9http=http/2 10loc=SG 11tls=TLSv1.3 12sni=plaintext 13warp=on 14gateway=off 15rbi=off 16kex=X25519 可以看到，warp 已经 on 的状态了。\n如果想要关闭，那么，这个时候，就可以 down 一下，\n1wg-quick down wgcf-profile 这样一来，imgur 对 ip 的限制就被我们绕过去了。\n比如，我以前很多博客的封面都是存在在 imgur 的，那么，我们可以看一下，访问的效果如何，\nhttps://fanlumaster.github.io/page/4/#board\n","permalink":"http://localhost:1313/posts/using-warp-to-unlock-imgur/","summary":"\u003cp\u003e或许也可以让 chatgpt 的访问更加丝滑。\u003c/p\u003e\n\u003cp\u003e起因是在看 react 的官方教程时，发现有一张图片无法访问，对，就是下面这张，\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/yXOvdOSs.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e其实我最近两年的 imgur 的访问一直比较有问题，有时候需要换很多个节点才能尝试出来一个可以正常加载 imgur 图片的 ip，而有时候甚至会全军覆没。\u003c/p\u003e","title":"使用 warp 来解除 imgur 的访问限制"},{"content":"","permalink":"http://localhost:1313/posts/my-experience-about-neovim-in-daily-dev-life/","summary":"","title":"My Experience About Neovim in Daily Dev Life"},{"content":"有网友问我关于我发布的算法竞赛入门经典(紫书)的更新计划，这里就简要说一下，顺便也可以作为这个系列的开篇/前言了。\n本来我的计划是，有时间就更，偶尔更，随机更。看到了感兴趣的题目或者随机抽一个就更一下。\n既然有人愿意看，那么，我就让这个系列稍微有秩序一些。所以，之后的更新计划是什么呢？那就是：如果是不忙的时候，我尽量两天更新一道题目。\n更新的计划 会讲哪些题目 对于没有和 UVa 绑定的例题，我应该不会讲解，因为那些题目是比较简单的、为了辅助读者理解概念的，读者看一遍就可以理解。\n但凡是可以提交到 OJ 的题目，在这本书里面，就都是 UVa 的题目了，那么，对于这些题目，我会一题不落的进行讲解，如果你发现有缺漏，那一定是时间的问题，我还没有更新到那里。\n更新的顺序是怎样的 对于更新的顺序问题，我会分成两条线，一条线是从第一章开始，按照顺序更，另一条线是在书中随机挑选题目进行更新。\n这两条线是同步进行的。\n初衷是什么 书的阅读说明里有这样一句话：\n本书最好是有人带着学习。\n确实，中学有很多的竞赛培训班，不过，但是，我认为他们的习惯他们的道德不符合我当初作为初学者时所期待的前辈的印象(包括很多大家可能认为比较权威的人士)，不管是所用工具，所传播出来的理念，动不动就加什么 QQ 群，收什么费之类，令人讨厌，徒增门槛，使人心生退意。一言以蔽之，乌烟瘴气，一群老登。\n而且，我认为，好的视频资源为什么只能存在于国外的平台？这好吗？这不好。\n所以，我就尽量在自己得空的时候，为一些真正对算法竞赛入门感兴趣的初学者提供一份还算能看的材料。就这么简单。\n是用爱发电吗 大概可以这么理解。首先视频绝无收费的可能。当然，如果你愿意花几块钱给我充个电，相当于是请我喝一杯奶茶了(奶茶我最喜欢喝蜜雪冰城)，那我也会很开心的。\n我是绝对没有依靠视频去获取多少收益的意思，如果大家愿意支持我，那么，后面大家愿意购买我开发的付费软件，那就可以算是最好的支持了。\n使用的工具 操作系统，\nWin11 Arch Linux (KDE 或者 hyprland) 当然，也不排除后续使用其他发行版的可能性。\n编程工具，\nNeovim VSCode gcc g++ clang++ MSVC 要讲的大概就这么多。如果大家还有什么想问的，评论区你问我答。\n","permalink":"http://localhost:1313/posts/my-updating-plan-about-aoapc2nd/","summary":"\u003cp\u003e有网友问我关于我发布的算法竞赛入门经典(紫书)的更新计划，这里就简要说一下，顺便也可以作为这个系列的开篇/前言了。\u003c/p\u003e\n\u003cp\u003e本来我的计划是，有时间就更，偶尔更，随机更。看到了感兴趣的题目或者随机抽一个就更一下。\u003c/p\u003e","title":"序言-更新计划-初衷-关于算法竞赛入门经典第二版"},{"content":"我现在如何给初中的少年作数学辅导工作。以一道具体的数学题举例。\n$x$、$y$、$z$ 都是有理数。求\n$$ |x| + |x - y| + |y - z| + |10 - z| $$\n的最小值，并说明什么时候取得最小值。\n一般来说，刚上初一的时候，做这道题目还是需要思索几分钟的，猜大家肯定几秒钟就都可以猜出来，10 嘛。但人一旦有过编程的经验，就不想自己去猜了，而是让机器去猜，那么，我们就写一点 Python 来猜一下，\n1min = float(\u0026#39;inf\u0026#39;) 2for x in range(-100, 100): 3 for y in range(-100, 100): 4 for z in range(-100, 100): 5 cur_min = abs(x) + abs(x - y) + abs(y - z) + abs(10 - z) 6 if cur_min \u0026lt; min: 7 min = cur_min 8print(min) $$ |x| + (|y - x| + |y - z|) + |10 - z| $$\n进一步，\n$$ |x| + |x - z| + |10 - z| $$\n再进一步，\n$$\n$$ $$ |x| + (|z - x| + |z - 10|) $$ 再进一步，\n$$ |x - 0| + |x - 10| $$\n显然，最小值就是 10。\n","permalink":"http://localhost:1313/posts/one-interesting-junior-high-school-math-problem/","summary":"\u003cp\u003e我现在如何给初中的少年作数学辅导工作。以一道具体的数学题举例。\u003c/p\u003e\n\u003cp\u003e$x$、$y$、$z$ 都是有理数。求\u003c/p\u003e\n\u003cp\u003e$$\n|x| + |x - y| + |y - z| + |10 - z|\n$$\u003c/p\u003e\n\u003cp\u003e的最小值，并说明什么时候取得最小值。\u003c/p\u003e","title":"一道有意思的初中数学题"},{"content":"按规矩，先上链接：https://github.com/fanlumaster/fcitx5-FanIME。\n这里我们可以简单看一下代码，因为有了 fcitx5 这个框架，所以实现起来就更加轻松了。我们只需要关注核心的逻辑。\n下面就是基本的功能的介绍啦。\n小鹤双拼 这是最基本的功能，即一个标准的小鹤双拼。\n关于辅助码，这里采用的方案基本是蓝天小雨点的方案。\n单码辅助 对于所有的词条，默认都支持首字单码辅助。\n对于两字词语，同时支持第二个字的单码辅助。比如：红杉，红衫。双码。混输。\n双码辅助 对于单字和双字，按下 Tab 进行翻页时，可以使用双码进行辅助。比如，对弈的弈。双码。尤其是打单字的时候，对于输入人名的时候，非常方便。\n造词时的辅助码 造词时也同时支持单码辅助和双码辅助。\n速度 绝大多数场景的候选词条生成速度在 1ms 以内。同时，最坏情况应该也不会超过 2ms，因为我目前的测试中还未出现这样的数据。\n词库 采用了两个比较经典的开源词库进行整合。目前大概有 170 万个不重复的词条。\nhttps://github.com/iDvel/rime-ice https://github.com/wuhgit/CustomPinyinDictionary 开源 没错，输入法这个东西，你不开源，你还想怎样？窃取用户的隐私吗？\n因为代码公开，所以，基于原始版本，你想怎么定制就怎么定制，至于隐私的问题，早就已经在九霄云外了，完全不用考虑。\nTODO 1、动态调频。这个完全是因为我懒，加上目前在使用辅助码的情况下，还没遇到需要翻页的情况，就暂时搁置了。\n2、之前基于 HMM 做了一个长句联想，但是效果不达标，这个需要后续迭代。不过，也不急，因为目前的功能其实完全够用了。\n3、基于 SLM 制作长句联想。\n4、中英混输。\n5、云输入。这个优先级最低。也还是因为目前已经可以使用得很舒适了。\n","permalink":"http://localhost:1313/posts/a-first-glimpse-on-my-own-ime-fcitx5-fanime/","summary":"\u003cp\u003e按规矩，先上链接：\u003ca href=\"https://github.com/fanlumaster/fcitx5-FanIME\"\u003ehttps://github.com/fanlumaster/fcitx5-FanIME\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e这里我们可以简单看一下代码，因为有了 fcitx5 这个框架，所以实现起来就更加轻松了。我们只需要关注核心的逻辑。\u003c/p\u003e\n\u003cp\u003e下面就是基本的功能的介绍啦。\u003c/p\u003e","title":"真·自制输入法·打你所想"},{"content":"一道经典的算法题。链接：https://onlinejudge.org/external/5/524.pdf。\n这里的原题的描述，我们需要注意的只有输入和输出的格式那里，对于题意的理解，书中的中文描述已经足够了，因为题意是比较简单的。(这里可以去书上读一下题目的意思。)\n首先，素数的定义：wiki。\n大于 1 的自然数中，除了 1 和该数自身外，无法被其他自然数整除的数。(2 当然是素数。)\n关于输出中的数字排列的顺序，书上说是逆时针排列，而原题中说的是顺时针和逆时针，这个其实无所谓，我们依次 dfs 过去，最终会把顺时针和逆时针的情况全部囊括的。\n然后，书上首先介绍了一个“生成-测试”法，这个比较容易，这里就不去详细说明，我们就简单看下用到的 next_permutation 这个函数，可以看一下文档。\n核心的部分是这个 dfs，\n1/* 2 从 1 开始，依次去搜索每个位置上的可能性 3 4 cur: 当前的位置 5*/ 6void dfs(int cur) { 7 if (cur == n \u0026amp;\u0026amp; isp[A[0] + A[n - 1]]) { // 递归边界 8 for (int i = 0; i \u0026lt; n; i++) { 9 if (i != 0) 10 printf(\u0026#34; \u0026#34;); 11 printf(\u0026#34;%d\u0026#34;, A[i]); 12 } 13 printf(\u0026#34;\\n\u0026#34;); 14 } else 15 for (int i = 2; i \u0026lt;= n; i++) 16 if (!vis[i] \u0026amp;\u0026amp; isp[i + A[cur - 1]]) { // 判断当前的数字是否可行，不行的就跳过，相当于是剪枝了 17 A[cur] = i; 18 vis[i] = 1; // 标记已经访问过 19 dfs(cur + 1); // 递归处理下一个位置 20 vis[i] = 0; // 还原 21 } 22} 我们直接看所有的代码，一次性整体进行讲解。\n","permalink":"http://localhost:1313/posts/uva524/","summary":"\u003cp\u003e一道经典的算法题。链接：\u003ca href=\"https://onlinejudge.org/external/5/524.pdf\"\u003ehttps://onlinejudge.org/external/5/524.pdf\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e这里的原题的描述，我们需要注意的只有输入和输出的格式那里，对于题意的理解，书中的中文描述已经足够了，因为题意是比较简单的。(这里可以去书上读一下题目的意思。)\u003c/p\u003e","title":"UVa524"},{"content":"首先，我看了所有的问题，基本上这些问题都是可以在问答平台上找到答案的，多检索、浏览，多看一些，肯定效果会不错的。我这里只能提供一些大而化之的回复，望理解。\n然后是，可以浏览的一些网站有：stackoverflow, reddit, 知乎, v2ex, 推特也可以多逛逛，然后就是，一般来说，现在你稍微有点追求的相关从业人员，至少也应该有一个 GitHub 和独立博客，通过这些独立博客，我相信应该能够挖掘到更加真实的信息，而且，遇到了一个你感兴趣的 GitHub 上面的项目，我想，大概率你也能够发现他的博客，那么，从别人的记录中，至少可以了解到一些过往的人家走过的路的经验。\n如果往硬件方向靠，只学c++这一门语言可以吗，c还没有学过，有必要先去补一下吗？ 按照我的经验，c 是有必要去补一下的，而且，因为 c 的语法知识其实不多，应该花费时间不是很多。\n有哪些学习步骤是学软件学硬件都要走的 这个我只了解软件，学习步骤的话，尽量多看，多学，多写，只有实际动手写起来，写一点自己感兴趣的东西，才可能知道自己该去学习什么东西。\n有什么好的方式去学习知识 Study in public. 多找一些优质的学习资源，远离营销号、远离吊儿郎当、胡吹海侃的内容。\n最近了解到acm，现在这个时间节点去弄acm对于我来说价值大嘛 可以先翻一下刘汝佳的《算法竞赛入门经典》(第二版)，如果你能在一个月内理解完书中所有的例题，那么，任何时候去搞 acm 都不晚。\n现在硬件方向待遇真的很好吗 大一点的公司的待遇其实都是差不多的，比如华为、tp，当然，更高的有大疆。大公司都是看职级来划分工资的，本科毕业的待遇平均 20k 起步(以华科为例)。\n想实习就业的话，四大件需要都学吗，还是重点放在项目上 都需要学，学习和项目不冲突，可以同步开展。还是那句话，只有真正做了，才能对知识点理解得更加深刻。否则只能停留在皮毛与侃大山。\n四大件怎么学习？我看别人都推荐国外的公开课（sc61abc这些）但是我感觉我边看字幕边学，速度太慢了[笑哭]，不知道能不能听国内的对应的课（请问up有推荐的吗） 我也没有很好的建议，大概就是把对应的经典的英文教材的英文版和中文版同时翻开，以中文版为主，遇到不清晰的翻原文，尽量理解书中出现的所有的代码和示例。这样大概比看视频快一点。公开课的话，可以作为补充，一般来讲，其实可以跟着学校的课过一遍，重点在于多问老师问题，即使学校的课可能讲得不好，但是和老师交流的收获会不少。\n学习顺序怎么安排，一门语言和对应框架＋四大件，该怎么分配学习顺序（好像四大件重点学哪些还要看想做什么岗位） 先基础，后上层，然后可以交替理解，反复琢磨，顺序什么的，看个人，有些人喜欢先有个概览性的概念，有些人则喜欢上来就扣细节。我个人认为细节是要注意的，但是不一定非要现在解决。\n对于小白，算法入门应该如何学习（学了一个内容就去刷对应的题目吗），顺便问一下有没有推荐的up主，灵神的看不太懂[笑哭] 算法入门的书，可以看 labuladong 的公开的免费的材料，虽然很多人诟病他抄袭国内外优秀题解，但是，他抄的那些确实是好东西，比较通俗。up 主的话，我个人其实讲得不好，当然，也没遇到过讲得比较好的，包括各种各样的大大小小的 up。关键还是在于多看，多想，前提多看看题解没什么坏处，就当是例题用来刷经验了。\n此外，建议把《算法竞赛入门经典》的所有例题当成例题给吃透了，代码也一行不能放过。\n编程语言选择建议C++吗，好像双非本学C++不好找工作的[笑哭] 我自己其实业余也写一点 C++，也很喜欢 Python，但是我找工作使用的是 Java。目前 Java 的后端岗位其实相比其他要多。至于专门的 C++，很多公司其实都是可以进去之后转语言的，你把一门语言吃透，然后做几个项目，经验度够了之后，其实看待问题的想法就会不一样。\n可以聊聊申请美国申请的事吗, 想了解[给心心] 这个可以多看看小红书上的帖子和一亩三分地上面的导师发布的招募帖，基本这两个地方的信息比较多。美国申请，其实不追求 QS 排名的话，老师应该都是比较包容的。现在需要注意的点可能是签证的问题，这个多上小红书看看经验。我因为拒签了一次就摆了，所以，提供不了太多的建议了。\n","permalink":"http://localhost:1313/posts/simple-replies-to-some-friends-questions-about-cs/","summary":"\u003cp\u003e首先，我看了所有的问题，基本上这些问题都是可以在问答平台上找到答案的，多检索、浏览，多看一些，肯定效果会不错的。我这里只能提供一些大而化之的回复，望理解。\u003c/p\u003e","title":"简要回复网友的关于计算机方面的问题"},{"content":"本题较为简单。本来是想讲另外一道题目的(UVa12171，例题 6-18)，但是那道题目提到了 floodfill，那么，就先把这个 floodfill 这个知识点给讲了吧。\n首先，搞清楚题目中的一些条件。\n输入的 m 和 n 分别代表行和列，其范围都是 $[1, 100]$。 * 代表空白，没有油的地块，而 @ 代表有油的地块。 然后，书上可能会让人觉得疑惑的点，\n上面的代码用一个二重循环来找到当前格子的相邻 8 个格子，也可以用常量数组或写 8 条 DFS 调用。\n这里说的是可以直接硬编码 8 个 DFS，因为每次遍历只需要 8 次的 DFS。或者，把这 8 次整成一个由 8 个向量组成的常量数组也可以。\n剩余的就是一个简单的 DFS 了。直接看代码很容易理解。\n","permalink":"http://localhost:1313/posts/uva572/","summary":"\u003cp\u003e本题较为简单。本来是想讲另外一道题目的(UVa12171，例题 6-18)，但是那道题目提到了 floodfill，那么，就先把这个 floodfill 这个知识点给讲了吧。\u003c/p\u003e","title":"UVa572"},{"content":"思来想去，还是把 CSDN 直接屏蔽掉吧。\n首先，安装 ublacklist，\n然后，找到 options(选项)，\n直接写一个模糊匹配的规则即可，\n1*://*.csdn.net/* ","permalink":"http://localhost:1313/posts/block-csdn-when-using-google-search/","summary":"\u003cp\u003e思来想去，还是把 CSDN 直接屏蔽掉吧。\u003c/p\u003e\n\u003cp\u003e首先，安装 \u003ca href=\"https://chromewebstore.google.com/detail/ublacklist/pncfbmialoiaghdehhbnbhkkgmjanfhe\"\u003eublacklist\u003c/a\u003e，\u003c/p\u003e\n\u003cp\u003e然后，找到 options(选项)，\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/zB7B3QvD/image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接写一个模糊匹配的规则即可，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-txt\" data-lang=\"txt\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e*://*.csdn.net/*\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"谷歌搜索屏蔽CSDN"},{"content":"前言 这篇博客是关于一些关于阅读《算法竞赛入门经典·第 2 版》的一些小贴士。\n老手自不必说，本博客针对的是刚接触这本书的一些新手。\n为什么要读这一本书？\n因为经典。首先作者的实力相当深厚，其次是选取的题目非常纯粹，都是 UVa 的题目，而我们也知道，UVa 的很多题目都是 acm 的原题，所以，题目的严谨性和质量有一定的保证，作为我们学习过程中的例题简直再合适不过。\n那么，下面就讲一些我认为需要讲的点。\n首先是前置条件，完整地、有体系地入门过数据结构。大概需要的程度是掌握 70% 的机械工业出版社的那本《数据结构与算法分析 C 语言描述》的内容。第一版和第二版都可以。这里插一句，一定要中英文放在一起看，为什么？因为如果你刚接触这本书，那么，你也就是大学低年级的水平，你的英文水平、专业词汇的水平还不够直接阅读英文原文，所以最好中英文放在一起看，中文觉得别扭的地方，翻开英文看看，记录一下不顺的地方，然后，把翻译得不好的地方放到网上供大家赏玩，让出版社蒙羞，注意，一定要有理有据，不然，和“秀才造反，三年不成，空谈误国”道理是一样的。\n然后，一些必须放在身边的辅助的工具。\n源码 第一，是源码，例题的代码在这个仓库：\nhttps://github.com/aoapc-book/aoapc-bac2nd\n这个例题的代码是刘汝佳亲自写的，代码质量有保证，不晦涩，很亲民，稍微多挠几下脑瓜，基本都可以搞懂。\n习题的代码在这个仓库：\nhttps://github.com/sukhoeing/aoapc-bac2nd-keys\n这个是陈锋写的，我个人觉得写得不如刘汝佳，不能够做到鞭辟入里。当然，代码本身的正确性和简洁性是毋庸置疑的，这个也没的黑。\n关于书的获取 这本书太有名了，随便谷歌一下即可获取。\n要看原题描述 然后，因为书中的题目全部选自 UVa，所以，阅读每一个例题的时候，最好把 UVa 的英文原题的 pdf 摆在旁边，这个 pdf 可以到 UVa 官网获取，也可以到 vjudge 中去获取，这个也可以自行搜索(千万不要使用百度、必应国内版)即可。基本上输入题目的序号，就能找到其题目的链接的。比如，有些题目的链接：\nUVa442(UVa 官网): https://onlinejudge.org/index.php?option=com_onlinejudge\u0026Itemid=8\u0026page=show_problem\u0026problem=383 UVa442(vjudge): https://vjudge.net/problem/UVA-442 当然，UVa 也提供了一份题单，我个人觉得没有必要，遇到的时候，直接搜索一把即可，基本上前两个结果就是我们想要的。\n跑测试用例 这里一定要借助 udebug 这个网站，输入题号，即可检索到大量的测试用例。便于我们在实际去跑一个题目的代码时去排查 bug。\n因为有时候作者给出的代码不一定是完全正确的，以及，在我们自己去做额外的题目时，这时候就需要我们自己去利用测试用例排查了。\n重定向标准输入 因为书里的题目都是 acm 模式，所以，我们自己在写题目的时候，肯定是要重定向标准输入到文件的，这样我们只需要把测试用例粘贴到文件中，然后，程序就可以从文件中读取测试用例了。\n输出倒是不用重定向，直接输出到控制台我们也可以很容易观察。\n如何提交代码 建议直接到 vjudge 中去提交，反正也是调用官方的 api。因为官网实在有点慢，难免，当然也理解，毕竟为爱发电。\n关于例题的阅读 有些人喜欢去空想，硬想，你以为你是天才？随便翻开书中一道简单的 BFS 的题目，我们可以测试一下，自己在不看任何题解的情况下，需要花费多少时间解决。\n编程没有天才，只有一些喜欢装逼的废柴。剩下的唯有多看多写多练。\n很多时候，我们看到很多人可以凭空想出来，那么，我们也可以猜一猜，他们的题量是多少。而最初的题量，就是来自于对例题的理解。\n我们听老师上课讲解题目，不也是相当于是看例题、看题解的过程吗？\n所以，我这里更建议大家直接把书上的所有例题理解即可。不用尝试自己去做。等把所有的例题都吃透了，甚至是琢磨了两三遍，那么，我们就可以尝试去自己写书上的习题了，这时候，有了知识储备，再去尝试独立思考，那么，必定事半而功倍.。\n阅读的笔记？ 关于笔记，我们在理解题目和题解的时候，对于每一个题目，我们只需要弄清几个问题即可：\n这样做的正确性书上给证明了吗？如果给了，理解简要的证明，也就理解了正确性。 如果没有给证明，我们就要自己想明白其中的正确性。 算法的时间复杂度/空间复杂度的理解和简要证明。 对于理解题意，也不必钻入细节，只要识别出题目的意图即可，因为，即使 UVa 的题目已经算是比较严谨了，却也依然有人力不可完全细察之处的缺漏。 最重要的一点，识别作者给出的代码的每一处意图。只有如此，我们才能在自己做题目的时候运用自如。 这样一套下来，其实，搞懂一个例题，不比我们写一道力扣中等题所花费的时间少，不过，却也必然比我们在没有任何/太多知识和题量储备的情况下去硬想力扣的题目所花费的时间要少得多。\n而看懂一道题的收获，必然也是不少的，因为，这书中的大部分题目都是力扣的困难级别的。\n","permalink":"http://localhost:1313/posts/some-tips-for-reading-aoapc-bac2nd/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e这篇博客是关于一些关于阅读《算法竞赛入门经典·第 2 版》的一些小贴士。\u003c/p\u003e\n\u003cp\u003e老手自不必说，本博客针对的是刚接触这本书的一些新手。\u003c/p\u003e\n\u003cp\u003e为什么要读这一本书？\u003c/p\u003e\n\u003cp\u003e因为经典。首先作者的实力相当深厚，其次是选取的题目非常纯粹，都是 UVa 的题目，而我们也知道，UVa 的很多题目都是 acm 的原题，所以，题目的严谨性和质量有一定的保证，作为我们学习过程中的例题简直再合适不过。\u003c/p\u003e","title":"《算法竞赛入门经典·第 2 版》的一些阅读小贴士"},{"content":"题目链接：https://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\n对应算法导论的 33.4。\n主要是有几个问题。\n1、分治是如何进行切分的？\n我是比较朴素地直接一分为二，不让在中间的分割线上既可以包含在左半部分也包含在右半部分。而且，中间的线上的点是先从上面的部分切起，保证这一点的做法是，把点集按照 x 坐标排序的同时，如果 x 相等，那么，再按 y 排序。\n2、真的是 O(nlogn) 吗？\n是的。不信你就去用主方法再推一遍。\n3、为什么可以是 5 而不是 7？\n因为我前面的切分保证了分割线上没有重复的点。\n4、如何保证每一次递归额外所花费的时间是 O(n)？\n对 Y 切割后进行排序使用 set，那么，基本可以保证每一次查询是 O(1) 的时间复杂度。而构建 set 的插入操作也是这个时间复杂度。不过，正如我们学习数据结构的时候知道，有些极端情况会退化成 O(n) 的，但是，这个极端情况也是可以通过进一步优化 set 的内部构造来解决的。所以，这里按下不表，单就做题而言，使用 Python 内置的 set 就可以了。\n5、为什么只用 X 和 Y 就可以了？\n因为 P 其实本来就用不到，书上是为了事无巨细地讲明白才如此冗余。\n6、对于中间条带的点的暴力循环，其时间复杂度是 O(n)？\n当然是的，5n 也是 O(n)，不是吗？\n其实，我以前在上课的时候，也写过一篇[笔记](https://fanlumaster.github.io/2021/05/03/《算法导论》寻找最近点对问题的 Python 实现)。\n代码见仓库。\n","permalink":"http://localhost:1313/posts/closest-pair-of-points-in-linearithmic-time/","summary":"\u003cp\u003e题目链接：\u003ca href=\"https://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\"\u003ehttps://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e对应算法导论的 33.4。\u003c/p\u003e\n\u003cp\u003e主要是有几个问题。\u003c/p\u003e\n\u003cp\u003e1、分治是如何进行切分的？\u003c/p\u003e\n\u003cp\u003e我是比较朴素地直接一分为二，不让在中间的分割线上既可以包含在左半部分也包含在右半部分。而且，中间的线上的点是先从上面的部分切起，保证这一点的做法是，把点集按照 x 坐标排序的同时，如果 x 相等，那么，再按 y 排序。\u003c/p\u003e","title":"寻找最近点对"},{"content":"愚蠢的人自然要自己为其付出代价。多说无益。\n人们当然愿意相信他们已经相信过的东西。\n很多东西其实是无意义的。比如，视频的封面、视频的播放量、视频的夸张的标题、视频的字幕等等等等。\n真正重要的是内容。无论是否有人愿意去看。\n","permalink":"http://localhost:1313/posts/the-foolish-must-pay-the-price-for-their-own-thoughts/","summary":"\u003cp\u003e愚蠢的人自然要自己为其付出代价。多说无益。\u003c/p\u003e\n\u003cp\u003e人们当然愿意相信他们已经相信过的东西。\u003c/p\u003e\n\u003cp\u003e很多东西其实是无意义的。比如，视频的封面、视频的播放量、视频的夸张的标题、视频的字幕等等等等。\u003c/p\u003e","title":"The Foolish Must Pay the Price for Their Own Thoughts"},{"content":"理解 题意比较简单，时间长没有碰数学者或许需要一两分钟回想一下矩阵的乘法。\n可以看一下同济大学的线代教材中给出的矩阵的相乘的公式，\n看一下输入和输出，\n输入\n这里有个术语：EBNF，这是编译原理里面的一个很简单的一个范式，上过课的应该都有印象，如果需要，再去翻一下书即可。\n注意这个条件，\n1Expression = Matrix | \u0026#34;(\u0026#34; Expression Expression \u0026#34;)\u0026#34; 可以推出，括号里面只可以出现一对单独的矩阵，也就是两个单独的矩阵，e.g. (AB)，或者，一个矩阵加上另一对括号括起来的矩阵，e.g. (A(AB))，以此类推。因此，我们可以在遇到右括号的时候，一次出栈两个栈中的元素，\n1else if (expr[i] == \u0026#39;)\u0026#39;) { 2 Matrix m2 = s.top(); 3 s.pop(); 4 Matrix m1 = s.top(); 5 s.pop(); 6 ... 7} 输出\n理解一下题目中的例子即可。\n代码 1#include \u0026lt;cstdio\u0026gt; 2#include \u0026lt;cctype\u0026gt; 3#include \u0026lt;stack\u0026gt; 4#include \u0026lt;iostream\u0026gt; 5#include \u0026lt;string\u0026gt; 6 7using namespace std; 8 9struct Matrix { 10 int a, b; 11 Matrix(int a = 0, int b = 0) : a(a), b(b) {} 12} m[26]; 13 14stack\u0026lt;Matrix\u0026gt; s; 15 16int main(int argc, char *argv[]) { 17 int n; 18 cin \u0026gt;\u0026gt; n; 19 for (int i = 0; i \u0026lt; n; i++) { 20 string name; 21 cin \u0026gt;\u0026gt; name; 22 int k = name[0] - \u0026#39;A\u0026#39;; 23 cin \u0026gt;\u0026gt; m[k].a \u0026gt;\u0026gt; m[k].b; 24 } 25 string expr; 26 while (cin \u0026gt;\u0026gt; expr) { 27 int len = expr.length(); 28 bool error = false; 29 int ans = 0; 30 for (int i = 0; i \u0026lt; len; i++) { 31 if (isalpha(expr[i])) 32 s.push(m[expr[i] - \u0026#39;A\u0026#39;]); 33 else if (expr[i] == \u0026#39;)\u0026#39;) { 34 Matrix m2 = s.top(); 35 s.pop(); 36 Matrix m1 = s.top(); 37 s.pop(); 38 if (m1.b != m2.a) { 39 error = true; 40 break; 41 } 42 ans += m1.a * m2.a * m2.b; 43 s.push(Matrix(m1.a, m2.b)); 44 } 45 } 46 if (error) 47 cout \u0026lt;\u0026lt; \u0026#34;error\\n\u0026#34;; 48 else 49 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 50 } 51 return 0; 52} ","permalink":"http://localhost:1313/posts/uva442/","summary":"UVa210 解题思路及代码解析","title":"UVa442"},{"content":"关于 B 站的 sonnycalcr 这个帐号的事情，就在这个博客里面说。\n今天与一位 B 站的网友私信时，我犯了一个习惯主义错误：一杯奶茶解决问题。\n这好吗？我以前从来没有意识到这个问题。以前的习惯是，给一些同学或者朋友看问题，往往会附加一个条件，那就是，请喝奶茶，或者请吃饭(当然，是学校的食堂)。人都是有所求的，不可能无缘无故帮助别人，这十块或者二十块以内非真实的金钱的交易，大概就和中学时代的一袋方便面讲解一道题类似。\n几块钱的问题本不值得拿出来一说，毕竟现在很多程序员以大厂作为炫耀的条件，以月薪 30k，40k，80k 这种作为一种说辞：难道还有人的薪资低于 20k 吗？\n但是，学生毕竟是学生。\n关于我个人的经济状况：\n因为房子是自己的，所以每个月的消耗也不过是一些脑力、电力、水、气这些。所以，经济状况，至少两年内不用考虑。如果稍微顺利一点，那就是一坤年。如果再幸运一点，那估计就要把单位换成 10 年这个 unit 了。\n总结：既然你也是群众的一员，那就不能拿群众一针一线。朋友同学除外。\n","permalink":"http://localhost:1313/posts/one-cup-of-tea/","summary":"\u003cp\u003e关于 B 站的 sonnycalcr 这个帐号的事情，就在这个博客里面说。\u003c/p\u003e\n\u003cp\u003e今天与一位 B 站的网友私信时，我犯了一个习惯主义错误：一杯奶茶解决问题。\u003c/p\u003e\n\u003cp\u003e这好吗？我以前从来没有意识到这个问题。以前的习惯是，给一些同学或者朋友看问题，往往会附加一个条件，那就是，请喝奶茶，或者请吃饭(当然，是学校的食堂)。人都是有所求的，不可能无缘无故帮助别人，这十块或者二十块以内非真实的金钱的交易，大概就和中学时代的一袋方便面讲解一道题类似。\u003c/p\u003e","title":"一杯奶茶引起的质疑"},{"content":"《算法竞赛入门经典》(第二版) 第 6 章例题 6-2。\n题意 这一题的题面较短，其中英文原题也比较容易理解，所以，我们直接分析题意和代码。\n本题的题意是右边有一列火车向左开，一列火车可以有很多个车厢，单个车厢来到岔路口的时候，可以选择直接进入 B 轨道，也可以选择在 Station 里面暂存一下，但是 Station 相当于是一个 stack，所以，遵循后进先出的规则。\n题目的要求就是，在这样的规则之下，判断给定的序列是否是合法的。\n具体我们看几个输入和输出的样例即可。\n代码 需要说明一点是，书上给出的代码是有误的，实际提交到 OJ 无法通过。我这里讲解的是我修改之后 AC 的代码。\n1// UVa514 Rails 2#include \u0026lt;cstdio\u0026gt; 3#include \u0026lt;stack\u0026gt; 4#include \u0026lt;string\u0026gt; 5 6using namespace std; 7const int MAXN = 1000 + 10; 8 9int n, target[MAXN]; 10 11int main() { 12 // 重定向输入数据，省去我们手动输入的繁琐 13 string relativePathToCurrentCFile = \u0026#34;./data/UVa514/input2.txt\u0026#34;; 14 // relativePathToCurrentCFile = \u0026#34;./data/UVa210/input3.txt\u0026#34;; 15 freopen(string(\u0026#34;./ch06\u0026#34; + relativePathToCurrentCFile.substr(1, relativePathToCurrentCFile.size() - 1)).c_str(), \u0026#34;r\u0026#34;, stdin); 16 17 while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1) { // 读取 N 18 if (n == 0) { 19 break; 20 } 21 while (true) { 22 scanf(\u0026#34;%d\u0026#34;, \u0026amp;target[1]); // 读取序列的第一个数 23 if (target[1] == 0) { // 如果是 0，那么，说明当前这个样例结束了 24 printf(\u0026#34;\\n\u0026#34;); 25 break; 26 } 27 for (int i = 2; i \u0026lt;= n; i++) // 继续读入 28 scanf(\u0026#34;%d\u0026#34;, \u0026amp;target[i]); 29 30 stack\u0026lt;int\u0026gt; s; // 利用 stack 来进行模拟处理 31 int A = 1, B = 1; 32 int ok = 1; 33 while (B \u0026lt;= n) { 34 if (A == target[B]) { // 当前的车厢和 target 在 B 这个位置所要求的车厢是相同的，那么不用经过 station 直接进入左边的轨道即可 35 A++; 36 B++; 37 } else if (!s.empty() \u0026amp;\u0026amp; s.top() == target[B]) { // 栈的顶部符合条件 38 s.pop(); 39 B++; 40 } else if (A \u0026lt;= n) // 目前没有符号条件的，就入栈 41 s.push(A++); 42 else { // 越界了都没有找到 43 ok = 0; 44 break; 45 } 46 } 47 printf(\u0026#34;%s\\n\u0026#34;, ok ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); 48 } 49 } 50 51 return 0; 52} ","permalink":"http://localhost:1313/posts/uva514/","summary":"\u003cp\u003e《算法竞赛入门经典》(第二版) 第 6 章例题 6-2。\u003c/p\u003e\n\u003ch2 id=\"题意\"\u003e题意\u003c/h2\u003e\n\u003cp\u003e这一题的题面较短，其中英文原题也比较容易理解，所以，我们直接分析题意和代码。\u003c/p\u003e\n\u003cp\u003e本题的题意是右边有一列火车向左开，一列火车可以有很多个车厢，单个车厢来到岔路口的时候，可以选择直接进入 B 轨道，也可以选择在 Station 里面暂存一下，但是 Station 相当于是一个 stack，所以，遵循后进先出的规则。\u003c/p\u003e","title":"UVa514"},{"content":"首先，放我在 v 站的质疑的帖子，基本信息都在这个里面了。\nhttps://www.v2ex.com/t/1072947\n惯例，先叠甲：我卑怯、胆小、狡猾、懦弱（EVA 真嗣语）。\n还有该死的好奇心，不，纯粹是我要当正义的伙伴！(卫宫士郎语)\n要是我输，我 TM 直播吃键盘(开玩笑，但是肯定会道歉的，而且是郑重道歉)。\n我呢，就来发出一点不同的声音，因为我看见评论区的意见的一致的，而刚好我也有些疑问。\n那么，这个视频的主体内容就是读评论了，不过，不是读在该 UP 视频下的评论。\n也可以看一看我自己对于争论的态度，我不反对，声音当然是越多越好，信息越多，越有利于大家判断。\nhttps://www.bilibili.com/video/BV1BsYSe1EGY/?spm_id_from=333.999.0.0\u0026vd_source=452591e6eeff36707902db6872a46580\n我其实不太讨厌培训班的人，因为他们好歹可以把成体系的知识传授给大家，而且，挣钱就挣钱，卖课就卖课，不寒碜。\n最后，本视频应该不涉及违规内容，而且我自己认为应该算是合理的一种质疑？如果大家认为我是在蹭热度，忌妒人家导致人红是非多，我权且接受，大家都来攻击我吧。\n再最后，本人逻辑极差，表达内容可能有失偏颇的地方，希望大家海涵。以及，我自己的代码水平极差，大家随便喷。\n希望审核放过。\n","permalink":"http://localhost:1313/posts/questioning-a-bilibili-up-dhwass/","summary":"\u003cp\u003e首先，放我在 v 站的质疑的帖子，基本信息都在这个里面了。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.v2ex.com/t/1072947\"\u003ehttps://www.v2ex.com/t/1072947\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e惯例，先叠甲：我卑怯、胆小、狡猾、懦弱（EVA 真嗣语）。\u003c/p\u003e\n\u003cp\u003e还有该死的好奇心，不，纯粹是我要当正义的伙伴！(卫宫士郎语)\u003c/p\u003e","title":"简要质疑一下 DHwass 的编程水平"},{"content":"这一集视频我们来看一下第二章的第一节。从这一集视频开始，我决定只讲代码和我认为需要挑出来讲解的难点/细节，对于难点和细节，我决定以提出问题和解决问题的形式来呈现。关于代码，基本只讲书上出现过的代码，实在有需要我再自己补充代码。毕竟基础知识的话，我觉得书上写的已经足够详细了，我再复述一遍没什么太多的意义，所以，大家看书的话，常看常新呀，总之就是一定要常看。\n因为代码是更加直观的东西，并且，我们最终都是要去实际地写代码的。所以，我这里将着重去讲解书上出现的每一处代码，我认为能够理解代码，并且把这些代码实际应用到我们实际的项目中去，这才是真正有意义的事情。\n如果我们能做到完全理解书上的这些代码，做到看到这些代码时心中有底，我觉得那就是胜利。同时，如果习题里面有涉及代码的部分，我们也不会错过。\n尽量做到：一切都在代码中。这样，如果有人问，你读过这本书吗？我们可以很有底气地说，读过，毕竟，代码全都掌握了，难道还不算读过吗？\n这里还要额外多说一点，就是，从这一章开始，我在视频中演示代码所使用的编辑器将换到 neovim + neovide 这样一个组合，然后，在 Windows 平台下，我会使用 pwsh 也就是 powershell 脚本来进行自动化编译和运行，而在 Linux 中，我将使用 shell 脚本来自动化编译和运行。当然，构建工具使用的肯定是 cmake。\n那么，就直接看代码吧。\n说明：代码的命名规范依然以英文原版书中出现的代码的页码为指导原则。\nPart1 英文原书 p32,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int i = 1; 6 int j = 2; 7 i = i + j; 8 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 9 10 return 0; 11} 个人对英文原书 32 页补充代码，custom_p32.cpp,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // bool 类型，通常大小为 1 个字节 6 bool boolean = true; 7 std::cout \u0026lt;\u0026lt; \u0026#34;bool: \u0026#34; \u0026lt;\u0026lt; boolean \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(boolean) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 8 9 // char 类型，8 bits 10 char character = \u0026#39;A\u0026#39;; 11 std::cout \u0026lt;\u0026lt; \u0026#34;char: \u0026#34; \u0026lt;\u0026lt; character \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(character) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 12 13 // wchar_t 类型，宽字符，16 bits 或 32 bits，取决于平台 14 wchar_t wide_character = L\u0026#39;A\u0026#39;; 15 std::wcout \u0026lt;\u0026lt; \u0026#34;wchar_t: \u0026#34; \u0026lt;\u0026lt; wide_character \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(wide_character) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 16 17 // char16_t 类型，16 bits Unicode 字符 18 char16_t unicode_16 = u\u0026#39;A\u0026#39;; 19 std::wcout \u0026lt;\u0026lt; \u0026#34;char16_t: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;wchar_t\u0026gt;(unicode_16) \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(unicode_16) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 20 21 // char32_t 类型，32 bits Unicode 字符 22 char32_t unicode_32 = U\u0026#39;A\u0026#39;; 23 std::wcout \u0026lt;\u0026lt; \u0026#34;char32_t: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;wchar_t\u0026gt;(unicode_32) \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(unicode_32) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 24 25 // short 整数类型，16 bits 26 short short_integer = 16; 27 std::cout \u0026lt;\u0026lt; \u0026#34;short: \u0026#34; \u0026lt;\u0026lt; short_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(short_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 28 29 // int 整数类型，通常至少为 32 bits，但某些系统上可能为 16 bits 30 int integer = 26; 31 std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 32 33 // long 整数类型，通常为 32 bits 34 long long_integer = 36; 35 std::cout \u0026lt;\u0026lt; \u0026#34;long: \u0026#34; \u0026lt;\u0026lt; long_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(long_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 36 37 // long long 整数类型，64 bits 38 long long long_long_integer = 46LL; 39 std::cout \u0026lt;\u0026lt; \u0026#34;long long: \u0026#34; \u0026lt;\u0026lt; long_long_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(long_long_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 40 41 // float 单精度浮点数，精度为 6 位有效数字 42 float single_precision = 3.1f; 43 std::cout \u0026lt;\u0026lt; \u0026#34;float: \u0026#34; \u0026lt;\u0026lt; single_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(single_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; FLT_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 44 45 // double 双精度浮点数，精度为 10 位有效数字 46 double double_precision = 3.14; 47 std::cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; double_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(double_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; DBL_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 48 49 // long double 扩展精度浮点数，通常与 double 相同，但某些系统上可能有更高精度 50 long double extended_precision = 3.1415L; 51 std::cout \u0026lt;\u0026lt; \u0026#34;long double: \u0026#34; \u0026lt;\u0026lt; extended_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(extended_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; LDBL_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 52 53 return 0; 54} 关于这些基本类型，如果有时间的话，推荐大家去看《深入理解计算机系统(第三版)》这本书，英文名是：Computer Systems: A Programmer\u0026rsquo;s Perspective (3rd Edition)，也就是大名鼎鼎的 CSAPP。就拿浮点数来说，这个是我当时完整看过的，所以能够安心地给出评价，那就是如果你想理解浮点数真正的构造及原理，那么，可以抽空看一下这本书。\n那么，如果仅仅停留在本书需要理解的程度，那么，我们就像上面这样写几行代码就可以了解怎么去使用了，\n使用微软的 MSVC 编译器运行的结果如下，\n1bool: 1 (size: 1 bytes) 2char: A (size: 1 bytes) 3wchar_t: A (size: 2 bytes) 4char16_t: A (size: 2 bytes) 5char32_t: A (size: 4 bytes) 6short: 16 (size: 2 bytes) 7int: 26 (size: 4 bytes) 8long: 36 (size: 4 bytes) 9long long: 46 (size: 8 bytes) 10float: 3.1 (size: 4 bytes, precision: 6 significant digits) 11double: 3.14 (size: 8 bytes, precision: 15 significant digits) 12long double: 3.1415 (size: 8 bytes, precision: 15 significant digits) 这里为什么有些尺寸感觉和书上有差异呢？因为书上写的是标准规定的只是最小尺寸，然后在此基础上编译器可以自由发挥。\nPart2 类型转换 p35,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 bool b = 42; // b is true 6 std::cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 7 int i = b; // i has value 1 8 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 9 i = 3.14; // i has value 3 10 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 11 double pi = i; // pi has value 3.0 12 std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; 13 unsigned char c = -1; // assuming 8-bit chars, c has value 255 14 std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; 15 std::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(c) \u0026lt;\u0026lt; std::endl; 16 signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined 17 std::cout \u0026lt;\u0026lt; c2 \u0026lt;\u0026lt; std::endl; 18 std::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(c2) \u0026lt;\u0026lt; std::endl; 19 return 0; 20} p36_1,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int i = 42; 6 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 7 if (i) // condition will evaluate as true 8 i = 0; 9 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 10 return 0; 11} p36_2,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u = 10; 6 int i = -42; 7 std::cout \u0026lt;\u0026lt; i + i \u0026lt;\u0026lt; std::endl; // prints -84 8 std::cout \u0026lt;\u0026lt; u + i \u0026lt;\u0026lt; std::endl; // if 32-bit ints, prints 4294967264 9 10 return 0; 11} 这里书上的解释有点问题，英文原版里面是让我们去看上面的案例，这里中文翻译多给了一些解释，但是这个解释不太能够让人理解，我们还是按照上面的取模的解释来。而对于给负数取模，我们可以把其想象成反方向拨动时钟，然后，从 0 到指针之间的距离就是我们所求的取模后的余数。\np37_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u1 = 42, u2 = 10; 6 std::cout \u0026lt;\u0026lt; u1 - u2 \u0026lt;\u0026lt; std::endl; // ok: result is 32 7 std::cout \u0026lt;\u0026lt; u2 - u1 \u0026lt;\u0026lt; std::endl; // ok: but the result will wrap around 8 9 return 0; 10} p37_02,\n1// 这里需要看一下中文版 p11 也的练习题第 2 题 2#include \u0026lt;iostream\u0026gt; 3 4int main(int argc, char *argv[]) 5{ 6 for (int i = 10; i \u0026gt;= 0; --i) 7 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 8 9 return 0; 10} 按：这里可以到 1.4.1 节(英文 p13)的练习那里去看一下。\np37_03,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 /* 6 // WRONG: u can never be less than 0; the condition will always succeed 7 for (unsigned u = 10; u \u0026gt;= 0; --u) 8 std::cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; std::endl; 9 */ 10 return 0; 11} p37_04,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u = 11; // start the loop one past the first element we want to print 6 while (u \u0026gt; 0) 7 { 8 --u; // decrement first, so that the last iteration will print 0 9 std::cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; std::endl; 10 } 11 12 return 0; 13} Part3 字面值常量 p38_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int a = 20; // 十进制 6 int b = 024; // 八进制 7 int c = 0x14; // 十六进制 8 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; 9 return 0; 10} p38_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 double a = 3.14159; 6 double b = 3.14159E0; 7 double c = 0.; 8 double d = 0e0; 9 double e = .001; 10 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; std::endl; 11 return 0; 12} p39_01,\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3 4int main() 5{ 6 char a = \u0026#39;a\u0026#39;; 7 std::string b = \u0026#34;Hello World!\u0026#34;; 8 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 9 return 0; 10} p39_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // multiline string literal 6 std::cout \u0026lt;\u0026lt; \u0026#34;a really, really long string literal \u0026#34; 7 \u0026#34;that spans two lines\u0026#34; \u0026lt;\u0026lt; std::endl; 8 return 0; 9} p39_03,\n1#include \u0026lt;cstdio\u0026gt; 2#include \u0026lt;iostream\u0026gt; 3 4int main() 5{ 6 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\nWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 7 std::cout \u0026lt;\u0026lt; \u0026#34;Name\\tAge\u0026#34; \u0026lt;\u0026lt; std::endl; 8 std::cout \u0026lt;\u0026lt; \u0026#34;\\a\u0026#34; \u0026lt;\u0026lt; std::endl; 9 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\vWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 10 std::cout \u0026lt;\u0026lt; \u0026#34;Helloo\\b World\u0026#34; \u0026lt;\u0026lt; std::endl; 11 std::cout \u0026lt;\u0026lt; \u0026#34;He said, \\\u0026#34;Hello!\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; std::endl; 12 std::cout \u0026lt;\u0026lt; \u0026#34;C:\\\\Program Files\u0026#34; \u0026lt;\u0026lt; std::endl; 13 std::cout \u0026lt;\u0026lt; \u0026#34;What\\?\u0026#34; \u0026lt;\u0026lt; std::endl; 14 std::cout \u0026lt;\u0026lt; \u0026#34;It\\\u0026#39;s a cat\u0026#34; \u0026lt;\u0026lt; std::endl; 15 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\rWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 16 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\fWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 17 getchar(); 18 return 0; 19} p39_04,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints a newline 6 std::cout \u0026lt;\u0026lt; \u0026#34;\\tHi!\\n\u0026#34;; // prints a tab followd by \u0026#34;Hi!\u0026#34; and a newline 7 return 0; 8} p39_05,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#34;\\7\u0026#34;; // 在一些环境下会发出提示音，和 \\a 相同 6 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\12World\u0026#34;; // 输出： 7 // Hello 8 // World 9 // 实际效果等同于 \\n 10 11 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\40World\u0026#34;; // 输出：Hello World （插入一个空格） 12 13 char str[] = \u0026#34;Hello\\0World\u0026#34;; 14 std::cout \u0026lt;\u0026lt; str; // 输出：Hello （由于\\0表示字符串结束，World部分不会被输出） 15 16 std::cout \u0026lt;\u0026lt; \u0026#34;\\115\u0026#34;; // 输出：M 17 18 std::cout \u0026lt;\u0026lt; \u0026#34;\\x4d\u0026#34;; // 输出：M 19 return 0; 20} p40_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#34;Hi \\x4dO\\115!\\n\u0026#34;; // prints Hi MOM! followed by a newline 6 std::cout \u0026lt;\u0026lt; \u0026#39;\\115\u0026#39; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints M followed by a newline 7 return 0; 8} p40_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // 1. L\u0026#39;a\u0026#39; - wide character literal (wchar_t) 6 wchar_t wideChar = L\u0026#39;a\u0026#39;; 7 std::wcout \u0026lt;\u0026lt; L\u0026#34;Wide character literal: \u0026#34; \u0026lt;\u0026lt; wideChar \u0026lt;\u0026lt; std::endl; 8 9 // 2. u8\u0026#34;hi!\u0026#34; - UTF-8 string literal 10 const char *utf8String = u8\u0026#34;hi!\u0026#34;; 11 std::cout \u0026lt;\u0026lt; \u0026#34;UTF-8 string literal: \u0026#34; \u0026lt;\u0026lt; utf8String \u0026lt;\u0026lt; std::endl; 12 13 // 3. 42ULL - unsigned long long literal 14 unsigned long long ullValue = 42ULL; 15 std::cout \u0026lt;\u0026lt; \u0026#34;Unsigned long long literal: \u0026#34; \u0026lt;\u0026lt; ullValue \u0026lt;\u0026lt; std::endl; 16 17 // 4. 1E-3F - single-precision floating-point literal (float) 18 float floatValue = 1E-3F; 19 std::cout \u0026lt;\u0026lt; \u0026#34;Single-precision floating-point literal: \u0026#34; \u0026lt;\u0026lt; floatValue \u0026lt;\u0026lt; std::endl; 20 21 // 5. 3.14159L - extended-precision floating-point literal (long double) 22 long double longDoubleValue = 3.14159L; 23 std::cout \u0026lt;\u0026lt; \u0026#34;Extended-precision floating-point literal: \u0026#34; \u0026lt;\u0026lt; longDoubleValue \u0026lt;\u0026lt; std::endl; 24 25 return 0; 26} p41,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() { 4 5 bool test = false; 6 std::cout \u0026lt;\u0026lt; test \u0026lt;\u0026lt; std::endl; 7 return 0; 8} ","permalink":"http://localhost:1313/posts/cpp-primer-ch02-1/","summary":"\u003cp\u003e这一集视频我们来看一下第二章的第一节。从这一集视频开始，我决定只讲代码和我认为需要挑出来讲解的难点/细节，对于难点和细节，我决定以提出问题和解决问题的形式来呈现。关于代码，基本只讲书上出现过的代码，实在有需要我再自己补充代码。毕竟基础知识的话，我觉得书上写的已经足够详细了，我再复述一遍没什么太多的意义，所以，大家看书的话，常看常新呀，总之就是一定要常看。\u003c/p\u003e","title":"C++ Primer 第五版 2.1  笔记"},{"content":"本节主要的内容只有一份代码，就是标题所说的书店程序，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item total; // variable to hold data for the next transaction 6 // read the first transaction and ensure that there are data to process 7 if (std::cin \u0026gt;\u0026gt; total) 8 { 9 Sales_item trans; // variable to hold the running sum 10 // read and process the remaining transactions 11 while (std::cin \u0026gt;\u0026gt; trans) 12 { 13 // if we’re still processing the same book 14 if (total.isbn() == trans.isbn()) 15 total += trans; // update the running total 16 else 17 { 18 // print results for the previous book 19 std::cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; std::endl; 20 total = trans; // total now refers to the next book 21 } 22 } 23 std::cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; std::endl; // print the last transaction 24 } 25 else 26 { 27 // no input! warn the user 28 std::cerr \u0026lt;\u0026lt; \u0026#34;No data?!\u0026#34; \u0026lt;\u0026lt; std::endl; 29 return -1; // indicate failure 30 } 31 return 0; 32} 33 34/* input: 350-201-70353-X 4 24.99 360-201-82470-1 4 45.39 370-201-88954-4 2 15.00 380-201-88954-4 5 12.00 390-201-88954-4 7 12.00 400-201-88954-4 2 12.00 410-399-82477-1 2 45.39 420-399-82477-1 3 45.39 430-201-78345-X 3 20.00 440-201-78345-X 2 25.00 45*/ 可能有同志会注意到这个程序在读取输入的时候，最后可能需要先回车一下，然后按下 Ctrl + Z 然后再回车，才能使程序接收到 EOF(end of file) 信号，这个问题我们只需要知道如何去规避即可，如果想刨根究底，那么，也没有问题，推荐去看以下两个链接，主要是第二个链接，\nhttps://stackoverflow.com/questions/1782080/what-is-eof-in-the-c-programming-language https://stackoverflow.com/questions/5655112/why-do-i-require-multiple-eof-ctrlz-characters ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-6/","summary":"\u003cp\u003e本节主要的内容只有一份代码，就是标题所说的书店程序，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026#34;Sales_item.h\u0026#34;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eSales_item\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// variable to hold data for the next transaction\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// read the first transaction and ensure that there are data to process\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eSales_item\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// variable to hold the running sum\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// read and process the remaining transactions\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e// if we’re still processing the same book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisbn\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisbn\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// update the running total\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e18\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e// print results for the previous book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e19\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e20\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// total now refers to the next book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e21\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e22\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e23\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// print the last transaction\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e24\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e25\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e26\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e27\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// no input! warn the user\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e28\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecerr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;No data?!\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e29\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// indicate failure\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e30\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e31\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e32\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e33\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e34\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/* input:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e35\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-70353-X 4 24.99\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e36\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-82470-1 4 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e37\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 2 15.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e38\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 5 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e39\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 7 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e40\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 2 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e41\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-399-82477-1 2 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e42\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-399-82477-1 3 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e43\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-78345-X 3 20.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e44\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-78345-X 2 25.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e45\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可能有同志会注意到这个程序在读取输入的时候，最后可能需要先回车一下，然后按下 Ctrl + Z 然后再回车，才能使程序接收到 EOF(end of file) 信号，这个\u003ca href=\"https://stackoverflow.com/questions/31261483/why-ctrl-z-does-not-trigger-eof\"\u003e问题\u003c/a\u003e我们只需要知道如何去规避即可，如果想刨根究底，那么，也没有问题，推荐去看以下两个链接，主要是第二个链接，\u003c/p\u003e","title":"C++ Primer 第五版 1.6 书店程序 笔记"},{"content":"这一集我们简要介绍一下类这个知识点。\n所谓的类，我们可以把它想象成一个内置的类型一样的物件，然后，和内置类型不同的点在于，类需要我们自己去设计和定义。\n这一小节主要是让我们看一下如何简单地使用一个类。\nPart1 Sales_item 类 那么，接下来接直接看代码，看一下如何简单地使用 Sales_item 这个类，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3 4int main() 5{ 6 Sales_item book; 7 8 // read ISBN, number of copies sold, and sales price 9 std::cin \u0026gt;\u0026gt; book; 10 // write ISBN, number of copies sold, total revenue, and average price 11 std::cout \u0026lt;\u0026lt; book \u0026lt;\u0026lt; std::endl; 12 13 return 0; 14} 这里插一句，书中的代码也可以直接到配套网站去下载，\nhttps://www.informit.com/store/c-plus-plus-primer-9780321714114\n书上有些没有给出的代码，但是配套代码给出了，那么，对于这一部分，我们就去到配套代码那里给取过来。比如，我们这里的代码想要跑通，就得把 Sales_item.h 这个头文件给复制过来。\n然后，是第二份代码，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item item1, item2; 6 std::cin \u0026gt;\u0026gt; item1 \u0026gt;\u0026gt; item2; // read a pair of transactions 7 std::cout \u0026lt;\u0026lt; item1 + item2 \u0026lt;\u0026lt; std::endl; // print their sum 8 return 0; 9} 按：关于书上提到的重定向操作，在 Windows 的命令行提示符和 Linux 系统的 shell 中，确实可以像下面这样，\n1addItems \u0026lt; infile \u0026gt; outfile 但是，在 PowerShell 中，我们得用另一种语法，\n1Get-Content .\\input.txt | addItems.exe \u0026gt; .\\output.txt Part2 成员函数 然后，是成员函数的简单使用，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item item1, item2; 6 std::cin \u0026gt;\u0026gt; item1 \u0026gt;\u0026gt; item2; 7 // first check that item1 and item2 represent the same book 8 if (item1.isbn() == item2.isbn()) 9 { 10 std::cout \u0026lt;\u0026lt; item1 + item2 \u0026lt;\u0026lt; std::endl; 11 return 0; // indicate success 12 } 13 else 14 { 15 std::cerr \u0026lt;\u0026lt; \u0026#34;Data must refer to same ISBN\u0026#34; \u0026lt;\u0026lt; std::endl; 16 return -1; // indicate failure 17 } 18} 19} ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-5/","summary":"\u003cp\u003e这一集我们简要介绍一下类这个知识点。\u003c/p\u003e\n\u003cp\u003e所谓的类，我们可以把它想象成一个内置的类型一样的物件，然后，和内置类型不同的点在于，类需要我们自己去设计和定义。\u003c/p\u003e","title":"C++ Primer 第五版 1.5 类简介 笔记"},{"content":"如何让你的 VSCode 更加地 sexual？这是一个有意思的的话题，而让光标具有动画效果，可以让其更加赏心悦目，进而提升编写代码的幸福感。\n那么，今天就来介绍一下可以让 VSCode 具有光标动画的插件，只需要安装两个插件，\nApc Customize UI++ VSCode Animations 然后按照官方的文档来操作即可。它们的官方仓库的地址如下，\nhttps://github.com/drcika/apc-extension https://github.com/BrandonKirbyson/VSCode-Animations ","permalink":"http://localhost:1313/posts/vscode-make-caret-or-cursor-animations/","summary":"\u003cp\u003e如何让你的 VSCode 更加地 sexual？这是一个有意思的的话题，而让光标具有动画效果，可以让其更加赏心悦目，进而提升编写代码的幸福感。\u003c/p\u003e\n\u003cp\u003e那么，今天就来介绍一下可以让 VSCode 具有光标动画的插件，只需要安装两个插件，\u003c/p\u003e","title":"VSCode 使光标具有动画效果"},{"content":"这一集视频我们主要来看一下 C++ Primer 1.4 节。\n主要是对几个常用的控制流的语句进行说明，包括，\nwhile 循环 for 循环 读取输入 if 语句 我们这里的讲解主要是对书上示例的代码进行相应的解析，对于大家容易理解的知识点，就不去花费多余的时间来说明。删繁就简，同时，不漏疑难点。\nPart1 while 循环 首先是 while 语句，核心是理解这样一句话，\nwhile 语句反复执行一段代码，直至给定条件为假为止。\n直接看书中的示例代码，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0, val = 1; 5 // keep executing the while as long as val is less than or equal to 10 6 while (val \u0026lt;= 10) 7 { 8 sum += val; // assigns sum + val to sum 9 ++val; // add 1 to val 10 } 11 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 12 return 0; 13} Part2 for 循环 然后是 for 语句，我们更加常用的一种循环语句，\n比如，书上的例子是从 1 加到 10，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0; 5 // sum values from1 through 10 inclusive 6 for (int val = 1; val \u0026lt;= 10; ++val) 7 sum += val; // equivalent to sum = sum + val 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} for 循环后面如果不加花括号，那么，for 循环中只会执行一条语句，\n1#include \u0026lt;iostream\u0026gt; 2int main() { 3 int sum = 0; 4 // sum values from1 through 10 inclusive 5 for (int val = 1; val \u0026lt;= 10; ++val) 6 sum += val; // equivalent to sum = sum + val 7 sum += 100; 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} 11// output: 155 我们再来看加了花括号的效果，\n1#include \u0026lt;iostream\u0026gt; 2int main() { 3 int sum = 0; 4 // sum values from1 through 10 inclusive 5 for (int val = 1; val \u0026lt;= 10; ++val) { 6 sum += val; // equivalent to sum = sum + val 7 sum += 100; 8 } 9 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 10 return 0; 11} 12// output: 1055 Part3 读取输入 读取输入数据。\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0, value = 0; 5 // read until end-of-file, calculating a running total of all values read 6 while (std::cin \u0026gt;\u0026gt; value) 7 sum += value; // equivalent to sum = sum + value 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum is: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} 从键盘输入文件结束符(EOF, end of file)这里，书上说的是在 Windows 下，输入文件结束符的方法是敲 Ctrl + Z，然后按回车键，但是在上面这个程序中无法体现，因为我们只要输入的不是一个 int 值，循环就会结束，比如，我们输入 Ctrl + D 然后回车也是可以的。所以，我们可以单独写一个程序来验证一下这个文件结束符，\n1// 测试一下 Windows 下 Ctrl + Z 然后回车是否是 EOF 2#include \u0026lt;cstdio\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4 5int main() 6{ 7 int x; 8 if ((x = std::cin.get()) == EOF) 9 { 10 std::cout \u0026lt;\u0026lt; \u0026#34;Here is an EOF.\u0026#34; \u0026lt;\u0026lt; std::endl; 11 } 12 return 0; 13} 同时，这一小节中，书上还介绍了编写程序时会导致的一些编译错误，这里具体演示一下，\n语法错误 类型错误 声明错误 首先是语法错误，\n然后是类型错误，比如，\n1int a = \u0026#34;this is a string\u0026#34;; 然后是声明错误，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int v1 = 0, v2 = 0; 5 std::cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; v2; // error: uses \u0026#34;v\u0026#34; not \u0026#34;v1\u0026#34; 6 // error: cout not defined; should be std::cout 7 cout \u0026lt;\u0026lt; v1 + v2 \u0026lt;\u0026lt; std::endl; 8 return 0; 9} Part4 if 1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 // currVal is the number we’re counting; we’ll read new values into val 5 int currVal = 0, val = 0; 6 // read first number and ensure that we have data to process 7 if (std::cin \u0026gt;\u0026gt; currVal) 8 { 9 int cnt = 1; // store the count for the current value we’re processing 10 while (std::cin \u0026gt;\u0026gt; val) 11 { // read the remaining numbers 12 if (val == currVal) // if the values are the same 13 ++cnt; // add 1 to cnt 14 else 15 { // otherwise, print the count for the previous value 16 std::cout \u0026lt;\u0026lt; currVal \u0026lt;\u0026lt; \u0026#34; occurs \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; std::endl; 17 currVal = val; // remember the new value 18 cnt = 1; // reset the counter 19 } 20 } // while loop ends here 21 // remember to print the count for the last value in the file 22 std::cout \u0026lt;\u0026lt; currVal \u0026lt;\u0026lt; \u0026#34; occurs \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; std::endl; 23 } // outermost if statement ends here 24 return 0; 25} 26// input: 42 42 42 42 42 55 55 62 100 100 100 ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-4/","summary":"\u003cp\u003e这一集视频我们主要来看一下 C++ Primer 1.4 节。\u003c/p\u003e\n\u003cp\u003e主要是对几个常用的控制流的语句进行说明，包括，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewhile 循环\u003c/li\u003e\n\u003cli\u003efor 循环\u003c/li\u003e\n\u003cli\u003e读取输入\u003c/li\u003e\n\u003cli\u003eif 语句\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们这里的讲解主要是对书上示例的代码进行相应的解析，对于大家容易理解的知识点，就不去花费多余的时间来说明。删繁就简，同时，不漏疑难点。\u003c/p\u003e","title":"C++ Primer 第五版 1.4 控制流 笔记"},{"content":"《算法竞赛入门经典》(第二版) 第 6 章例题 6-1。\n题目描述 英文描述 Programs executed concurrently on a uniprocessor system appear to be executed at the same time, but in reality the single CPU alternates between the programs, executing some number of instructions from each program before switching to the next. You are to simulate the concurrent execution of up to ten programs on such a system and determine the output that they will produce.\nThe program that is currently being executed is said to be running, while all programs awaiting execution are said to be ready. A program consists of a sequence of no more than 25 statements, one per line, followed by an end statement. The statements available are listed below.\nA variable is any single lowercase alphabetic character and a constant is an unsigned decimal number less than 100. There are only 26 variables in the computer system, and they are shared among the programs. Thus assignments to a variable in one program affect the value that might be printed by a different program. All variables are initially set to zero.\nEach statement requires an integral number of time units to execute. The running program is permitted to continue executing instructions for a period of time called its quantum. When a program’s time quantum expires, another ready program will be selected to run. Any instruction currently being executed when the time quantum expires will be allowed to complete.\nPrograms are queued first-in-first-out for execution in a ready queue. The initial order of the ready queue corresponds to the original order of the programs in the input file. This order can change, however, as a result of the execution of lock and unlock statements.\nThe lock and unlock statements are used whenever a program wishes to claim mutually exclusive access to the variables it is manipulating. These statements always occur in pairs, bracketing one or more other statements. A lock will always precede an unlock, and these statements will never be nested. Once a program successfully executes a lock statement, no other program may successfully execute a lock statement until the locking program runs and executes the corresponding unlock statement. Should a running program attempt to execute a lock while one is already in effect, this program will be placed at the end of the blocked queue. Programs blocked in this fashion lose any of their current time quantum remaining. When an unlock is executed, any program at the head of the blocked queue is moved to the head of the ready queue. The first statement this program will execute when it runs will be the lock statement that previously failed. Note that it is up to the programs involved to enforce the mutual exclusion protocol through correct usage of lock and unlock statements. (A renegade program with no lock/unlock pair could alter any variables it wished, despite the proper use of lock/unlock by the other programs.)\nInput\nThe input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.\nThe first line of the input file consists of seven integers separated by spaces. These integers specify (in order): the number of programs which follow, the unit execution times for each of the five statements (in the order given above), and the number of time units comprising the time quantum. The remainder of the input consists of the programs, which are correctly formed from statements according to the rules described above.\nAll program statements begin in the first column of a line. Blanks appearing in a statement should be ignored. Associated with each program is an identification number based upon its location in the input data (the first program has ID = 1, the second has ID = 2, etc.).\nOutput\nFor each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.\nYour output will contain of the output generated by the print statements as they occur during the simulation. When a print statement is executed, your program should display the program ID, a colon, a space, and the value of the selected variable. Output from separate print statements should appear on separate lines.\nSample Input\n3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end Sample Output\n1: 3 2: 3 3: 17 3: 9 1: 9 1: 9 2: 8 2: 8 3: 21 3: 21 题目全文·中文翻译 在单处理器系统上并发执行的程序看起来像是同时执行的，但实际上单个 CPU 在多个程序之间交替执行，在切换到下一个程序之前，每个程序执行一定数量的指令。你需要模拟最多十个程序在这种系统上的并发执行，并确定它们将产生的输出。\n当前正在执行的程序称为“运行中”，而所有等待执行的程序称为“就绪”。一个程序由不超过 25 条语句的序列组成，每行一条语句，最后以一个结束语句结尾。可用的语句列在下面。\n一个变量是任何单个的小写字母字符，常量是小于 100 的无符号十进制数。系统中只有 26 个变量(按：也就是 26 个英文字母)，并且这些变量在所有程序中共享。因此，一个程序中对变量的赋值会影响其他程序可能打印的值。所有变量初始值均为零。\n每条语句的执行都需要一个整数量的时间单位。运行中的程序被允许在一个称为“时间片”的时间段内继续执行指令。当程序的时间片耗尽时，将选择另一个就绪程序来运行。当时间片到期时，正在执行的指令会被允许完成。\n程序按照先进先出的顺序排队执行，就绪队列的初始顺序与输入文件中的程序顺序相对应。然而，由于锁（lock）和解锁（unlock）语句的执行，这一顺序可能发生变化。\n当一个程序希望对其操作的变量进行互斥访问时，会使用锁和解锁语句。这些语句总是成对出现，包围一个或多个其他语句。锁语句总是先于解锁语句执行，并且这些语句不会嵌套。一旦程序成功执行锁语句，其他程序在锁定程序运行并执行相应的解锁语句之前，无法成功执行锁语句。如果一个正在运行的程序在已有锁生效时尝试执行锁语句，该程序将被放置到阻塞队列的末尾。以这种方式被阻塞的程序会失去当前剩余的时间片。当解锁语句执行时，阻塞队列头部的程序会被移到就绪队列的头部。该程序在运行时执行的第一条语句将是之前失败的锁语句。需要注意的是，互斥协议的实施依赖于程序通过正确使用锁和解锁语句来实现。（一个不遵循锁/解锁规则的流氓程序仍然可以随意修改任何变量，尽管其他程序正确使用了锁/解锁语句。）\n输入\n输入以一行包含单个正整数的行开始，表示接下来要处理的测试用例数量，每个测试用例如以下所述。该行后有一行空行，两个连续输入之间也有一行空行。\n输入文件的第一行由七个用空格分隔的整数组成。这些整数按顺序指定：后续程序的数量、五条语句的单位执行时间（按上述顺序）、以及构成时间片的时间单位数。输入的其余部分由程序组成，这些程序根据上述规则正确由语句组成。\n所有程序语句都从行的第一列开始。语句中的空格应被忽略。每个程序都有一个与其在输入数据中的位置相关的标识号（第一个程序的 ID = 1，第二个程序的 ID = 2，以此类推）。\n输出\n对于每个测试用例，输出必须遵循以下描述。两个连续测试用例的输出之间应有一个空行。\n你的输出应包含在模拟过程中由 print 语句生成的输出。当 print 语句被执行时，程序应显示程序 ID、一个冒号、一个空格，以及被选变量的值。不同 print 语句的输出应分别显示在不同的行上。\n输入样例\n3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end 输出样例\n1: 3 2: 3 3: 17 3: 9 1: 9 1: 9 2: 8 2: 8 3: 21 3: 21 注意：这里的输入样例是有问题的，修正后如下：\n1 3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end 思路分析 核心的思路就是模拟。所需要使用的数据结构是队列。普通队列和双端队列都需要。\n好吧，其实这题的关键是理解题意。看懂输入输出要干什么就可以了。\n我们先来看输入，\n第一行的 1 表示有接下来有一个 case 需要我们去处理，然后接下来的下一行是空行，这是固定的格式要求，然后，下一行是\n13 1 1 1 1 1 1 其中，3 表示接下来有 3 个 program 要并行运行。然后，\n第一个 1：赋值(Assignment)语句花费的时间。 第二个 1：输出(Output)语句花费的时间。 第三个 1：锁(lock)语句花费的时间。 第四个 1：解锁(unlock)语句花费的时间。 第五个 1：结束(end)语句花费的时间。 最后的 1 表示：cpu 会分配的时间片的长短。\n关于对题目的理解，有个地方需要注意一下，\n当时间片到期时，正在执行的指令会被允许完成。\n比如某个语句(指令)执行主要 4 个单位的时间，但是当前被分配的时间片只剩 2 个单位了，没关系，这个语句依旧会被执行。\n书中还提出了一个问题：本题不会出现越界错误，为什么？这是因为在执行插入到队首这个动作之前，队首的元素已经被 pop 出来进行处理了，所以队首总是空着一个位置的，这时如果想要插入一个元素到队首，自然不会发生越界的情况。\n那么，本题的思路，说起来其实很简单：\n先把所有的程序按照输入的顺序放入 ready 队列中； 然后，逐个从队列中 pop 出程序进行处理。 具体的处理过程如下，\n如果当前这次时间片用完了，但是程序还没有执行完，那么，记录当前执行到的位置，再将程序放入 ready 队列中； 当前运行到了程序结尾，此程序生命周期结束，无需额外操作； 如果遇到了 lock 语句，那么，根据当前是否有其他程序上了锁来进行处理； 如果已经被上锁，那么，将当前程序放入 block 队列，时间片如果还没用完，那么，也作废了； 如果还没有被上锁，那么，进行上锁操作(这里其实就是设置以下 locked 这个全局变量)，然后还是正常执行； 如果遇到了 unlock， 如果阻塞队列不为空，出队一个元素，然后，入队到 ready 的队首； 接下来还是正常运行。 代码分析 代码分析就全部在注释里面了。如果觉得不够清晰，那就再听一听我视频里面的讲解。\n主要就三个部分。\n全局变量定义 1const int maxlinecnt = 1000; // 最多 1000 行，这是一个大致的数量 2const int linecharcnt = 10; // 每一行的字符串长度不会超过 10(按：这是推断出来的，我们假定程序中没有过多的空格，否则这里就还需要再调整) 3 4deque\u0026lt;int\u0026gt; readyQ; // ready 队列 5queue\u0026lt;int\u0026gt; blockQ; // 存放被阻塞的程序的队列 6int n; // 会参与并行运行的程序的数量 7int quantum; // 时间片长度 8int c[5]; // 每个语句所需的运行时间 9int var[26]; // 最多 26 个变量 10int ip[maxlinecnt]; // ip[pid]是程序pid的当前行号。所有程序都存在prog数组，更类似真实的情况，代码也更短 11bool locked; // 是否已经被锁住 12char prog[maxlinecnt][linecharcnt]; // 存储所有程序的指令，每个程序的每条指令都是一行字符串 主要的模拟函数 1void run(int pid) { 2 int q = quantum; 3 while (q \u0026gt; 0) { 4 char *p = prog[ip[pid]]; // 取出 pid 号程序中当前该运行的那一行 5 switch (p[2]) { // 根据第 3 个字符来判断 6 case \u0026#39;=\u0026#39;: // 赋值 7 var[p[0] - \u0026#39;a\u0026#39;] = isdigit(p[5]) ? (p[4] - \u0026#39;0\u0026#39;) * 10 + p[5] - \u0026#39;0\u0026#39; : p[4] - \u0026#39;0\u0026#39;; 8 q -= c[0]; 9 break; 10 case \u0026#39;i\u0026#39;: // 打印 11 printf(\u0026#34;%d: %d\\n\u0026#34;, pid + 1, var[p[6] - \u0026#39;a\u0026#39;]); 12 q -= c[1]; 13 break; 14 case \u0026#39;c\u0026#39;: // lock 15 if (locked) { 16 blockQ.push(pid); // 放入阻塞队列 17 return; 18 } 19 locked = true; 20 q -= c[2]; 21 break; 22 case \u0026#39;l\u0026#39;: // unlock 23 locked = false; 24 if (!blockQ.empty()) { 25 int pid2 = blockQ.front(); 26 blockQ.pop(); 27 readyQ.push_front(pid2); 28 } 29 q -= c[3]; 30 break; 31 case \u0026#39;d\u0026#39;: // end 32 return; 33 } 34 ip[pid]++; 35 } 36 readyQ.push_back(pid); 37} main 函数 主要是做一些数据的读入操作。\n1int main() { 2 // 重定向输入数据，省去我们手动输入的繁琐 3 string relativePathToCurrentCFile = \u0026#34;./data/UVa210/input1.txt\u0026#34;; 4 // relativePathToCurrentCFile = \u0026#34;./data/UVa210/input3.txt\u0026#34;; 5 freopen(string(\u0026#34;./ch06\u0026#34; + relativePathToCurrentCFile.substr(1, relativePathToCurrentCFile.size() - 1)).c_str(), \u0026#34;r\u0026#34;, stdin); 6 7 int T; // input 数据中 case 的数量 8 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 9 while (T--) { // 分别处理每一个 case 10 scanf(\u0026#34;%d %d %d %d %d %d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;c[0], \u0026amp;c[1], \u0026amp;c[2], \u0026amp;c[3], \u0026amp;c[4], \u0026amp;quantum); 11 memset(var, 0, sizeof(var)); 12 13 int line = 0; 14 for (int i = 0; i \u0026lt; n; i++) { 15 fgets(prog[line++], maxlinecnt, stdin); // 按行读取数据 16 ip[i] = line - 1; 17 while (prog[line - 1][2] != \u0026#39;d\u0026#39;) 18 fgets(prog[line++], linecharcnt, stdin); 19 readyQ.push_back(i); // 把 id 为 i 的程序入队 20 } 21 22 locked = false; // 初始值为 false 23 while (!readyQ.empty()) { 24 int pid = readyQ.front(); 25 readyQ.pop_front(); 26 run(pid); 27 } 28 if (T) 29 printf(\u0026#34;\\n\u0026#34;); 30 } 31 return 0; 32} ","permalink":"http://localhost:1313/posts/uva210/","summary":"UVa210 解题思路及代码解析","title":"UVa210"},{"content":"这一集视频我们主要来看一下 C++ Primer 1.3 节。\n从这一集视频开始，我将继续采取挑取核心重点的形式来进行解说。如果是很简单的东西，那么会简单带过，如果是需要注意或者不容易理解的细节，那么，也绝对不会漏掉。这样一来，可以一定程度上保证信息密度。整体会结合我记录的笔记来和大家讲解。当然，书中所给出的每一处示例代码，都不会跳过，这一点也请大家放心。\n并且，从这一节开始，我们将采用 CMake 来作为我们代码的构建工具，这样，我们就可以进一步把精力集中在语言学习本身了。\n这一节介绍了 C++ 的注释，内容很少。需要理解的地方，就两个点，\n单行注释 多行注释 这里，仔细看书上的示例代码，理解一下就好。\n1#include \u0026lt;iostream\u0026gt; 2/* 3 * Simple main function: 4 * Read two numbers and write their sum 5 */ 6int main() { 7 // 提示用户输入两个数 8 std::cout \u0026lt;\u0026lt; \u0026#34;Enter two numbers:\u0026#34; \u0026lt;\u0026lt; std::endl; 9 int v1 = 0, v2 = 0; // 保存我们读入的输入数据的变量 10 std::cin \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2; // 读取输入数据 11 std::cout \u0026lt;\u0026lt; \u0026#34;The sum of \u0026#34; \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; v2 \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; v1 + v2 \u0026lt;\u0026lt; std::endl; 12 return 0; 13} 然后，对于单行注释，大家放心去用即可：单行注释以双斜线（//）开始，以换行符结束。// 后面可以接任何的字符，那么，当然也包括 // 本身。\n对于多行注释，也就是用注释界定符的这个注释，需要注意一下不能嵌套。我们实际看一个例子就明白了。\n1// 不能像下面这样有嵌套，会报错 2/* 3 * 注释对 /* */ 不能嵌套 4 * “不能嵌套”几个字会被认为是源码 5 * 像剩余程序一样处理 6 */ 7int main() 8{ 9 return 0; 10} 需要注意一点，/* */ 形式的注释也可以用于单行注释。这里我们也来看一个例子，\n1int main() 2{ 3 /* 也可以用作单行注释 */ 4 return 0; 5} ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-3/","summary":"\u003cp\u003e这一集视频我们主要来看一下 C++ Primer 1.3 节。\u003c/p\u003e\n\u003cp\u003e从这一集视频开始，我将继续采取挑取核心重点的形式来进行解说。如果是很简单的东西，那么会简单带过，如果是需要注意或者不容易理解的细节，那么，也绝对不会漏掉。这样一来，可以一定程度上保证信息密度。整体会结合我记录的笔记来和大家讲解。当然，书中所给出的每一处示例代码，都不会跳过，这一点也请大家放心。\u003c/p\u003e","title":"C++ Primer 第五版 1.3 注释简介 笔记"},{"content":"本文假定读者的 Linux 环境为 Arch Linux + KDE。\nKitty 重要程度：必装。\n直接命令行安装，\n1yay -S kitty fish 重要程度：必装。\n直接命令行安装，\n1yay -S fish kitty 和 fish 安装好之后，其实就基本可以使用了。\ngcc 重要程度：必装。\n直接命令行安装，\n1yay -S gcc CMake 重要程度：必装。\n直接命令行安装，\n1yay -S cmake VSCode 重要程度：必装。\n直接命令行安装，\n1yay -S visual-studio-code-bin 安装好之后，安装几个插件，\nclangd CMake 然后，可以把 VSCode 的默认的 shell 设置成 fish。这个直接在 settings.json 配置文件中加一行配置即可，\n1\u0026#34;terminal.integrated.defaultProfile.linux\u0026#34;: \u0026#34;fish\u0026#34;, 然后，就可以新建一个项目试一下使用了。\n如果有遇到 cmake 插件让选择编译器的，记得选择 gcc，\nNeovim 首先，安装一些必要的软件，\n1yay -S nodejs 2yay -S npm 3yay -S p7zip 4yay -S bottom 5yay -S fastfetch 6yay -S fd 7yay -S gitui 8yay -S grep 9yay -S ripgrep 10yay -S starship 然后，在命令行中复制我的 neovim 配置，\n1git clone https://github.com/fanlumaster/lazyvim-archlinux.git ~/.config/nvim 然后，运行 neovim，\n1nvim 然后，在 nvim 中使用 mason 安装 clangd，\n1:MasonInstall clangd 这样一来，环境差不多就配置好了。\n对于 Linux 用户，我想对命令行应该都不陌生，所以，就不去讲配置 starship 这种比较简单的操作了。\n","permalink":"http://localhost:1313/posts/cpp-coding-environment-configuration-linux-version/","summary":"\u003cp\u003e本文假定读者的 Linux 环境为 Arch Linux + KDE。\u003c/p\u003e\n\u003ch2 id=\"kitty\"\u003eKitty\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e直接命令行安装，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eyay -S kitty\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"fish\"\u003efish\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e直接命令行安装，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eyay -S fish\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ekitty 和 fish 安装好之后，其实就基本可以使用了。\u003c/p\u003e","title":"Linux 系统下的 C++ 编程环境配置"},{"content":"Windows Terminal 重要程度：必装。\n到微软的应用商店中找到 Windows Terminal 和 Windows Terminal Perivew(预览版) 任意选择一个即可。\nPowershell7.0+ 重要程度：必装。\n下载地址：https://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\n选择这个 msi 文件进行下载，然后安装，一路默认下一步即可,\n安装好了之后，可以在 Windows Terminal 中设置一下默认启动 powershell7。\nCMake 重要程度：必装。\n前提：解决了网络的问题。\n首先，通过 scoop 安装 cmake。\n如果还没有安装 scoop，请先到 scoop 的官网安装。\n然后，执行安装命令，\n1scoop install cmake Visual Studio 篇 重要程度：必装。\n因为是需要 C++ 编译套件，所以把使用C++的桌面开发勾选上即可。需要勾选的选项，直接看我下面的截图，\nVisual Studio 直接在初始界面创建 CMake 项目即可。\nVSCode 篇 重要程度：选装。\n来到VSCode官网界面进行下载。\n下载好之后，直接一路下一步，全部按默认的来，因为现在已经 2024 年了，大家的 C 盘没有 1T 也至少 512GB 起步了，不差空间。\n安装好之后，安装几个插件，\nC/C++ CMake 然后，可以把 VSCode 的默认的 shell 设置成 powershell7。\n安装好之后，就可以写简单的 C++ 程序测试一下了。\n1#include \u0026lt;iostream\u0026gt; 2 3int main(int, char**){ 4 std::cout \u0026lt;\u0026lt; \u0026#34;哟西！\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 5} CLion 篇 重要程度：选装。\n来到官网下载安装。\n大家可以自行使用破解或者试用。\n之后新建一个项目就可以开始编写代码了。\nNeovim 篇 重要程度：选装。\n安装 Neovim，\n1scoop install neovim 安装一些常用的软件，\n1scoop install neovide 2scoop install 7zip 3scoop install bottom 4scoop install btop 5scoop install fastfetch 6scoop install fd 7scoop install gitui 8scoop install grep 9scoop install gsudo 10scoop install make 11scoop install nodejs 12scoop install ripgrep 13scoop install starship 14scoop install vcredist2022 15scoop install which 然后到 pwsh(即 powershell)复制我的 neovim 配置，\n1git clone https://github.com/fanlumaster/FanyLazyvim.git $env:LOCALAPPDATA\\nvim 然后，打开 neovim 等待其自动下载插件，配置一会儿即可，\n1nvim 然后，在 nvim 中使用 mason 安装 clangd，\n1:MasonInstall clangd 这样一来，环境差不多就配置好了。\n然后，还可以稍微配置一下 powershell，这里就简单设置一下 starship，\n1nvim $PROFILE 1Invoke-Expression (\u0026amp;starship init powershell) 参考：\n1、https://www.lazyvim.org/installation\n","permalink":"http://localhost:1313/posts/cpp-coding-environment-configuration-windows-version/","summary":"\u003ch2 id=\"windows-terminal\"\u003eWindows Terminal\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e到微软的应用商店中找到 Windows Terminal 和 Windows Terminal Perivew(预览版) 任意选择一个即可。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/VmjKSpKC/image.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"powershell70\"\u003ePowershell7.0+\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e下载地址：\u003ca href=\"https://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\"\u003ehttps://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e选择这个 msi 文件进行下载，然后安装，一路默认下一步即可,\u003c/p\u003e","title":"Windows 系统下的 C++ 编程环境配置"},{"content":"Hey 朋友们，今天我们来聊一期系列介绍的视频。\n谈一谈我接下来将要在 B 站投稿的 C++ Primer 第五版的系列视频。\n名字叫：【大学生】《C++ Primer》精读精讲\n面向人群 大学生。尤其是大一大二的学生。不限于计算机相关专业，不限文理科。计算机领域是相当包容的。因为是相当于入门课程，所以可能会比较啰唆，甚至是照本宣科，所以，高年级的同学可能没有那么多时间来观看，以及，以高年级同学的知识储备来讲，可能内容偏基础。\n我希望大家准备的东西 一台电脑。无论是运行 Windows11/10 还是 Linux 的电脑，都可以。 畅通的网络，即可以流畅地访问 Google、GitHub、Stackoverflow 等等。限于某些原因，我无法在这里给大家讲解这部分的内容，但相信大家在网上应该可以找到对应的材料，实在不行，让身边的小伙伴手把手教一下请他/她吃顿饭也成。 为什么想要出这一个系列的视频 《C++ Primer》这本书用来打基础是相当好的，但是，这本书有一个缺点，也是我认为的惟一的缺点，那就是，有那么一丢丢阅读的门槛。我相信，很多人都听说过这本书，也读过这本书，但是，真正能把这本书读完的，十中无一。我以前也没有读完，最近重新捡起来读，花费了一个月，每天大概读四五个小时，最终是把这本书读完了。也正是因为仔细读了一遍下来，才知道这本书确实是真正地好书，也就促成了我录这个视频来分享交流的契机。\n所以，我这一系列的视频，就是为了打破这个门槛。让初入校园或者刚接触编程或者刚接触 C++ 的同学能够破除阻碍，读下这本书，从而为自己的爱好打下一个良好的基础。\n使用的教材以及获取方式 教材当时是视频标题的这本《C++ Primer》第五版啦。这本书是十年前出版的，但是，我读完之后，发现其中的内容鞭辟入里，放在今天一点也不过时，同时，结合国内外的评论，发现大家的看法也都是类似的，那就是，推荐。\n豆瓣上的评分：https://book.douban.com/subject/10505113/。\n获取方式如下，\n英文版：\nhttps://zhjwpku.com/assets/pdf/books/C++.Primer.5th.Edition_2013.pdf 中文版：\nC++ Primer 中文版·第五版 或者，有条件的直接到微信读书开一个会员即可。 也可以到以下网站去检索一下：\nzlibrary 安娜的档案 我讲解的方式 对于重要的文本，逐字逐句讲解，不落下。 对于书中出现的示例代码，一个不落，全部拓展成完整的可以运行的源文件进行测试。并且，全部在视频中手动编写、编译(包括借助 IDE)、运行。代码编排的顺序大概以英文版的页码为主。 有时候可能会结合其他材料，比如：网上的技术博客、cppreference 网站、GitHub 讨论区、stackoverflow、reddit 论坛的讨论等等。 对于习题，尽量全部讲解，但是更新的速度可能比主要的章节要慢一些。视频主要的节奏还是以非习题的主体部分为主。 我的想法还是，以代码为主，希望大家能够跟我一起边看边敲。有我的视频在，大家在编写、编译、调试、运行代码的过程中，基本上是不会有什么问题的，这样就可以把精力集中在学习编程语言本身这个事情上来。\n这里还是要多说一点，就是，我讲解的内容只能保证尽量通俗，大家额外该看的资料肯定是不能少的。也希望大家多多给我提意见，我会不断改进，有好的建议我会做成补充视频的形式，供大家参考。\n我演示编写代码的工具 编译套件 命令行或者 CMake。对于演示和学习而言，这两者足够简单并且够用。\nCMake 现在也是编写 C++ 大型项目的主流工具，不过，我们在学习的过程中只会用到很简单很简单的一小部分。\n具体到编译器，那么，在 Windows 中使用微软家的 MSVC 编译套件系列；在 Linux 中使用 gcc/g++ 套件。\n操作系统 Windows11 Arch Linux KDE(wayland) 代码编辑器/IDE 主要是 Neovim + Neovide。然后借助 Powershell 脚本或者 shell 脚本来自动化 CMake 的编译过程，然后运行。\n我的 Neovim 配置是公开的，我把它们放在了我另一个 GitHub 帐号中：\nWindows 中的 Neovim 配置：https://github.com/fanlumaster/FanyLazyvim Linux 中的 Neovim 配置：https://github.com/fanlumaster/lazyvim-archlinux 会介绍 VSCode、Visual Studio、CLion 的使用，大家随意使用。\n我自己除了在前期的编程环境配置视频中会使用 IDE 以外，后期应该都会使用 neovim 来进行代码编写。对于代码调试，在 Windows 端我会使用 Visual Studio 或者 VSCode；在 Linux 我会使用 gdb 或者 VSCode。\n终端工具 或者，大家也可以称其为命令行工具。\nWindows 下，建议使用 Windows Terminal + Powershell7 Linux 下，建议使用 Kitty + fish 大家可能会有的一些疑问 有课时的顾虑吗？ 当然没有，这里不是大学，不是正式的老师，不用恪守严格的规则。所以，我个人对课时不设限制，不会有大学老师所说的因为课时压缩等等原因而去跳过一些内容。所以，书中所有的内容都会涉及。\n收费吗？可以转载吗？ 我都放在 B 站了(条件允许也会同步到 Youtube)，那当然是不会收费。并且，以后也不会收费。整本书的讲解都不会收费。我争取把整本书讲完，希望能够得到大家的支持。\n不管是视频还是博客，任何形式的转载、下载都是可以的，包括商业、非商业。当然，一定要注明出处哈。\n视频涉及到的文档和代码材料在哪里？ 所有的文稿都会放在我这个博客里面。并且在每个视频的简介里面附上 url 地址。\n视频中所涉及的代码材料，我都会放在我当前的这个 GitHub 中。\nup 主会讲解其他的编程语言或者算法题吗？ 大概率会。比如，我还有一些书想录制一些视频讲一下，比如，《流畅的 Python》第二版、《C 程序设计语言》K\u0026amp;R 第二版等。\n对于数据结构和算法相关，我也想录制一些《算法竞赛入门经典》第二版、《数据结构与算法分析 C 语言描述》这类的视频。\n总之，如果时间没有问题的话，我不打算给自己的题材设限。\n会有一些小项目之类的视频吗？ 会有的。目前的想法是先把一门完整的编程语言讲完，后续会录制项目相关视频。\n当然，希望大家不要有太多的期待。因为我并不会整一些培训班的项目，可能顶多就是一些小游戏、或者像是在屏幕中显示键盘按下的按键、中文输入法开发这样的小众的项目。这也和我录制这些视频的初衷相吻合，我录制视频的目的并非是面向找工作，而且希望大家真的能够为了自己喜欢的编程奉献一点时间。\n可以私信问 up 问题吗？ 当然可以，不过，更建议以评论的方式留言，这样，我漏掉的时候还会有其他朋友来帮助回答。\n欢迎多多评论。无论是在 B 站还是我这个博客下面。\n声明 本人水平有限，欢迎随便喷。可以在视频的评论区吐槽，可以在博客的评论区留言，如果有理有据，那当然是更好啦，承诺：遇到错误，一定修正。\n以及，有时间会做字幕，没空的时候就不加字幕了，望担待。\n好，本期视频的前言就介绍到这里，下一期视频，我们将讲解 Windows 和 Linux 系统中 C++ 编程环境的搭建。\n","permalink":"http://localhost:1313/posts/bilibili-cpp-primer-0-1-preface/","summary":"\u003cp\u003eHey 朋友们，今天我们来聊一期系列介绍的视频。\u003c/p\u003e\n\u003cp\u003e谈一谈我接下来将要在 B 站投稿的 C++ Primer 第五版的系列视频。\u003c/p\u003e\n\u003cp\u003e名字叫：【大学生】《C++ Primer》精读精讲\u003c/p\u003e\n\u003ch2 id=\"面向人群\"\u003e面向人群\u003c/h2\u003e\n\u003cp\u003e大学生。尤其是大一大二的学生。不限于计算机相关专业，不限文理科。计算机领域是相当包容的。因为是相当于入门课程，所以可能会比较啰唆，甚至是照本宣科，所以，高年级的同学可能没有那么多时间来观看，以及，以高年级同学的知识储备来讲，可能内容偏基础。\u003c/p\u003e","title":"Bilibili C++ Primer 精读精讲 ch0-1 前言"},{"content":"编程体验 CS 相关的同学比较感兴趣。\n首先看编程语言。\n简单起见，就稍微看一下 C++ 和 Python 这两门语言在 Arch + KDE 上的表现如何。\n然后，看编程工具。同时我们想要看一下代码的提示功能如何。\nNeovim: 弄潮儿，Neovide VSCode Godot 然后，是终端，\nkitty 日常工具 输入法 pdf 阅读工具 浏览器 goldendict 音乐体验 telegram ","permalink":"http://localhost:1313/posts/is-arch-kde-wayland-good-for-daily-use/","summary":"\u003ch2 id=\"编程体验\"\u003e编程体验\u003c/h2\u003e\n\u003cp\u003eCS 相关的同学比较感兴趣。\u003c/p\u003e\n\u003cp\u003e首先看编程语言。\u003c/p\u003e\n\u003cp\u003e简单起见，就稍微看一下 C++ 和 Python 这两门语言在 Arch + KDE 上的表现如何。\u003c/p\u003e\n\u003cp\u003e然后，看编程工具。同时我们想要看一下代码的提示功能如何。\u003c/p\u003e","title":"Arch Linux KDE 适合我们作为一个日常的操作系统去使用吗？"},{"content":"前言 首先，建议大家读一下原题目，题目的内容这里就不放了，大家可以到这个地址去下载: https://vjudge.net/problem/UVA-12569，有些人可能说英文不太好，那么，也没关系，除了查字典，现在还可以使用这个翻译插件：沉浸式翻译，总之，现在英语语言层面的问题是不会有问题的。\n为什么我建议大家读原题目呢？虽然我们大家接触到这个题目可能都是通过刘汝佳的这本《算法竞赛入门经典》才选择去看的，但是，书中给出的描述都是很略的，简单讲一点，题目很重要的输入和输出样例数据，书上一般都是没有的，其他的细节更不必说。大概就这样。\n然后，我们来详细研究一下 UVa12569 这道题的思路和解析。\n这道题整体的思路是 BFS。然后代码参考(可能有我的微小调整)的是《算法竞赛入门经典-习题与解答》的配套代码，GitHub 地址为：https://github.com/sukhoeing/aoapc-bac2nd-keys。\n此外，如果我们想要更多的测试数据，这个 udebug 的网站也是必不可少的：https://www.udebug.com。本题的测试数据地址为：https://www.udebug.com/UVa/12569。\n同时，我的代码托管在了这个地址：https://github.com/sonnycalcr/aoapc-homework。\n首先，这道题很多人可能觉得简单，我说一下我的观点：对于初学者或者算法初阶的同学来讲，这道题还是有很多值得学习的部分的。\n接下来，我挑一些关键的代码讲一下，更详细的解释在代码的注释里面。\n注意，在具体看/写代码之前，我们首先要明确一个点，题目中的编号是从 1 开始递增的，而下面我们的程序都是从 0 开始递增的。\nPart1 先看数据结构，一个是 Node，\n1struct Node { 2 int from, to; 3 Node *next; 4}; Node 是表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点，主要是用来在 State 类型中表示 path，也就是当前的状态是由上一个状态从 from 移动了机器人/石头到 to 而转化过来的。\nPart2 再看 State，\n1struct State { 2 Node *path; // 路径 3 int g; // 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 \u0026lt;= n \u0026lt;= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头 4 int len; // 路径长度，到了当前状态已经经历的长度 5 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 6 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } // 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头 7 inline void setRock(size_t i, bool val = true) { // 设置位置 i 上是否有石头 8 if (val) 9 g |= 1 \u0026lt;\u0026lt; (i + 4); // 位或操作来把第(i + 4)位来置 1 10 else 11 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); // 先取反，再用与操作来把第(i + 4)位来置 0 12 } 13 // 机器人的位置操作 14 inline int getP() const { return g \u0026amp; 15; } // 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置 15 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } // 设置机器人的位置，这里先右移再左移 4 位清除原有的数据 16}; 所谓的 State，就是当前的局面，由以下几个维度的数据构成，\npath 是路径，上面讲过了，其中保存了上一个状态转变到当前状态是移动了哪一个编号，然后又是移动到了哪一个编号，同时 next 指向了上一次状态的 path。 g 代表了整体的状态，其中，前 4 位(分别是：0, 1, 2, 3)二进制值作为一个整体可以转化成十进制，表示了当前机器人在哪个编号的位置；然后再往左取 16 位二进制 bit 位，其中每一位都代表了一个编号，比如，0 号位置的 bit 位是 (0 + 4)，也就是第 4 位，如果这一位为 1，则表示树中编号为 0 的位置上有石头，反之则没有，其它的编号依此类推。 len 表示从最原始的状态来到了当前的状态，一共走了多少步。 理解了上面的几个成员变量，就不难理解之后的几个成员函数了。\nPart3 我们再看输出运算符的重载，\n1// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的 2ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 3 if (p == NULL) 4 return os; 5 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; // 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号 6 return os; 7} 这里我们要注意，因为 Node 实际上是用来表示 State 中的 path 的，所以，并且，我们是到了最后成功到达终点时(看代码 109 行)直接打印最终的那个 State 的 path 的，而每一个 path 指向的又是上一个 State 的 path，所以，这个输出重载就达到了输出从初始的状态移动到最终目标的全部路径的目的。\nPart4 然后，我们看一下尝试移动机器人或者石头的思路，在这之前，我们先再来看一下全局变量，\n1const int MAXN = 16; // 节点的最大数量是 16，根据题目中的条件得来 2vector\u0026lt;int\u0026gt; G[MAXN]; // 图的邻接矩阵表示，题目中简化成了树(无环图) 3MemPool\u0026lt;Node\u0026gt; pool; // 链表节点分配，用 MemPool 比较好管理内存 4// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置 5// O: 每一个石头的位置编号 6// VIS: 表示某个位置是否已经 visited 过了 7int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 这个注释比较清晰了，就不多讲了。然后，让我们进入正题，来看 tryMove 这个函数，\n1// 尝试移动在点 from 上的物体(机器人或者石头) 2void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 3 int rp = s.getP(); // 获取当前状态下机器人的位置编号 4 for (auto to : G[from]) { 5 if ((to == rp) || s[to]) // to 和当前状态的机器人位置重合或者 to 的位置上有机器人 6 continue; 7 int ng = s.g; 8 if (from == rp) 9 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; // 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置 10 else 11 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); // 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置 12 if (VIS[ng]) 13 continue; // 新的状态已经访问过 14 VIS[ng] = 1; // 标记访问 15 // 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node 16 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 17 } 18} 因为 G 是邻接矩阵，我们可以利用这个特点来进行 for 循环，遍历与 from 顶点所邻接的几个顶点，尝试去移动到这些位置，然后就是一系列的细节处理，看注释比较容易理解。\nPart5 下面我们来看最终的核心的代码，\n1// bfs 2void solve() { 3 // 定义并初始化原始的状态 4 State s; 5 _for(i, 0, m) s.setRock(O[i]); 6 s.setP(S); 7 queue\u0026lt;State\u0026gt; q; 8 q.push(s); 9 VIS[s.g] = 1; // 标记当前机器人和石头的状态已经被访问过 10 // bfs 一层一层地遍历 11 while (!q.empty()) { 12 const State \u0026amp;st = q.front(); 13 int rp = st.getP(); 14 if (rp == T) { // 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数 15 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 16 return; 17 } 18 tryMove(st, rp, q); // 尝试移动机器人 19 _for(i, 0, n) if (st[i]) tryMove(st, i, q); // 尝试移动石头 20 q.pop(); 21 } 22 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; // 无法到达目的地 23} 这里就是一个纯粹的 bfs，我们定义好了原始的状态之后，然后利用队列这个数据结构一圈一圈地往外进行波纹扩散性地遍历，队列中从前往后存放的分别是第 1 圈、第 2 圈\u0026hellip;的数据，而且队列是先进先出(FIFO, First In First Out)，所以，我们可以暴力地遍历所有的情况，并且，可以保证，一旦第一次得到了想要的结果，那么，这个结果就是我们最终想要的结果。\n完整的代码和注释 以上就是关键的代码和解释了。其他的东西没什么好讲的。关于数据的输入和处理，上面也没有细讲，直接看注释即可。\n下面就是完整的代码和详细的注释：\n1#include \u0026lt;cmath\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4#include \u0026lt;queue\u0026gt; 5#include \u0026lt;vector\u0026gt; 6#include \u0026lt;fstream\u0026gt; 7 8#define _for(i, a, b) for (int i = (a); i \u0026lt; (b); ++i) 9 10using namespace std; 11 12int readint() { 13 int x; 14 cin \u0026gt;\u0026gt; x; 15 return x; 16} 17 18template \u0026lt;typename T\u0026gt; struct MemPool { 19 vector\u0026lt;T *\u0026gt; buf; 20 T *createNew() { 21 buf.push_back(new T()); 22 return buf.back(); 23 } 24 25 void dispose() { 26 for (int i = 0; i \u0026lt; buf.size(); i++) 27 delete buf[i]; 28 buf.clear(); 29 } 30}; 31 32const int MAXN = 16; // 节点的最大数量是 16 33 34struct Node { // 表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点 35 int from, to; 36 Node *next; 37}; 38 39struct State { 40 Node *path; // 路径 41 int g; // 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 \u0026lt;= n \u0026lt;= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头 42 int len; // 路径长度，到了当前状态已经经历的长度 43 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 44 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } // 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头 45 inline void setRock(size_t i, bool val = true) { // 设置位置 i 上是否有石头 46 if (val) 47 g |= 1 \u0026lt;\u0026lt; (i + 4); // 位或操作来把第(i + 4)位来置 1 48 else 49 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); // 先取反，再用与操作来把第(i + 4)位来置 0 50 } 51 // 机器人的位置操作 52 inline int getP() const { return g \u0026amp; 15; } // 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置 53 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } // 设置机器人的位置，这里先右移再左移 4 位清除原有的数据 54}; 55 56vector\u0026lt;int\u0026gt; G[MAXN]; // 图的邻接矩阵表示，题目中简化成了树(无环图) 57MemPool\u0026lt;Node\u0026gt; pool; // 链表节点分配，用 MemPool 比较好管理内存 58// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置 59// O: 每一个石头的位置编号 60// VIS: 表示某个位置是否已经 visited 过了 61int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 62Node *newNode(Node *next = NULL, int u = -1, int v = -1) { 63 Node *p = pool.createNew(); 64 p-\u0026gt;next = next, p-\u0026gt;from = u, p-\u0026gt;to = v; 65 return p; 66} 67 68// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的 69ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 70 if (p == NULL) 71 return os; 72 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; // 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号 73 return os; 74} 75 76// 尝试移动在点 from 上的物体(机器人或者石头) 77void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 78 int rp = s.getP(); // 获取当前状态下机器人的位置编号 79 for (auto to : G[from]) { 80 if ((to == rp) || s[to]) // to 和当前状态的机器人位置重合或者 to 的位置上有机器人 81 continue; 82 int ng = s.g; 83 if (from == rp) 84 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; // 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置 85 else 86 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); // 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置 87 if (VIS[ng]) 88 continue; // 新的状态已经访问过 89 VIS[ng] = 1; // 标记访问 90 // 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node 91 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 92 } 93} 94 95// bfs 96void solve() { 97 // 定义并初始化原始的状态 98 State s; 99 _for(i, 0, m) s.setRock(O[i]); 100 s.setP(S); 101 queue\u0026lt;State\u0026gt; q; 102 q.push(s); 103 VIS[s.g] = 1; // 标记当前机器人和石头的状态已经被访问过 104 // bfs 一层一层地遍历 105 while (!q.empty()) { 106 const State \u0026amp;st = q.front(); 107 int rp = st.getP(); 108 if (rp == T) { // 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数 109 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 110 return; 111 } 112 tryMove(st, rp, q); // 尝试移动机器人 113 _for(i, 0, n) if (st[i]) tryMove(st, i, q); // 尝试移动石头 114 q.pop(); 115 } 116 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; // 无法到达目的地 117} 118 119int main() { 120 // 重定向标准输入到文件 121 string relativePathToCurrentCppFile = \u0026#34;./data/UVa12569/input1.txt\u0026#34;; 122 // relativePathToCurrentCppFile = \u0026#34;./data/UVa12569/input2.txt\u0026#34;; 123 // 因为我们是在根目录下执行编译出来的可执行文件的 124 ifstream inputFile(\u0026#34;./ch07\u0026#34; + relativePathToCurrentCppFile.substr(1, relativePathToCurrentCppFile.size() - 1)); 125 if (!inputFile.is_open()) { 126 cerr \u0026lt;\u0026lt; \u0026#34;Failed to open input data file.\u0026#34; \u0026lt;\u0026lt; endl; 127 return 2; 128 } 129 streambuf *cinbuf = cin.rdbuf(); // save original buf 130 cin.rdbuf(inputFile.rdbuf()); 131 132 int K = readint(); // 读取 case 的数量，为了和 case 关键字区分，一般用 Kase 或者 K 来表示 case 133 for (int t = 1; t \u0026lt;= K; t++) { 134 memset(VIS, 0, sizeof(VIS)); // 初始化置 0 135 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; S \u0026gt;\u0026gt; T; // 读入 n m S T 136 --S; // 程序用到的编号要减 1 137 --T; // 同上 138 cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; 139 _for(i, 0, m) O[i] = readint() - 1; // 读入石头的编号，编号是从给的数据减 1 而得来 140 _for(i, 0, n) G[i].clear(); // 清除之前的数据 141 142 // 构建邻接矩阵 143 _for(i, 0, n - 1) { // 读入 n - 1 条边 144 int u = readint() - 1, v = readint() - 1; // 每一个顶点的编号都要减 1 145 G[u].push_back(v); 146 G[v].push_back(u); 147 } 148 149 solve(); 150 pool.dispose(); // 释放内存 151 cout \u0026lt;\u0026lt; endl; 152 } 153 154 // 恢复标准输入 155 cin.rdbuf(cinbuf); 156 return 0; 157} 纯净的代码 由于上面的代码我为了自己测试方便进行标准输入流重定向的处理，是不能直接提交的，所以，我在下面提供一份纯净的可以用于提交验证的代码，这里同时去除了所有的注释，因为中文字符似乎不被接受，\n1#include \u0026lt;cmath\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4#include \u0026lt;queue\u0026gt; 5#include \u0026lt;vector\u0026gt; 6 7#define _for(i, a, b) for (int i = (a); i \u0026lt; (b); ++i) 8 9using namespace std; 10 11int readint() { 12 int x; 13 cin \u0026gt;\u0026gt; x; 14 return x; 15} 16 17template \u0026lt;typename T\u0026gt; struct MemPool { 18 vector\u0026lt;T *\u0026gt; buf; 19 T *createNew() { 20 buf.push_back(new T()); 21 return buf.back(); 22 } 23 24 void dispose() { 25 for (int i = 0; i \u0026lt; buf.size(); i++) 26 delete buf[i]; 27 buf.clear(); 28 } 29}; 30 31const int MAXN = 16; 32 33struct Node { 34 int from, to; 35 Node *next; 36}; 37 38struct State { 39 Node *path; 40 int g; 41 int len; 42 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 43 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } 44 inline void setRock(size_t i, bool val = true) { 45 if (val) 46 g |= 1 \u0026lt;\u0026lt; (i + 4); 47 else 48 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); 49 } 50 51 inline int getP() const { return g \u0026amp; 15; } 52 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } 53}; 54 55vector\u0026lt;int\u0026gt; G[MAXN]; 56MemPool\u0026lt;Node\u0026gt; pool; 57 58int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 59Node *newNode(Node *next = NULL, int u = -1, int v = -1) { 60 Node *p = pool.createNew(); 61 p-\u0026gt;next = next, p-\u0026gt;from = u, p-\u0026gt;to = v; 62 return p; 63} 64 65ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 66 if (p == NULL) 67 return os; 68 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; 69 return os; 70} 71 72void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 73 int rp = s.getP(); 74 for (auto to : G[from]) { 75 if ((to == rp) || s[to]) 76 continue; 77 int ng = s.g; 78 if (from == rp) 79 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; 80 else 81 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); 82 if (VIS[ng]) 83 continue; 84 VIS[ng] = 1; 85 86 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 87 } 88} 89 90void solve() { 91 92 State s; 93 _for(i, 0, m) s.setRock(O[i]); 94 s.setP(S); 95 queue\u0026lt;State\u0026gt; q; 96 q.push(s); 97 VIS[s.g] = 1; 98 99 while (!q.empty()) { 100 const State \u0026amp;st = q.front(); 101 int rp = st.getP(); 102 if (rp == T) { 103 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 104 return; 105 } 106 tryMove(st, rp, q); 107 _for(i, 0, n) if (st[i]) tryMove(st, i, q); 108 q.pop(); 109 } 110 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; 111} 112 113int main() { 114 int K = readint(); 115 for (int t = 1; t \u0026lt;= K; t++) { 116 memset(VIS, 0, sizeof(VIS)); 117 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; S \u0026gt;\u0026gt; T; 118 --S; 119 --T; 120 cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; 121 _for(i, 0, m) O[i] = readint() - 1; 122 _for(i, 0, n) G[i].clear(); 123 124 _for(i, 0, n - 1) { 125 int u = readint() - 1, v = readint() - 1; 126 G[u].push_back(v); 127 G[v].push_back(u); 128 } 129 130 solve(); 131 pool.dispose(); 132 cout \u0026lt;\u0026lt; endl; 133 } 134 135 return 0; 136} 当然，这个代码也是可以在我的 GitHub 仓库中找到的。\n参考 1、《算法竞赛入门经典》第二版\n2、https://github.com/sukhoeing/aoapc-bac2nd-keys\n","permalink":"http://localhost:1313/posts/uva12569/","summary":"UVa12569 解题思路及代码解析","title":"UVa12569"},{"content":"这篇博客主要来聊一聊我在 Windows 端使用的终端和 Shell 软件。\n按：本篇博客大致上只是一个提纲，更详细的内容和使用体验在我的 B 站视频中，毕竟这东西不如直接用视频的形式展示出来比较直观。\n终端 Windows Terminal. Alacritty，这个之前使用过，后来放弃了。 Shell Windows 平台下也就是 pwsh7 这个软件了。其实也没什么太多好讲的，就简单介绍一下我目前使用的一些和终端相关的软件吧。\nPowerShell 7.0+ $PROFILE starship fastfetch scoop Neovim，关于 Neovim 的配置相关后面的视频中会讲，当前只是讲一下它的使用。 一些常用的命令。\n1ls 2cls 3cd 4cp 5tree 6Get-Command 如果想要一些快捷的命令的话，那么，可以去定制 pwsh 的配置文件，比如，去定制一些命令别名、函数之类。\n然后，还有一个小技巧，就是在 Neovim 中使用 pwsh，比较方便我们去复制一些内容。\n","permalink":"http://localhost:1313/posts/personal-likes-terminal-and-shell-in-windows/","summary":"\u003cp\u003e这篇博客主要来聊一聊我在 Windows 端使用的终端和 Shell 软件。\u003c/p\u003e\n\u003cp\u003e按：本篇博客大致上只是一个提纲，更详细的内容和使用体验在我的 B 站视频中，毕竟这东西不如直接用视频的形式展示出来比较直观。\u003c/p\u003e","title":"终端和 Shell 的使用之 Windows 篇"},{"content":"几个月前也简单安装过 Hyprland，在 nixos 发行版上。只是由于当时时间不够，就没有怎么深入去配置，导致最终的使用体验其实比较糟糕。所以最终是放弃了体验。\n最近时间比较多，刚好我的 KDE 出了点问题，所以，直接重装，WM(Windows Manager) 也换成了 hyprland，最终的体验还行。这里就简单分享一些我认为简易配置一下就可以获得的体验。\n提前说一下我的个人建议：好看，但不推荐。目前有太多的问题。\n按：本文更多面向的是 CS 专业在读学生，如果是非 CS 专业，但是对 CS 感兴趣、有实践的同学，那就更加 perfect 了。\n基本的使用的效果 就是一些平铺效果，这个没什么好说的。\n高分屏的适配 按照默认的配置来，其实还行。\n基本的编程软件 Kitty fish Neovim Neovide VSCode starship 这几个体验起来其实还行，只有 VSCode 需要开启 wayland 的标志，不然，缩放很有问题。\n美化和主题 暗色模式很有问题。比如，使用 dolphin，起界面调起来有一番难度。整个系统想要调整成暗色模式也很有难度。\n常用的工具 ags，标题栏和一些小组件的美化和定制。 rofi，这里我使用的 wayland 的版本，rofi-wayland，但是有一个问题：不能输入中文。 fcitx5，大部分应用是可以正常使用的。 chrome，开启了 wayland 的 flag 之后，使用起来还行。 edge，和 chrome 类似。 firefox，如果缩小到屏幕的 1/32，那么，缩放会出问题。 telegram，很不稳定。启动的时间长，缩放有一定问题，输入法偶尔失灵。 obs-studio，这个录屏的软件还是挺好用的。 很多缺失的工具 比如，截图软件，其实没有好用的。\n总结 我个人给出的结论是，不推荐使用这个系统。我们在使用一个系统的时候，其实是有很多事情要做的，因此，必须要有足够多的软件来支持，这一点 KDE 就做得非常好，而 hyprland 毕竟是一个年轻的 WM，所以，它在很多方面都有欠缺，因此，如果要作为我们的主系统的话，那么，它是很不合适的。不过，如果，仅仅是用来编写代码的副操作系统，大家大可以尝试一番，它的理念，也就是平铺式桌面的里面是相当优秀的。\n之前(大概是前天)也是因为 KDE 的 chrome 浏览器会导致 fcitx5 卡死，才一气之下换到了 hyprland，现在发现问题好像可以解决了。KDE 中的 chrome 默认使用的 x11 协议，那么，换成 wayland 其实就可以解决输入法的问题了。\n","permalink":"http://localhost:1313/posts/arch-linux-trying-hyprland/","summary":"\u003cp\u003e几个月前也简单安装过 Hyprland，在 nixos 发行版上。只是由于当时时间不够，就没有怎么深入去配置，导致最终的使用体验其实比较糟糕。所以最终是放弃了体验。\u003c/p\u003e","title":"Arch Linux Trying Hyprland"},{"content":"如何给 Kitty 设置主题呢？这个问题其实很简单，因为像这样成熟的 terminal 模拟器，必然有人在网上已经整理好了相关的 themes，通常只需要我们去 clone 一下就可以使用了。Kitty 就是如此。\n","permalink":"http://localhost:1313/posts/how-to-set-themes-for-kitty/","summary":"\u003cp\u003e如何给 Kitty 设置主题呢？这个问题其实很简单，因为像这样成熟的 terminal 模拟器，必然有人在网上已经整理好了相关的 themes，通常只需要我们去 clone 一下就可以使用了。Kitty 就是如此。\u003c/p\u003e","title":"How to Set Themes for Kitty"},{"content":"追根溯源，也就是速度、易用性和便携性。\n以前我是使用 Hexo 来建站的，而且，放到 Github 上面的是 hexo 最终渲染好的 html 文件之类，我现在发现这样特别笨重，尤其是在有多台 pc 的情况下，如果想要在不同的设备和操作系统之间进行写作，那么，这无疑是一件困难的事情。而且，每一次渲染造成的文件改动是很多的，这个在一定程度上是不利于版本管理的。而 Hugo 就很好地做到了这一点，利用 Github Actions 实现了文章与最终构建出来的产物进行分离，这样一来，我只需要把 markdown 文件托管到 Github 上面就可以了。对于 Hexo，我觉得应该也是可以做到这一点的，之所以没有去尝试，一方面懒了，另一方面，人总是想要尝试一点新鲜的东西，所以，这就转到了 Hugo。\n我之前其实建立过好多个基于 Github Pages 网站，其中，写得最多的，是这个站点，也是因为写得文章实在是有点多了，所以，hexo 在速度这一块的弊病就显现出来了，毕竟是基于 nodejs 的嘛。此外，我在之前的博客中使用的图床是 imgur，评论使用的是 disqus，这俩可谓是反面意义的卧龙凤雏了，速度都奇慢无比。有时候，imgur 的图片甚至加载不出来，应该是全球的服务器不够用。在速度这个层面上，postimage 和 Github Discussion 就要好很多，非常多。基本上只要搭了个梯子，那么，速度是没问题的。Hugo 本身由于 go 语言本身的性能，速度是相当快的，而且，在 Windows 上的表现比 Linux 中的表现差不了多少。目测 500 篇文章的生成速度应该可以保持在 5s 以内。\n","permalink":"http://localhost:1313/posts/why-i-build-another-github-pages-website/","summary":"\u003cp\u003e追根溯源，也就是速度、易用性和便携性。\u003c/p\u003e\n\u003cp\u003e以前我是使用 Hexo 来建站的，而且，放到 Github 上面的是 hexo 最终渲染好的 html 文件之类，我现在发现这样特别笨重，尤其是在有多台 pc 的情况下，如果想要在不同的设备和操作系统之间进行写作，那么，这无疑是一件困难的事情。而且，每一次渲染造成的文件改动是很多的，这个在一定程度上是不利于版本管理的。而 Hugo 就很好地做到了这一点，利用 Github Actions 实现了文章与最终构建出来的产物进行分离，这样一来，我只需要把 markdown 文件托管到 Github 上面就可以了。对于 Hexo，我觉得应该也是可以做到这一点的，之所以没有去尝试，一方面懒了，另一方面，人总是想要尝试一点新鲜的东西，所以，这就转到了 Hugo。\u003c/p\u003e","title":"谈一谈我为什么重新建立了一个 Github Pages 个人网站"},{"content":"title: \u0026ldquo;归档\u0026rdquo; date : 2025-09-12T03:25:53+08:00 categories : [\u0026ldquo;电机驱动\u0026rdquo;] tags : [\u0026ldquo;用户指南\u0026rdquo;] 说明书\n行内数学公式：$a^2 + b^2 = c^2$。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n$$ \\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} $$ 1scoop install hugo-extended ","permalink":"http://localhost:1313/posts/build-a-blog-using-hugo-papermod-github-pages/","summary":"\u003ch2 id=\"tags--用户指南\"\u003etitle: \u0026ldquo;归档\u0026rdquo;\ndate : 2025-09-12T03:25:53+08:00\ncategories : [\u0026ldquo;电机驱动\u0026rdquo;]\ntags : [\u0026ldquo;用户指南\u0026rdquo;]\u003c/h2\u003e\n\u003cp\u003e说明书\u003c/p\u003e\n\u003cp\u003e行内数学公式：$a^2 + b^2 = c^2$。\u003c/p\u003e","title":""},{"content":"\n正在尝试一种自由的生活。\n自由的生活，也是独居的生活。幽居于楚地的一隅。\n困的时候睡，睡够了然后醒。饿了的时候做饭、吃饭。不饿的时候看书、听歌、写一点无聊的东西。身体康健的时候锻炼，微恙的时候蛰伏。\n过往的生活大致说得过去。没有心理问题，没有身体问题，没有原生家庭问题等等。读过一个还算不错的大学，在一个还算不错的公司短暂地上过班。\n最后，我有一个朋友。\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"},{"content":"题意 https://onlinejudge.org/external/3/340.pdf https://onlinejudge.org/external/4/401.pdf 理解分析 这两道题比较直接，都是用字符数组来进行解决。\n","permalink":"http://localhost:1313/posts/uva401-and-uva340/","summary":"\u003ch2 id=\"题意\"\u003e题意\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/3/340.pdf\"\u003ehttps://onlinejudge.org/external/3/340.pdf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/4/401.pdf\"\u003ehttps://onlinejudge.org/external/4/401.pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"理解分析\"\u003e理解分析\u003c/h2\u003e\n\u003cp\u003e这两道题比较直接，都是用字符数组来进行解决。\u003c/p\u003e","title":"UVa401 and UVa340"},{"content":"配套的书是这本：\u0026lt;\n如何看自己当前的 Kotlin 的版本？\n在 build.gradle.kts 中，\n1// Top-level build file where you can add configuration options common to all sub-projects/modules. 2plugins { 3 alias(libs.plugins.android.application) apply false 4 alias(libs.plugins.kotlin.android) apply false 5 alias(libs.plugins.kotlin.compose) apply false 6} 我们点进第二行的版本中去查看即可。现在 Kotlin 的版本为 2.0.0.\n如何看 Jetpack Compose 的版本？\nhttps://developer.android.com/develop/ui/compose/compiler\n也是类似的道理，现在 Jetpack Compose 的版本为 2.0.0.\n书上是建议我们使用 Jetpack Compose v1.2.1，这里我们不听他的，我们直接用最新版，遇到不兼容的地方，就直接去解决就行。\n我们这里可以先把代码 clone 一份下来备用，\n1git clone https://github.com/kodecocodes/jet-materials.git 如何阅读这本书？\n直接从开头然后按照顺序读下去即可。\n开发环境的搭建。\n安装 Android Studio 即可。\n对于测试的设备，直接使用手头的安卓手机。\n","permalink":"http://localhost:1313/posts/jetpack-compose-by-tutorials-2nd-cn-version/before-you-begin/","summary":"\u003cp\u003e配套的书是这本：\u0026lt;\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如何看自己当前的 Kotlin 的版本？\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e在 build.gradle.kts 中，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e3\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eandroid\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eapplication\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e4\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekotlin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eandroid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ealias\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elibs\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eplugins\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekotlin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecompose\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eapply\u003c/span\u003e \u003cspan class=\"k\"\u003efalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e我们点进第二行的版本中去查看即可。现在 Kotlin 的版本为 2.0.0.\u003c/p\u003e","title":"在你开始之前"},{"content":"很多朋友在使用 Hyprland/Wayland 的时候，可能会遇到这样一个问题，那就是 Chrome、VSCode 和 Obsidian 这类基于 chromium 的软件的界面字体和 UI 比较模糊，不够 sharp 和清晰。那么，我这里简要介绍我常用的两种方法。\n一种是像 VSCode/Chrome 这种可以直接加 flags 的，那么，我们直接在在配置目录中新建一个 code-flags.conf 然后加上一些启动参数即可，\n1--ozone-platform-hint=wayland 2--enable-wayland-ime 对于 Chrome，我们则需要写一个 chrome-flags.conf，\n1--enable-features=UseOzonePlatform 2--ozone-platform=wayland 3--enable-wayland-ime 然后是一些我们不知道其 flags 文件怎么命名的软件，比如，Obsidian 和 Jetbrains 家的软件，那么，我们可以直接自制一份我们自己的 desktop file 来覆盖系统默认的，这里拿 Obsidian 举例，我们去 /usr/share/applications 下去复制一份 obsidian.desktop 文件到 ~/.local/share/applications/ 下面，然后在 Exec 那一行加一些启动参数即可，\n1Exec=/usr/bin/obsidian %U --enable-features=UseOzonePlatform --ozone-platform=wayland --enable-wayland-ime Jetbrains 家的软件也是一样，加一下它们提供的 wayland 相关的参数即可，\n1Exec=intellij-idea-ultimate-edition %u -Dawt.toolkit.name=WLToolkit ","permalink":"http://localhost:1313/posts/resolve-wayland-or-hyprland-chrome-and-jetrains-scale-issue/","summary":"\u003cp\u003e很多朋友在使用 Hyprland/Wayland 的时候，可能会遇到这样一个问题，那就是 Chrome、VSCode 和 Obsidian 这类基于 chromium 的软件的界面字体和 UI 比较模糊，不够 sharp 和清晰。那么，我这里简要介绍我常用的两种方法。\u003c/p\u003e","title":"解决 Hyprland/Wayland 下 Chrome/Chromium 系列软件和 Jetbrains 系列软件的缩放和输入法使用的问题"},{"content":"题意理解 https://onlinejudge.org/external/10/1025.pdf\n这里要我们求的输出是：最少等待时间。什么是最少等待时间呢？就是在车站逗留的时间。\n解题思路 用 $d(i, j)$ 表示时刻 i，Mario 在车站 j 最少还需要等待多少时间。 边界条件是：$d(T, n) = 0$，表示在 T 时刻，Mario 已经在 n 站台了。其他的 d(T, i) 为正无穷。 对于其他的普通的情况，也就是 d(i, j)，可以有 3 种决策： 1、等 1 个时间单位 2、搭乘往右开的车(如果有) 3、搭乘往左开的车(如果有) 代码理解 这里状态转移方程比较直观，其实就是最内层的 for 循环中的处理过程。因为我们的边界条件是 T 时刻，所以，对于时刻 i，我们从 T - 1 开始遍历。\n这里一定要明确，$dp[i, j]$ 表示的是时刻 i，在车站 j 最少还需要等待多少时间。\n1dp[i][j] = dp[i+1][j] + 1; // 等待一个时间单位 表示，从 dp[i][j] 状态来到 dp[i+1][j]，是在 j 站台等待了一个时间单位。并且，最终来到了 i + 1 时刻。\n1dp[i][j] = min(dp[i][j], dp[i+t[j]][j+1]); // 右 表示，从 dp[i][j] 状态来到 dp[i+t[j]][j+1] 状态，是在往右的列车上花费了 t[j] 个时间单位，并且，最终来到了 i + t[j] 时刻和 j + 1 站台。这个过程中，没有等待。\n1dp[i][j] = min(dp[i][j], dp[i+t[j-1]][j-1]); // 左 表示，从 dp[i][j] 状态来到 dp[i+t[j-1]][j-1] 状态，是在往左的列车上花费了 t[j-1] 个时间单位(因为题意说，两个站台之间列车往左往右花费的时间是一样的)，并且，最终来到了 i + t[j - 1] 时刻和 j - 1 站台。这个过程中，也没有等待。\n注意：这里为什么一次只让列车走一个站台呢？是因为一次走多个站台的情况也被我们这种挨个处理的方式给囊括了，便于我们去处理所有的情况。比如，我想坐列车一次往右走两个站台，那么，其实在我走完一个站台的时候，会有三种决策，那么，其中，直接向右走的决策就和一次走两个站台的那种情况是相等了。\n","permalink":"http://localhost:1313/posts/uva1025/","summary":"\u003ch2 id=\"题意理解\"\u003e题意理解\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://onlinejudge.org/external/10/1025.pdf\"\u003ehttps://onlinejudge.org/external/10/1025.pdf\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这里要我们求的输出是：最少等待时间。什么是最少等待时间呢？就是在车站逗留的时间。\u003c/p\u003e\n\u003ch2 id=\"解题思路\"\u003e解题思路\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e用 $d(i, j)$ 表示时刻 i，Mario 在车站 j 最少还需要等待多少时间。\u003c/li\u003e\n\u003cli\u003e边界条件是：$d(T, n) = 0$，表示在 T 时刻，Mario 已经在 n 站台了。其他的 d(T, i) 为正无穷。\u003c/li\u003e\n\u003cli\u003e对于其他的普通的情况，也就是 d(i, j)，可以有 3 种决策：\n\u003cul\u003e\n\u003cli\u003e1、等 1 个时间单位\u003c/li\u003e\n\u003cli\u003e2、搭乘往右开的车(如果有)\u003c/li\u003e\n\u003cli\u003e3、搭乘往左开的车(如果有)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"代码理解\"\u003e代码理解\u003c/h2\u003e\n\u003cp\u003e这里状态转移方程比较直观，其实就是最内层的 for 循环中的处理过程。因为我们的边界条件是 T 时刻，所以，对于时刻 i，我们从 T - 1 开始遍历。\u003c/p\u003e","title":"UVa1025"},{"content":"这两道题是整本书中出现的第一道和第二道 UVa 的题目。\nhttps://onlinejudge.org/external/2/272.pdf https://onlinejudge.org/external/100/10082.pdf 先看 UVa272，这里需要注意两点，\ngetchar =\u0026gt; 这里之所以使用 getchar，是因为如果使用 scanf 来读取输入的话，那么，像 TAB、空格这样的字符就会被当成分隔符而无法读入； EOF 是什么？EOF 表示一个文件的结束，如果是读取一个文件，那么，读取到文件尾时，就会读取到 EOF。更详细的内容可以看：https://stackoverflow.com/questions/4358728/end-of-file-eof-in-c。我们在使用命令行的时候，可以使用 Ctrl + D(在 Linux 系统下) 来手动触发 EOF。 额外说一句，第 46 页，\n如果用“scanf(\u0026quot;%d\u0026quot;, \u0026amp;n)”读取整数 n，则要是在输入 123 后多加了一个空格，用 getchar 读取的将是这个空格，\n这里的意思是先调用 scanf，然后调用 getchar，并不是上来就只调用 getchar。\n再看 UVa10082，思路也是一样，毕竟是开篇的题目，所以比较简单。\n好，那么这两道题所用到的知识点就是这个 getchar 了。\n然后，下面是代码时间，写代码的时候，注意一下题目的输入数据的格式即可。\n","permalink":"http://localhost:1313/posts/uva272-and-uva10082/","summary":"\u003cp\u003e这两道题是整本书中出现的第一道和第二道 UVa 的题目。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/2/272.pdf\"\u003ehttps://onlinejudge.org/external/2/272.pdf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://onlinejudge.org/external/100/10082.pdf\"\u003ehttps://onlinejudge.org/external/100/10082.pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e先看 UVa272，这里需要注意两点，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egetchar =\u0026gt; 这里之所以使用 getchar，是因为如果使用 scanf 来读取输入的话，那么，像 TAB、空格这样的字符就会被当成分隔符而无法读入；\u003c/li\u003e\n\u003cli\u003eEOF 是什么？EOF 表示一个文件的结束，如果是读取一个文件，那么，读取到文件尾时，就会读取到 EOF。更详细的内容可以看：\u003ca href=\"https://stackoverflow.com/questions/4358728/end-of-file-eof-in-c\"\u003ehttps://stackoverflow.com/questions/4358728/end-of-file-eof-in-c\u003c/a\u003e。我们在使用命令行的时候，可以使用 Ctrl + D(在 Linux 系统下) 来手动触发 EOF。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e额外说一句，第 46 页，\u003c/p\u003e","title":"UVa272 and UVa10082"},{"content":"这里以 Windows11 为例。\n这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\n这个可以写的东西不多，就直接看视频吧。\n插件：\nC/C++ CMake Tools CMake(LSP) 首先，我们先手动地配置一个 C/C++ 项目。\n全手动。即，从命令行编译一个 C++ 文件。\n然后，如果你想省事儿，那么，可以试一下我的模板，\nhttps://github.com/fanlumaster/LinuxCppTemplate\n不过呢，我建议每个人还是自己给自己建立一个模板，这样用起来才放心、熟悉。\n最后，如果大家想更多从实际上手的角度来理解 CMake 的使用，我斗胆推荐一下这本 Modern CMake for C++，刚好前段时间刚出了第二版，很新。如果仅仅是想入个门，那么，读一下第一章也可以有不少收获。\n关于 debug 的配置，可以参考 cmake 插件给出的配置，\nhttps://github.com/microsoft/vscode-cmake-tools/blob/main/docs/debug-launch.md\n因为是在 Windows 平台，所以，就使用 msvc 比较好。\n","permalink":"http://localhost:1313/posts/configure-vscode-cmake-c-cpp-windows/","summary":"\u003cp\u003e这里以 Windows11 为例。\u003c/p\u003e\n\u003cp\u003e这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\u003c/p\u003e\n\u003cp\u003e这个可以写的东西不多，就直接看视频吧。\u003c/p\u003e\n\u003cp\u003e插件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC/C++\u003c/li\u003e\n\u003cli\u003eCMake Tools\u003c/li\u003e\n\u003cli\u003eCMake(LSP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先，我们先手动地配置一个 C/C++ 项目。\u003c/p\u003e","title":"Windows 配置 VSCode + CMake + C/C++ 开发环境"},{"content":"这里以 Arch Linux 为例。\n这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\n这个可以写的东西不多，就直接看视频吧。\n插件：\nC/C++ CMake Tools CMake(LSP) 首先，我们先手动地配置一个 C/C++ 项目。\n全手动。即，从命令行编译一个 C++ 文件。\n然后，如果你想省事儿，那么，可以试一下我的模板，\nhttps://github.com/fanlumaster/LinuxCppTemplate\n不过呢，我建议每个人还是自己给自己建立一个模板，这样用起来才放心、熟悉。\n最后，如果大家想更多从实际上手的角度来理解 CMake 的使用，我斗胆推荐一下这本 Modern CMake for C++，刚好前段时间刚出了第二版，很新。如果仅仅是想入个门，那么，读一下第一章也可以有不少收获。\n下下期视频(大概率)，我将带大家看一个真实的世界中使用 VSCode + C/C++ 插件 + CMake 插件大型项目：Hyprland。\n","permalink":"http://localhost:1313/posts/configure-vscode-cmake-c-cpp-linux/","summary":"\u003cp\u003e这里以 Arch Linux 为例。\u003c/p\u003e\n\u003cp\u003e这里只介绍比较通用的搭配：VSCode + 微软的 C/C++ 插件 + CMake 插件。虽然我平时更多用 clangd 和 Neovim。\u003c/p\u003e\n\u003cp\u003e这个可以写的东西不多，就直接看视频吧。\u003c/p\u003e\n\u003cp\u003e插件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eC/C++\u003c/li\u003e\n\u003cli\u003eCMake Tools\u003c/li\u003e\n\u003cli\u003eCMake(LSP)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先，我们先手动地配置一个 C/C++ 项目。\u003c/p\u003e","title":"Linux 配置 VSCode + CMake + C/C++ 开发环境"},{"content":"或许也可以让 chatgpt 的访问更加丝滑。\n起因是在看 react 的官方教程时，发现有一张图片无法访问，对，就是下面这张，\n其实我最近两年的 imgur 的访问一直比较有问题，有时候需要换很多个节点才能尝试出来一个可以正常加载 imgur 图片的 ip，而有时候甚至会全军覆没。\n今天实在忍不了了，所以，就在网上找了一下有没有好的方法可以实现 imgur 的图片的正常访问，因为这个图床(图片托管网站)用到的地方挺多的，比如，像上面的 reactjs 的官网都会用到，还有 v 站也是默认会渲染 imgur 的图片，我自己的博客之前也是用 imgur 比较多，现在则换成了访问更加顺畅的 postimage，不过，我还有很多图片没有迁移过去，所以，解决 imgur 这个图床的问题迫在眉睫。找了一圈，发现还是用 warp 套一层比较合适。\n那么，具体是怎么操作呢？\n经过我的尝试，发现使用第三方开源的 cli 而非是 cloudflare 的官方 cli 在 Arch 上的体验是更加丝滑的，具体可以参考 Reddit 的这个帖子，\nhttps://www.reddit.com/r/CloudFlare/comments/q0hqj4/warpcli_is_not_working/\n具体来讲，就是先安装几个依赖，\n1yay -S cloudflare-warp-bin wireguard-dkms openresolv wireguard-tools wgcf 这里在安装完毕之后，不要忘记 reboot 一下。\n然后，来到一个临时的目录，依次执行，\n1wgcf register 2wgcf generate 3cp ./wgcf-profile.conf /etc/wireguard/ 然后，\n1wg-quick up wgcf-profile 然后，就可以查看一下 warp 的状态了，\n1curl https://www.cloudflare.com/cdn-cgi/trace/ 我这里的输出为，\n1fl=412f42 2h=www.cloudflare.com 3ip=2a09:bac5:55fd:1028::19c:2a 4ts=1729814011.542 5visit_scheme=https 6uag=curl/8.10.1 7colo=SIN 8sliver=none 9http=http/2 10loc=SG 11tls=TLSv1.3 12sni=plaintext 13warp=on 14gateway=off 15rbi=off 16kex=X25519 可以看到，warp 已经 on 的状态了。\n如果想要关闭，那么，这个时候，就可以 down 一下，\n1wg-quick down wgcf-profile 这样一来，imgur 对 ip 的限制就被我们绕过去了。\n比如，我以前很多博客的封面都是存在在 imgur 的，那么，我们可以看一下，访问的效果如何，\nhttps://fanlumaster.github.io/page/4/#board\n","permalink":"http://localhost:1313/posts/using-warp-to-unlock-imgur/","summary":"\u003cp\u003e或许也可以让 chatgpt 的访问更加丝滑。\u003c/p\u003e\n\u003cp\u003e起因是在看 react 的官方教程时，发现有一张图片无法访问，对，就是下面这张，\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.imgur.com/yXOvdOSs.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e其实我最近两年的 imgur 的访问一直比较有问题，有时候需要换很多个节点才能尝试出来一个可以正常加载 imgur 图片的 ip，而有时候甚至会全军覆没。\u003c/p\u003e","title":"使用 warp 来解除 imgur 的访问限制"},{"content":"","permalink":"http://localhost:1313/posts/my-experience-about-neovim-in-daily-dev-life/","summary":"","title":"My Experience About Neovim in Daily Dev Life"},{"content":"有网友问我关于我发布的算法竞赛入门经典(紫书)的更新计划，这里就简要说一下，顺便也可以作为这个系列的开篇/前言了。\n本来我的计划是，有时间就更，偶尔更，随机更。看到了感兴趣的题目或者随机抽一个就更一下。\n既然有人愿意看，那么，我就让这个系列稍微有秩序一些。所以，之后的更新计划是什么呢？那就是：如果是不忙的时候，我尽量两天更新一道题目。\n更新的计划 会讲哪些题目 对于没有和 UVa 绑定的例题，我应该不会讲解，因为那些题目是比较简单的、为了辅助读者理解概念的，读者看一遍就可以理解。\n但凡是可以提交到 OJ 的题目，在这本书里面，就都是 UVa 的题目了，那么，对于这些题目，我会一题不落的进行讲解，如果你发现有缺漏，那一定是时间的问题，我还没有更新到那里。\n更新的顺序是怎样的 对于更新的顺序问题，我会分成两条线，一条线是从第一章开始，按照顺序更，另一条线是在书中随机挑选题目进行更新。\n这两条线是同步进行的。\n初衷是什么 书的阅读说明里有这样一句话：\n本书最好是有人带着学习。\n确实，中学有很多的竞赛培训班，不过，但是，我认为他们的习惯他们的道德不符合我当初作为初学者时所期待的前辈的印象(包括很多大家可能认为比较权威的人士)，不管是所用工具，所传播出来的理念，动不动就加什么 QQ 群，收什么费之类，令人讨厌，徒增门槛，使人心生退意。一言以蔽之，乌烟瘴气，一群老登。\n而且，我认为，好的视频资源为什么只能存在于国外的平台？这好吗？这不好。\n所以，我就尽量在自己得空的时候，为一些真正对算法竞赛入门感兴趣的初学者提供一份还算能看的材料。就这么简单。\n是用爱发电吗 大概可以这么理解。首先视频绝无收费的可能。当然，如果你愿意花几块钱给我充个电，相当于是请我喝一杯奶茶了(奶茶我最喜欢喝蜜雪冰城)，那我也会很开心的。\n我是绝对没有依靠视频去获取多少收益的意思，如果大家愿意支持我，那么，后面大家愿意购买我开发的付费软件，那就可以算是最好的支持了。\n使用的工具 操作系统，\nWin11 Arch Linux (KDE 或者 hyprland) 当然，也不排除后续使用其他发行版的可能性。\n编程工具，\nNeovim VSCode gcc g++ clang++ MSVC 要讲的大概就这么多。如果大家还有什么想问的，评论区你问我答。\n","permalink":"http://localhost:1313/posts/my-updating-plan-about-aoapc2nd/","summary":"\u003cp\u003e有网友问我关于我发布的算法竞赛入门经典(紫书)的更新计划，这里就简要说一下，顺便也可以作为这个系列的开篇/前言了。\u003c/p\u003e\n\u003cp\u003e本来我的计划是，有时间就更，偶尔更，随机更。看到了感兴趣的题目或者随机抽一个就更一下。\u003c/p\u003e","title":"序言-更新计划-初衷-关于算法竞赛入门经典第二版"},{"content":"我现在如何给初中的少年作数学辅导工作。以一道具体的数学题举例。\n$x$、$y$、$z$ 都是有理数。求\n$$ |x| + |x - y| + |y - z| + |10 - z| $$\n的最小值，并说明什么时候取得最小值。\n一般来说，刚上初一的时候，做这道题目还是需要思索几分钟的，猜大家肯定几秒钟就都可以猜出来，10 嘛。但人一旦有过编程的经验，就不想自己去猜了，而是让机器去猜，那么，我们就写一点 Python 来猜一下，\n1min = float(\u0026#39;inf\u0026#39;) 2for x in range(-100, 100): 3 for y in range(-100, 100): 4 for z in range(-100, 100): 5 cur_min = abs(x) + abs(x - y) + abs(y - z) + abs(10 - z) 6 if cur_min \u0026lt; min: 7 min = cur_min 8print(min) $$ |x| + (|y - x| + |y - z|) + |10 - z| $$\n进一步，\n$$ |x| + |x - z| + |10 - z| $$\n再进一步，\n$$\n$$ $$ |x| + (|z - x| + |z - 10|) $$ 再进一步，\n$$ |x - 0| + |x - 10| $$\n显然，最小值就是 10。\n","permalink":"http://localhost:1313/posts/one-interesting-junior-high-school-math-problem/","summary":"\u003cp\u003e我现在如何给初中的少年作数学辅导工作。以一道具体的数学题举例。\u003c/p\u003e\n\u003cp\u003e$x$、$y$、$z$ 都是有理数。求\u003c/p\u003e\n\u003cp\u003e$$\n|x| + |x - y| + |y - z| + |10 - z|\n$$\u003c/p\u003e\n\u003cp\u003e的最小值，并说明什么时候取得最小值。\u003c/p\u003e","title":"一道有意思的初中数学题"},{"content":"按规矩，先上链接：https://github.com/fanlumaster/fcitx5-FanIME。\n这里我们可以简单看一下代码，因为有了 fcitx5 这个框架，所以实现起来就更加轻松了。我们只需要关注核心的逻辑。\n下面就是基本的功能的介绍啦。\n小鹤双拼 这是最基本的功能，即一个标准的小鹤双拼。\n关于辅助码，这里采用的方案基本是蓝天小雨点的方案。\n单码辅助 对于所有的词条，默认都支持首字单码辅助。\n对于两字词语，同时支持第二个字的单码辅助。比如：红杉，红衫。双码。混输。\n双码辅助 对于单字和双字，按下 Tab 进行翻页时，可以使用双码进行辅助。比如，对弈的弈。双码。尤其是打单字的时候，对于输入人名的时候，非常方便。\n造词时的辅助码 造词时也同时支持单码辅助和双码辅助。\n速度 绝大多数场景的候选词条生成速度在 1ms 以内。同时，最坏情况应该也不会超过 2ms，因为我目前的测试中还未出现这样的数据。\n词库 采用了两个比较经典的开源词库进行整合。目前大概有 170 万个不重复的词条。\nhttps://github.com/iDvel/rime-ice https://github.com/wuhgit/CustomPinyinDictionary 开源 没错，输入法这个东西，你不开源，你还想怎样？窃取用户的隐私吗？\n因为代码公开，所以，基于原始版本，你想怎么定制就怎么定制，至于隐私的问题，早就已经在九霄云外了，完全不用考虑。\nTODO 1、动态调频。这个完全是因为我懒，加上目前在使用辅助码的情况下，还没遇到需要翻页的情况，就暂时搁置了。\n2、之前基于 HMM 做了一个长句联想，但是效果不达标，这个需要后续迭代。不过，也不急，因为目前的功能其实完全够用了。\n3、基于 SLM 制作长句联想。\n4、中英混输。\n5、云输入。这个优先级最低。也还是因为目前已经可以使用得很舒适了。\n","permalink":"http://localhost:1313/posts/a-first-glimpse-on-my-own-ime-fcitx5-fanime/","summary":"\u003cp\u003e按规矩，先上链接：\u003ca href=\"https://github.com/fanlumaster/fcitx5-FanIME\"\u003ehttps://github.com/fanlumaster/fcitx5-FanIME\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e这里我们可以简单看一下代码，因为有了 fcitx5 这个框架，所以实现起来就更加轻松了。我们只需要关注核心的逻辑。\u003c/p\u003e\n\u003cp\u003e下面就是基本的功能的介绍啦。\u003c/p\u003e","title":"真·自制输入法·打你所想"},{"content":"一道经典的算法题。链接：https://onlinejudge.org/external/5/524.pdf。\n这里的原题的描述，我们需要注意的只有输入和输出的格式那里，对于题意的理解，书中的中文描述已经足够了，因为题意是比较简单的。(这里可以去书上读一下题目的意思。)\n首先，素数的定义：wiki。\n大于 1 的自然数中，除了 1 和该数自身外，无法被其他自然数整除的数。(2 当然是素数。)\n关于输出中的数字排列的顺序，书上说是逆时针排列，而原题中说的是顺时针和逆时针，这个其实无所谓，我们依次 dfs 过去，最终会把顺时针和逆时针的情况全部囊括的。\n然后，书上首先介绍了一个“生成-测试”法，这个比较容易，这里就不去详细说明，我们就简单看下用到的 next_permutation 这个函数，可以看一下文档。\n核心的部分是这个 dfs，\n1/* 2 从 1 开始，依次去搜索每个位置上的可能性 3 4 cur: 当前的位置 5*/ 6void dfs(int cur) { 7 if (cur == n \u0026amp;\u0026amp; isp[A[0] + A[n - 1]]) { // 递归边界 8 for (int i = 0; i \u0026lt; n; i++) { 9 if (i != 0) 10 printf(\u0026#34; \u0026#34;); 11 printf(\u0026#34;%d\u0026#34;, A[i]); 12 } 13 printf(\u0026#34;\\n\u0026#34;); 14 } else 15 for (int i = 2; i \u0026lt;= n; i++) 16 if (!vis[i] \u0026amp;\u0026amp; isp[i + A[cur - 1]]) { // 判断当前的数字是否可行，不行的就跳过，相当于是剪枝了 17 A[cur] = i; 18 vis[i] = 1; // 标记已经访问过 19 dfs(cur + 1); // 递归处理下一个位置 20 vis[i] = 0; // 还原 21 } 22} 我们直接看所有的代码，一次性整体进行讲解。\n","permalink":"http://localhost:1313/posts/uva524/","summary":"\u003cp\u003e一道经典的算法题。链接：\u003ca href=\"https://onlinejudge.org/external/5/524.pdf\"\u003ehttps://onlinejudge.org/external/5/524.pdf\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e这里的原题的描述，我们需要注意的只有输入和输出的格式那里，对于题意的理解，书中的中文描述已经足够了，因为题意是比较简单的。(这里可以去书上读一下题目的意思。)\u003c/p\u003e","title":"UVa524"},{"content":"首先，我看了所有的问题，基本上这些问题都是可以在问答平台上找到答案的，多检索、浏览，多看一些，肯定效果会不错的。我这里只能提供一些大而化之的回复，望理解。\n然后是，可以浏览的一些网站有：stackoverflow, reddit, 知乎, v2ex, 推特也可以多逛逛，然后就是，一般来说，现在你稍微有点追求的相关从业人员，至少也应该有一个 GitHub 和独立博客，通过这些独立博客，我相信应该能够挖掘到更加真实的信息，而且，遇到了一个你感兴趣的 GitHub 上面的项目，我想，大概率你也能够发现他的博客，那么，从别人的记录中，至少可以了解到一些过往的人家走过的路的经验。\n如果往硬件方向靠，只学c++这一门语言可以吗，c还没有学过，有必要先去补一下吗？ 按照我的经验，c 是有必要去补一下的，而且，因为 c 的语法知识其实不多，应该花费时间不是很多。\n有哪些学习步骤是学软件学硬件都要走的 这个我只了解软件，学习步骤的话，尽量多看，多学，多写，只有实际动手写起来，写一点自己感兴趣的东西，才可能知道自己该去学习什么东西。\n有什么好的方式去学习知识 Study in public. 多找一些优质的学习资源，远离营销号、远离吊儿郎当、胡吹海侃的内容。\n最近了解到acm，现在这个时间节点去弄acm对于我来说价值大嘛 可以先翻一下刘汝佳的《算法竞赛入门经典》(第二版)，如果你能在一个月内理解完书中所有的例题，那么，任何时候去搞 acm 都不晚。\n现在硬件方向待遇真的很好吗 大一点的公司的待遇其实都是差不多的，比如华为、tp，当然，更高的有大疆。大公司都是看职级来划分工资的，本科毕业的待遇平均 20k 起步(以华科为例)。\n想实习就业的话，四大件需要都学吗，还是重点放在项目上 都需要学，学习和项目不冲突，可以同步开展。还是那句话，只有真正做了，才能对知识点理解得更加深刻。否则只能停留在皮毛与侃大山。\n四大件怎么学习？我看别人都推荐国外的公开课（sc61abc这些）但是我感觉我边看字幕边学，速度太慢了[笑哭]，不知道能不能听国内的对应的课（请问up有推荐的吗） 我也没有很好的建议，大概就是把对应的经典的英文教材的英文版和中文版同时翻开，以中文版为主，遇到不清晰的翻原文，尽量理解书中出现的所有的代码和示例。这样大概比看视频快一点。公开课的话，可以作为补充，一般来讲，其实可以跟着学校的课过一遍，重点在于多问老师问题，即使学校的课可能讲得不好，但是和老师交流的收获会不少。\n学习顺序怎么安排，一门语言和对应框架＋四大件，该怎么分配学习顺序（好像四大件重点学哪些还要看想做什么岗位） 先基础，后上层，然后可以交替理解，反复琢磨，顺序什么的，看个人，有些人喜欢先有个概览性的概念，有些人则喜欢上来就扣细节。我个人认为细节是要注意的，但是不一定非要现在解决。\n对于小白，算法入门应该如何学习（学了一个内容就去刷对应的题目吗），顺便问一下有没有推荐的up主，灵神的看不太懂[笑哭] 算法入门的书，可以看 labuladong 的公开的免费的材料，虽然很多人诟病他抄袭国内外优秀题解，但是，他抄的那些确实是好东西，比较通俗。up 主的话，我个人其实讲得不好，当然，也没遇到过讲得比较好的，包括各种各样的大大小小的 up。关键还是在于多看，多想，前提多看看题解没什么坏处，就当是例题用来刷经验了。\n此外，建议把《算法竞赛入门经典》的所有例题当成例题给吃透了，代码也一行不能放过。\n编程语言选择建议C++吗，好像双非本学C++不好找工作的[笑哭] 我自己其实业余也写一点 C++，也很喜欢 Python，但是我找工作使用的是 Java。目前 Java 的后端岗位其实相比其他要多。至于专门的 C++，很多公司其实都是可以进去之后转语言的，你把一门语言吃透，然后做几个项目，经验度够了之后，其实看待问题的想法就会不一样。\n可以聊聊申请美国申请的事吗, 想了解[给心心] 这个可以多看看小红书上的帖子和一亩三分地上面的导师发布的招募帖，基本这两个地方的信息比较多。美国申请，其实不追求 QS 排名的话，老师应该都是比较包容的。现在需要注意的点可能是签证的问题，这个多上小红书看看经验。我因为拒签了一次就摆了，所以，提供不了太多的建议了。\n","permalink":"http://localhost:1313/posts/simple-replies-to-some-friends-questions-about-cs/","summary":"\u003cp\u003e首先，我看了所有的问题，基本上这些问题都是可以在问答平台上找到答案的，多检索、浏览，多看一些，肯定效果会不错的。我这里只能提供一些大而化之的回复，望理解。\u003c/p\u003e","title":"简要回复网友的关于计算机方面的问题"},{"content":"本题较为简单。本来是想讲另外一道题目的(UVa12171，例题 6-18)，但是那道题目提到了 floodfill，那么，就先把这个 floodfill 这个知识点给讲了吧。\n首先，搞清楚题目中的一些条件。\n输入的 m 和 n 分别代表行和列，其范围都是 $[1, 100]$。 * 代表空白，没有油的地块，而 @ 代表有油的地块。 然后，书上可能会让人觉得疑惑的点，\n上面的代码用一个二重循环来找到当前格子的相邻 8 个格子，也可以用常量数组或写 8 条 DFS 调用。\n这里说的是可以直接硬编码 8 个 DFS，因为每次遍历只需要 8 次的 DFS。或者，把这 8 次整成一个由 8 个向量组成的常量数组也可以。\n剩余的就是一个简单的 DFS 了。直接看代码很容易理解。\n","permalink":"http://localhost:1313/posts/uva572/","summary":"\u003cp\u003e本题较为简单。本来是想讲另外一道题目的(UVa12171，例题 6-18)，但是那道题目提到了 floodfill，那么，就先把这个 floodfill 这个知识点给讲了吧。\u003c/p\u003e","title":"UVa572"},{"content":"思来想去，还是把 CSDN 直接屏蔽掉吧。\n首先，安装 ublacklist，\n然后，找到 options(选项)，\n直接写一个模糊匹配的规则即可，\n1*://*.csdn.net/* ","permalink":"http://localhost:1313/posts/block-csdn-when-using-google-search/","summary":"\u003cp\u003e思来想去，还是把 CSDN 直接屏蔽掉吧。\u003c/p\u003e\n\u003cp\u003e首先，安装 \u003ca href=\"https://chromewebstore.google.com/detail/ublacklist/pncfbmialoiaghdehhbnbhkkgmjanfhe\"\u003eublacklist\u003c/a\u003e，\u003c/p\u003e\n\u003cp\u003e然后，找到 options(选项)，\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/zB7B3QvD/image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接写一个模糊匹配的规则即可，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-txt\" data-lang=\"txt\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003e*://*.csdn.net/*\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"谷歌搜索屏蔽CSDN"},{"content":"前言 这篇博客是关于一些关于阅读《算法竞赛入门经典·第 2 版》的一些小贴士。\n老手自不必说，本博客针对的是刚接触这本书的一些新手。\n为什么要读这一本书？\n因为经典。首先作者的实力相当深厚，其次是选取的题目非常纯粹，都是 UVa 的题目，而我们也知道，UVa 的很多题目都是 acm 的原题，所以，题目的严谨性和质量有一定的保证，作为我们学习过程中的例题简直再合适不过。\n那么，下面就讲一些我认为需要讲的点。\n首先是前置条件，完整地、有体系地入门过数据结构。大概需要的程度是掌握 70% 的机械工业出版社的那本《数据结构与算法分析 C 语言描述》的内容。第一版和第二版都可以。这里插一句，一定要中英文放在一起看，为什么？因为如果你刚接触这本书，那么，你也就是大学低年级的水平，你的英文水平、专业词汇的水平还不够直接阅读英文原文，所以最好中英文放在一起看，中文觉得别扭的地方，翻开英文看看，记录一下不顺的地方，然后，把翻译得不好的地方放到网上供大家赏玩，让出版社蒙羞，注意，一定要有理有据，不然，和“秀才造反，三年不成，空谈误国”道理是一样的。\n然后，一些必须放在身边的辅助的工具。\n源码 第一，是源码，例题的代码在这个仓库：\nhttps://github.com/aoapc-book/aoapc-bac2nd\n这个例题的代码是刘汝佳亲自写的，代码质量有保证，不晦涩，很亲民，稍微多挠几下脑瓜，基本都可以搞懂。\n习题的代码在这个仓库：\nhttps://github.com/sukhoeing/aoapc-bac2nd-keys\n这个是陈锋写的，我个人觉得写得不如刘汝佳，不能够做到鞭辟入里。当然，代码本身的正确性和简洁性是毋庸置疑的，这个也没的黑。\n关于书的获取 这本书太有名了，随便谷歌一下即可获取。\n要看原题描述 然后，因为书中的题目全部选自 UVa，所以，阅读每一个例题的时候，最好把 UVa 的英文原题的 pdf 摆在旁边，这个 pdf 可以到 UVa 官网获取，也可以到 vjudge 中去获取，这个也可以自行搜索(千万不要使用百度、必应国内版)即可。基本上输入题目的序号，就能找到其题目的链接的。比如，有些题目的链接：\nUVa442(UVa 官网): https://onlinejudge.org/index.php?option=com_onlinejudge\u0026Itemid=8\u0026page=show_problem\u0026problem=383 UVa442(vjudge): https://vjudge.net/problem/UVA-442 当然，UVa 也提供了一份题单，我个人觉得没有必要，遇到的时候，直接搜索一把即可，基本上前两个结果就是我们想要的。\n跑测试用例 这里一定要借助 udebug 这个网站，输入题号，即可检索到大量的测试用例。便于我们在实际去跑一个题目的代码时去排查 bug。\n因为有时候作者给出的代码不一定是完全正确的，以及，在我们自己去做额外的题目时，这时候就需要我们自己去利用测试用例排查了。\n重定向标准输入 因为书里的题目都是 acm 模式，所以，我们自己在写题目的时候，肯定是要重定向标准输入到文件的，这样我们只需要把测试用例粘贴到文件中，然后，程序就可以从文件中读取测试用例了。\n输出倒是不用重定向，直接输出到控制台我们也可以很容易观察。\n如何提交代码 建议直接到 vjudge 中去提交，反正也是调用官方的 api。因为官网实在有点慢，难免，当然也理解，毕竟为爱发电。\n关于例题的阅读 有些人喜欢去空想，硬想，你以为你是天才？随便翻开书中一道简单的 BFS 的题目，我们可以测试一下，自己在不看任何题解的情况下，需要花费多少时间解决。\n编程没有天才，只有一些喜欢装逼的废柴。剩下的唯有多看多写多练。\n很多时候，我们看到很多人可以凭空想出来，那么，我们也可以猜一猜，他们的题量是多少。而最初的题量，就是来自于对例题的理解。\n我们听老师上课讲解题目，不也是相当于是看例题、看题解的过程吗？\n所以，我这里更建议大家直接把书上的所有例题理解即可。不用尝试自己去做。等把所有的例题都吃透了，甚至是琢磨了两三遍，那么，我们就可以尝试去自己写书上的习题了，这时候，有了知识储备，再去尝试独立思考，那么，必定事半而功倍.。\n阅读的笔记？ 关于笔记，我们在理解题目和题解的时候，对于每一个题目，我们只需要弄清几个问题即可：\n这样做的正确性书上给证明了吗？如果给了，理解简要的证明，也就理解了正确性。 如果没有给证明，我们就要自己想明白其中的正确性。 算法的时间复杂度/空间复杂度的理解和简要证明。 对于理解题意，也不必钻入细节，只要识别出题目的意图即可，因为，即使 UVa 的题目已经算是比较严谨了，却也依然有人力不可完全细察之处的缺漏。 最重要的一点，识别作者给出的代码的每一处意图。只有如此，我们才能在自己做题目的时候运用自如。 这样一套下来，其实，搞懂一个例题，不比我们写一道力扣中等题所花费的时间少，不过，却也必然比我们在没有任何/太多知识和题量储备的情况下去硬想力扣的题目所花费的时间要少得多。\n而看懂一道题的收获，必然也是不少的，因为，这书中的大部分题目都是力扣的困难级别的。\n","permalink":"http://localhost:1313/posts/some-tips-for-reading-aoapc-bac2nd/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e这篇博客是关于一些关于阅读《算法竞赛入门经典·第 2 版》的一些小贴士。\u003c/p\u003e\n\u003cp\u003e老手自不必说，本博客针对的是刚接触这本书的一些新手。\u003c/p\u003e\n\u003cp\u003e为什么要读这一本书？\u003c/p\u003e\n\u003cp\u003e因为经典。首先作者的实力相当深厚，其次是选取的题目非常纯粹，都是 UVa 的题目，而我们也知道，UVa 的很多题目都是 acm 的原题，所以，题目的严谨性和质量有一定的保证，作为我们学习过程中的例题简直再合适不过。\u003c/p\u003e","title":"《算法竞赛入门经典·第 2 版》的一些阅读小贴士"},{"content":"题目链接：https://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\n对应算法导论的 33.4。\n主要是有几个问题。\n1、分治是如何进行切分的？\n我是比较朴素地直接一分为二，不让在中间的分割线上既可以包含在左半部分也包含在右半部分。而且，中间的线上的点是先从上面的部分切起，保证这一点的做法是，把点集按照 x 坐标排序的同时，如果 x 相等，那么，再按 y 排序。\n2、真的是 O(nlogn) 吗？\n是的。不信你就去用主方法再推一遍。\n3、为什么可以是 5 而不是 7？\n因为我前面的切分保证了分割线上没有重复的点。\n4、如何保证每一次递归额外所花费的时间是 O(n)？\n对 Y 切割后进行排序使用 set，那么，基本可以保证每一次查询是 O(1) 的时间复杂度。而构建 set 的插入操作也是这个时间复杂度。不过，正如我们学习数据结构的时候知道，有些极端情况会退化成 O(n) 的，但是，这个极端情况也是可以通过进一步优化 set 的内部构造来解决的。所以，这里按下不表，单就做题而言，使用 Python 内置的 set 就可以了。\n5、为什么只用 X 和 Y 就可以了？\n因为 P 其实本来就用不到，书上是为了事无巨细地讲明白才如此冗余。\n6、对于中间条带的点的暴力循环，其时间复杂度是 O(n)？\n当然是的，5n 也是 O(n)，不是吗？\n其实，我以前在上课的时候，也写过一篇[笔记](https://fanlumaster.github.io/2021/05/03/《算法导论》寻找最近点对问题的 Python 实现)。\n代码见仓库。\n","permalink":"http://localhost:1313/posts/closest-pair-of-points-in-linearithmic-time/","summary":"\u003cp\u003e题目链接：\u003ca href=\"https://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\"\u003ehttps://www.codewars.com/kata/5376b901424ed4f8c20002b7/train/python\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e对应算法导论的 33.4。\u003c/p\u003e\n\u003cp\u003e主要是有几个问题。\u003c/p\u003e\n\u003cp\u003e1、分治是如何进行切分的？\u003c/p\u003e\n\u003cp\u003e我是比较朴素地直接一分为二，不让在中间的分割线上既可以包含在左半部分也包含在右半部分。而且，中间的线上的点是先从上面的部分切起，保证这一点的做法是，把点集按照 x 坐标排序的同时，如果 x 相等，那么，再按 y 排序。\u003c/p\u003e","title":"寻找最近点对"},{"content":"愚蠢的人自然要自己为其付出代价。多说无益。\n人们当然愿意相信他们已经相信过的东西。\n很多东西其实是无意义的。比如，视频的封面、视频的播放量、视频的夸张的标题、视频的字幕等等等等。\n真正重要的是内容。无论是否有人愿意去看。\n","permalink":"http://localhost:1313/posts/the-foolish-must-pay-the-price-for-their-own-thoughts/","summary":"\u003cp\u003e愚蠢的人自然要自己为其付出代价。多说无益。\u003c/p\u003e\n\u003cp\u003e人们当然愿意相信他们已经相信过的东西。\u003c/p\u003e\n\u003cp\u003e很多东西其实是无意义的。比如，视频的封面、视频的播放量、视频的夸张的标题、视频的字幕等等等等。\u003c/p\u003e","title":"The Foolish Must Pay the Price for Their Own Thoughts"},{"content":"理解 题意比较简单，时间长没有碰数学者或许需要一两分钟回想一下矩阵的乘法。\n可以看一下同济大学的线代教材中给出的矩阵的相乘的公式，\n看一下输入和输出，\n输入\n这里有个术语：EBNF，这是编译原理里面的一个很简单的一个范式，上过课的应该都有印象，如果需要，再去翻一下书即可。\n注意这个条件，\n1Expression = Matrix | \u0026#34;(\u0026#34; Expression Expression \u0026#34;)\u0026#34; 可以推出，括号里面只可以出现一对单独的矩阵，也就是两个单独的矩阵，e.g. (AB)，或者，一个矩阵加上另一对括号括起来的矩阵，e.g. (A(AB))，以此类推。因此，我们可以在遇到右括号的时候，一次出栈两个栈中的元素，\n1else if (expr[i] == \u0026#39;)\u0026#39;) { 2 Matrix m2 = s.top(); 3 s.pop(); 4 Matrix m1 = s.top(); 5 s.pop(); 6 ... 7} 输出\n理解一下题目中的例子即可。\n代码 1#include \u0026lt;cstdio\u0026gt; 2#include \u0026lt;cctype\u0026gt; 3#include \u0026lt;stack\u0026gt; 4#include \u0026lt;iostream\u0026gt; 5#include \u0026lt;string\u0026gt; 6 7using namespace std; 8 9struct Matrix { 10 int a, b; 11 Matrix(int a = 0, int b = 0) : a(a), b(b) {} 12} m[26]; 13 14stack\u0026lt;Matrix\u0026gt; s; 15 16int main(int argc, char *argv[]) { 17 int n; 18 cin \u0026gt;\u0026gt; n; 19 for (int i = 0; i \u0026lt; n; i++) { 20 string name; 21 cin \u0026gt;\u0026gt; name; 22 int k = name[0] - \u0026#39;A\u0026#39;; 23 cin \u0026gt;\u0026gt; m[k].a \u0026gt;\u0026gt; m[k].b; 24 } 25 string expr; 26 while (cin \u0026gt;\u0026gt; expr) { 27 int len = expr.length(); 28 bool error = false; 29 int ans = 0; 30 for (int i = 0; i \u0026lt; len; i++) { 31 if (isalpha(expr[i])) 32 s.push(m[expr[i] - \u0026#39;A\u0026#39;]); 33 else if (expr[i] == \u0026#39;)\u0026#39;) { 34 Matrix m2 = s.top(); 35 s.pop(); 36 Matrix m1 = s.top(); 37 s.pop(); 38 if (m1.b != m2.a) { 39 error = true; 40 break; 41 } 42 ans += m1.a * m2.a * m2.b; 43 s.push(Matrix(m1.a, m2.b)); 44 } 45 } 46 if (error) 47 cout \u0026lt;\u0026lt; \u0026#34;error\\n\u0026#34;; 48 else 49 cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 50 } 51 return 0; 52} ","permalink":"http://localhost:1313/posts/uva442/","summary":"UVa210 解题思路及代码解析","title":"UVa442"},{"content":"关于 B 站的 sonnycalcr 这个帐号的事情，就在这个博客里面说。\n今天与一位 B 站的网友私信时，我犯了一个习惯主义错误：一杯奶茶解决问题。\n这好吗？我以前从来没有意识到这个问题。以前的习惯是，给一些同学或者朋友看问题，往往会附加一个条件，那就是，请喝奶茶，或者请吃饭(当然，是学校的食堂)。人都是有所求的，不可能无缘无故帮助别人，这十块或者二十块以内非真实的金钱的交易，大概就和中学时代的一袋方便面讲解一道题类似。\n几块钱的问题本不值得拿出来一说，毕竟现在很多程序员以大厂作为炫耀的条件，以月薪 30k，40k，80k 这种作为一种说辞：难道还有人的薪资低于 20k 吗？\n但是，学生毕竟是学生。\n关于我个人的经济状况：\n因为房子是自己的，所以每个月的消耗也不过是一些脑力、电力、水、气这些。所以，经济状况，至少两年内不用考虑。如果稍微顺利一点，那就是一坤年。如果再幸运一点，那估计就要把单位换成 10 年这个 unit 了。\n总结：既然你也是群众的一员，那就不能拿群众一针一线。朋友同学除外。\n","permalink":"http://localhost:1313/posts/one-cup-of-tea/","summary":"\u003cp\u003e关于 B 站的 sonnycalcr 这个帐号的事情，就在这个博客里面说。\u003c/p\u003e\n\u003cp\u003e今天与一位 B 站的网友私信时，我犯了一个习惯主义错误：一杯奶茶解决问题。\u003c/p\u003e\n\u003cp\u003e这好吗？我以前从来没有意识到这个问题。以前的习惯是，给一些同学或者朋友看问题，往往会附加一个条件，那就是，请喝奶茶，或者请吃饭(当然，是学校的食堂)。人都是有所求的，不可能无缘无故帮助别人，这十块或者二十块以内非真实的金钱的交易，大概就和中学时代的一袋方便面讲解一道题类似。\u003c/p\u003e","title":"一杯奶茶引起的质疑"},{"content":"《算法竞赛入门经典》(第二版) 第 6 章例题 6-2。\n题意 这一题的题面较短，其中英文原题也比较容易理解，所以，我们直接分析题意和代码。\n本题的题意是右边有一列火车向左开，一列火车可以有很多个车厢，单个车厢来到岔路口的时候，可以选择直接进入 B 轨道，也可以选择在 Station 里面暂存一下，但是 Station 相当于是一个 stack，所以，遵循后进先出的规则。\n题目的要求就是，在这样的规则之下，判断给定的序列是否是合法的。\n具体我们看几个输入和输出的样例即可。\n代码 需要说明一点是，书上给出的代码是有误的，实际提交到 OJ 无法通过。我这里讲解的是我修改之后 AC 的代码。\n1// UVa514 Rails 2#include \u0026lt;cstdio\u0026gt; 3#include \u0026lt;stack\u0026gt; 4#include \u0026lt;string\u0026gt; 5 6using namespace std; 7const int MAXN = 1000 + 10; 8 9int n, target[MAXN]; 10 11int main() { 12 // 重定向输入数据，省去我们手动输入的繁琐 13 string relativePathToCurrentCFile = \u0026#34;./data/UVa514/input2.txt\u0026#34;; 14 // relativePathToCurrentCFile = \u0026#34;./data/UVa210/input3.txt\u0026#34;; 15 freopen(string(\u0026#34;./ch06\u0026#34; + relativePathToCurrentCFile.substr(1, relativePathToCurrentCFile.size() - 1)).c_str(), \u0026#34;r\u0026#34;, stdin); 16 17 while (scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) == 1) { // 读取 N 18 if (n == 0) { 19 break; 20 } 21 while (true) { 22 scanf(\u0026#34;%d\u0026#34;, \u0026amp;target[1]); // 读取序列的第一个数 23 if (target[1] == 0) { // 如果是 0，那么，说明当前这个样例结束了 24 printf(\u0026#34;\\n\u0026#34;); 25 break; 26 } 27 for (int i = 2; i \u0026lt;= n; i++) // 继续读入 28 scanf(\u0026#34;%d\u0026#34;, \u0026amp;target[i]); 29 30 stack\u0026lt;int\u0026gt; s; // 利用 stack 来进行模拟处理 31 int A = 1, B = 1; 32 int ok = 1; 33 while (B \u0026lt;= n) { 34 if (A == target[B]) { // 当前的车厢和 target 在 B 这个位置所要求的车厢是相同的，那么不用经过 station 直接进入左边的轨道即可 35 A++; 36 B++; 37 } else if (!s.empty() \u0026amp;\u0026amp; s.top() == target[B]) { // 栈的顶部符合条件 38 s.pop(); 39 B++; 40 } else if (A \u0026lt;= n) // 目前没有符号条件的，就入栈 41 s.push(A++); 42 else { // 越界了都没有找到 43 ok = 0; 44 break; 45 } 46 } 47 printf(\u0026#34;%s\\n\u0026#34;, ok ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;); 48 } 49 } 50 51 return 0; 52} ","permalink":"http://localhost:1313/posts/uva514/","summary":"\u003cp\u003e《算法竞赛入门经典》(第二版) 第 6 章例题 6-2。\u003c/p\u003e\n\u003ch2 id=\"题意\"\u003e题意\u003c/h2\u003e\n\u003cp\u003e这一题的题面较短，其中英文原题也比较容易理解，所以，我们直接分析题意和代码。\u003c/p\u003e\n\u003cp\u003e本题的题意是右边有一列火车向左开，一列火车可以有很多个车厢，单个车厢来到岔路口的时候，可以选择直接进入 B 轨道，也可以选择在 Station 里面暂存一下，但是 Station 相当于是一个 stack，所以，遵循后进先出的规则。\u003c/p\u003e","title":"UVa514"},{"content":"首先，放我在 v 站的质疑的帖子，基本信息都在这个里面了。\nhttps://www.v2ex.com/t/1072947\n惯例，先叠甲：我卑怯、胆小、狡猾、懦弱（EVA 真嗣语）。\n还有该死的好奇心，不，纯粹是我要当正义的伙伴！(卫宫士郎语)\n要是我输，我 TM 直播吃键盘(开玩笑，但是肯定会道歉的，而且是郑重道歉)。\n我呢，就来发出一点不同的声音，因为我看见评论区的意见的一致的，而刚好我也有些疑问。\n那么，这个视频的主体内容就是读评论了，不过，不是读在该 UP 视频下的评论。\n也可以看一看我自己对于争论的态度，我不反对，声音当然是越多越好，信息越多，越有利于大家判断。\nhttps://www.bilibili.com/video/BV1BsYSe1EGY/?spm_id_from=333.999.0.0\u0026vd_source=452591e6eeff36707902db6872a46580\n我其实不太讨厌培训班的人，因为他们好歹可以把成体系的知识传授给大家，而且，挣钱就挣钱，卖课就卖课，不寒碜。\n最后，本视频应该不涉及违规内容，而且我自己认为应该算是合理的一种质疑？如果大家认为我是在蹭热度，忌妒人家导致人红是非多，我权且接受，大家都来攻击我吧。\n再最后，本人逻辑极差，表达内容可能有失偏颇的地方，希望大家海涵。以及，我自己的代码水平极差，大家随便喷。\n希望审核放过。\n","permalink":"http://localhost:1313/posts/questioning-a-bilibili-up-dhwass/","summary":"\u003cp\u003e首先，放我在 v 站的质疑的帖子，基本信息都在这个里面了。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.v2ex.com/t/1072947\"\u003ehttps://www.v2ex.com/t/1072947\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e惯例，先叠甲：我卑怯、胆小、狡猾、懦弱（EVA 真嗣语）。\u003c/p\u003e\n\u003cp\u003e还有该死的好奇心，不，纯粹是我要当正义的伙伴！(卫宫士郎语)\u003c/p\u003e","title":"简要质疑一下 DHwass 的编程水平"},{"content":"这一集视频我们来看一下第二章的第一节。从这一集视频开始，我决定只讲代码和我认为需要挑出来讲解的难点/细节，对于难点和细节，我决定以提出问题和解决问题的形式来呈现。关于代码，基本只讲书上出现过的代码，实在有需要我再自己补充代码。毕竟基础知识的话，我觉得书上写的已经足够详细了，我再复述一遍没什么太多的意义，所以，大家看书的话，常看常新呀，总之就是一定要常看。\n因为代码是更加直观的东西，并且，我们最终都是要去实际地写代码的。所以，我这里将着重去讲解书上出现的每一处代码，我认为能够理解代码，并且把这些代码实际应用到我们实际的项目中去，这才是真正有意义的事情。\n如果我们能做到完全理解书上的这些代码，做到看到这些代码时心中有底，我觉得那就是胜利。同时，如果习题里面有涉及代码的部分，我们也不会错过。\n尽量做到：一切都在代码中。这样，如果有人问，你读过这本书吗？我们可以很有底气地说，读过，毕竟，代码全都掌握了，难道还不算读过吗？\n这里还要额外多说一点，就是，从这一章开始，我在视频中演示代码所使用的编辑器将换到 neovim + neovide 这样一个组合，然后，在 Windows 平台下，我会使用 pwsh 也就是 powershell 脚本来进行自动化编译和运行，而在 Linux 中，我将使用 shell 脚本来自动化编译和运行。当然，构建工具使用的肯定是 cmake。\n那么，就直接看代码吧。\n说明：代码的命名规范依然以英文原版书中出现的代码的页码为指导原则。\nPart1 英文原书 p32,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int i = 1; 6 int j = 2; 7 i = i + j; 8 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 9 10 return 0; 11} 个人对英文原书 32 页补充代码，custom_p32.cpp,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // bool 类型，通常大小为 1 个字节 6 bool boolean = true; 7 std::cout \u0026lt;\u0026lt; \u0026#34;bool: \u0026#34; \u0026lt;\u0026lt; boolean \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(boolean) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 8 9 // char 类型，8 bits 10 char character = \u0026#39;A\u0026#39;; 11 std::cout \u0026lt;\u0026lt; \u0026#34;char: \u0026#34; \u0026lt;\u0026lt; character \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(character) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 12 13 // wchar_t 类型，宽字符，16 bits 或 32 bits，取决于平台 14 wchar_t wide_character = L\u0026#39;A\u0026#39;; 15 std::wcout \u0026lt;\u0026lt; \u0026#34;wchar_t: \u0026#34; \u0026lt;\u0026lt; wide_character \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(wide_character) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 16 17 // char16_t 类型，16 bits Unicode 字符 18 char16_t unicode_16 = u\u0026#39;A\u0026#39;; 19 std::wcout \u0026lt;\u0026lt; \u0026#34;char16_t: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;wchar_t\u0026gt;(unicode_16) \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(unicode_16) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 20 21 // char32_t 类型，32 bits Unicode 字符 22 char32_t unicode_32 = U\u0026#39;A\u0026#39;; 23 std::wcout \u0026lt;\u0026lt; \u0026#34;char32_t: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;wchar_t\u0026gt;(unicode_32) \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(unicode_32) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 24 25 // short 整数类型，16 bits 26 short short_integer = 16; 27 std::cout \u0026lt;\u0026lt; \u0026#34;short: \u0026#34; \u0026lt;\u0026lt; short_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(short_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 28 29 // int 整数类型，通常至少为 32 bits，但某些系统上可能为 16 bits 30 int integer = 26; 31 std::cout \u0026lt;\u0026lt; \u0026#34;int: \u0026#34; \u0026lt;\u0026lt; integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 32 33 // long 整数类型，通常为 32 bits 34 long long_integer = 36; 35 std::cout \u0026lt;\u0026lt; \u0026#34;long: \u0026#34; \u0026lt;\u0026lt; long_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(long_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 36 37 // long long 整数类型，64 bits 38 long long long_long_integer = 46LL; 39 std::cout \u0026lt;\u0026lt; \u0026#34;long long: \u0026#34; \u0026lt;\u0026lt; long_long_integer \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(long_long_integer) \u0026lt;\u0026lt; \u0026#34; bytes)\u0026#34; \u0026lt;\u0026lt; std::endl; 40 41 // float 单精度浮点数，精度为 6 位有效数字 42 float single_precision = 3.1f; 43 std::cout \u0026lt;\u0026lt; \u0026#34;float: \u0026#34; \u0026lt;\u0026lt; single_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(single_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; FLT_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 44 45 // double 双精度浮点数，精度为 10 位有效数字 46 double double_precision = 3.14; 47 std::cout \u0026lt;\u0026lt; \u0026#34;double: \u0026#34; \u0026lt;\u0026lt; double_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(double_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; DBL_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 48 49 // long double 扩展精度浮点数，通常与 double 相同，但某些系统上可能有更高精度 50 long double extended_precision = 3.1415L; 51 std::cout \u0026lt;\u0026lt; \u0026#34;long double: \u0026#34; \u0026lt;\u0026lt; extended_precision \u0026lt;\u0026lt; \u0026#34; (size: \u0026#34; \u0026lt;\u0026lt; sizeof(extended_precision) \u0026lt;\u0026lt; \u0026#34; bytes, precision: \u0026#34; \u0026lt;\u0026lt; LDBL_DIG \u0026lt;\u0026lt; \u0026#34; significant digits)\u0026#34; \u0026lt;\u0026lt; std::endl; 52 53 return 0; 54} 关于这些基本类型，如果有时间的话，推荐大家去看《深入理解计算机系统(第三版)》这本书，英文名是：Computer Systems: A Programmer\u0026rsquo;s Perspective (3rd Edition)，也就是大名鼎鼎的 CSAPP。就拿浮点数来说，这个是我当时完整看过的，所以能够安心地给出评价，那就是如果你想理解浮点数真正的构造及原理，那么，可以抽空看一下这本书。\n那么，如果仅仅停留在本书需要理解的程度，那么，我们就像上面这样写几行代码就可以了解怎么去使用了，\n使用微软的 MSVC 编译器运行的结果如下，\n1bool: 1 (size: 1 bytes) 2char: A (size: 1 bytes) 3wchar_t: A (size: 2 bytes) 4char16_t: A (size: 2 bytes) 5char32_t: A (size: 4 bytes) 6short: 16 (size: 2 bytes) 7int: 26 (size: 4 bytes) 8long: 36 (size: 4 bytes) 9long long: 46 (size: 8 bytes) 10float: 3.1 (size: 4 bytes, precision: 6 significant digits) 11double: 3.14 (size: 8 bytes, precision: 15 significant digits) 12long double: 3.1415 (size: 8 bytes, precision: 15 significant digits) 这里为什么有些尺寸感觉和书上有差异呢？因为书上写的是标准规定的只是最小尺寸，然后在此基础上编译器可以自由发挥。\nPart2 类型转换 p35,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 bool b = 42; // b is true 6 std::cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 7 int i = b; // i has value 1 8 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 9 i = 3.14; // i has value 3 10 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 11 double pi = i; // pi has value 3.0 12 std::cout \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; 13 unsigned char c = -1; // assuming 8-bit chars, c has value 255 14 std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; 15 std::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(c) \u0026lt;\u0026lt; std::endl; 16 signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined 17 std::cout \u0026lt;\u0026lt; c2 \u0026lt;\u0026lt; std::endl; 18 std::cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(c2) \u0026lt;\u0026lt; std::endl; 19 return 0; 20} p36_1,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int i = 42; 6 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 7 if (i) // condition will evaluate as true 8 i = 0; 9 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 10 return 0; 11} p36_2,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u = 10; 6 int i = -42; 7 std::cout \u0026lt;\u0026lt; i + i \u0026lt;\u0026lt; std::endl; // prints -84 8 std::cout \u0026lt;\u0026lt; u + i \u0026lt;\u0026lt; std::endl; // if 32-bit ints, prints 4294967264 9 10 return 0; 11} 这里书上的解释有点问题，英文原版里面是让我们去看上面的案例，这里中文翻译多给了一些解释，但是这个解释不太能够让人理解，我们还是按照上面的取模的解释来。而对于给负数取模，我们可以把其想象成反方向拨动时钟，然后，从 0 到指针之间的距离就是我们所求的取模后的余数。\np37_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u1 = 42, u2 = 10; 6 std::cout \u0026lt;\u0026lt; u1 - u2 \u0026lt;\u0026lt; std::endl; // ok: result is 32 7 std::cout \u0026lt;\u0026lt; u2 - u1 \u0026lt;\u0026lt; std::endl; // ok: but the result will wrap around 8 9 return 0; 10} p37_02,\n1// 这里需要看一下中文版 p11 也的练习题第 2 题 2#include \u0026lt;iostream\u0026gt; 3 4int main(int argc, char *argv[]) 5{ 6 for (int i = 10; i \u0026gt;= 0; --i) 7 std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; 8 9 return 0; 10} 按：这里可以到 1.4.1 节(英文 p13)的练习那里去看一下。\np37_03,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 /* 6 // WRONG: u can never be less than 0; the condition will always succeed 7 for (unsigned u = 10; u \u0026gt;= 0; --u) 8 std::cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; std::endl; 9 */ 10 return 0; 11} p37_04,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 unsigned u = 11; // start the loop one past the first element we want to print 6 while (u \u0026gt; 0) 7 { 8 --u; // decrement first, so that the last iteration will print 0 9 std::cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; std::endl; 10 } 11 12 return 0; 13} Part3 字面值常量 p38_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 int a = 20; // 十进制 6 int b = 024; // 八进制 7 int c = 0x14; // 十六进制 8 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; 9 return 0; 10} p38_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 double a = 3.14159; 6 double b = 3.14159E0; 7 double c = 0.; 8 double d = 0e0; 9 double e = .001; 10 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; std::endl; 11 return 0; 12} p39_01,\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3 4int main() 5{ 6 char a = \u0026#39;a\u0026#39;; 7 std::string b = \u0026#34;Hello World!\u0026#34;; 8 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; 9 return 0; 10} p39_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // multiline string literal 6 std::cout \u0026lt;\u0026lt; \u0026#34;a really, really long string literal \u0026#34; 7 \u0026#34;that spans two lines\u0026#34; \u0026lt;\u0026lt; std::endl; 8 return 0; 9} p39_03,\n1#include \u0026lt;cstdio\u0026gt; 2#include \u0026lt;iostream\u0026gt; 3 4int main() 5{ 6 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\nWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 7 std::cout \u0026lt;\u0026lt; \u0026#34;Name\\tAge\u0026#34; \u0026lt;\u0026lt; std::endl; 8 std::cout \u0026lt;\u0026lt; \u0026#34;\\a\u0026#34; \u0026lt;\u0026lt; std::endl; 9 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\vWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 10 std::cout \u0026lt;\u0026lt; \u0026#34;Helloo\\b World\u0026#34; \u0026lt;\u0026lt; std::endl; 11 std::cout \u0026lt;\u0026lt; \u0026#34;He said, \\\u0026#34;Hello!\\\u0026#34;\u0026#34; \u0026lt;\u0026lt; std::endl; 12 std::cout \u0026lt;\u0026lt; \u0026#34;C:\\\\Program Files\u0026#34; \u0026lt;\u0026lt; std::endl; 13 std::cout \u0026lt;\u0026lt; \u0026#34;What\\?\u0026#34; \u0026lt;\u0026lt; std::endl; 14 std::cout \u0026lt;\u0026lt; \u0026#34;It\\\u0026#39;s a cat\u0026#34; \u0026lt;\u0026lt; std::endl; 15 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\rWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 16 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\fWorld\u0026#34; \u0026lt;\u0026lt; std::endl; 17 getchar(); 18 return 0; 19} p39_04,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints a newline 6 std::cout \u0026lt;\u0026lt; \u0026#34;\\tHi!\\n\u0026#34;; // prints a tab followd by \u0026#34;Hi!\u0026#34; and a newline 7 return 0; 8} p39_05,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#34;\\7\u0026#34;; // 在一些环境下会发出提示音，和 \\a 相同 6 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\12World\u0026#34;; // 输出： 7 // Hello 8 // World 9 // 实际效果等同于 \\n 10 11 std::cout \u0026lt;\u0026lt; \u0026#34;Hello\\40World\u0026#34;; // 输出：Hello World （插入一个空格） 12 13 char str[] = \u0026#34;Hello\\0World\u0026#34;; 14 std::cout \u0026lt;\u0026lt; str; // 输出：Hello （由于\\0表示字符串结束，World部分不会被输出） 15 16 std::cout \u0026lt;\u0026lt; \u0026#34;\\115\u0026#34;; // 输出：M 17 18 std::cout \u0026lt;\u0026lt; \u0026#34;\\x4d\u0026#34;; // 输出：M 19 return 0; 20} p40_01,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 std::cout \u0026lt;\u0026lt; \u0026#34;Hi \\x4dO\\115!\\n\u0026#34;; // prints Hi MOM! followed by a newline 6 std::cout \u0026lt;\u0026lt; \u0026#39;\\115\u0026#39; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints M followed by a newline 7 return 0; 8} p40_02,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() 4{ 5 // 1. L\u0026#39;a\u0026#39; - wide character literal (wchar_t) 6 wchar_t wideChar = L\u0026#39;a\u0026#39;; 7 std::wcout \u0026lt;\u0026lt; L\u0026#34;Wide character literal: \u0026#34; \u0026lt;\u0026lt; wideChar \u0026lt;\u0026lt; std::endl; 8 9 // 2. u8\u0026#34;hi!\u0026#34; - UTF-8 string literal 10 const char *utf8String = u8\u0026#34;hi!\u0026#34;; 11 std::cout \u0026lt;\u0026lt; \u0026#34;UTF-8 string literal: \u0026#34; \u0026lt;\u0026lt; utf8String \u0026lt;\u0026lt; std::endl; 12 13 // 3. 42ULL - unsigned long long literal 14 unsigned long long ullValue = 42ULL; 15 std::cout \u0026lt;\u0026lt; \u0026#34;Unsigned long long literal: \u0026#34; \u0026lt;\u0026lt; ullValue \u0026lt;\u0026lt; std::endl; 16 17 // 4. 1E-3F - single-precision floating-point literal (float) 18 float floatValue = 1E-3F; 19 std::cout \u0026lt;\u0026lt; \u0026#34;Single-precision floating-point literal: \u0026#34; \u0026lt;\u0026lt; floatValue \u0026lt;\u0026lt; std::endl; 20 21 // 5. 3.14159L - extended-precision floating-point literal (long double) 22 long double longDoubleValue = 3.14159L; 23 std::cout \u0026lt;\u0026lt; \u0026#34;Extended-precision floating-point literal: \u0026#34; \u0026lt;\u0026lt; longDoubleValue \u0026lt;\u0026lt; std::endl; 24 25 return 0; 26} p41,\n1#include \u0026lt;iostream\u0026gt; 2 3int main() { 4 5 bool test = false; 6 std::cout \u0026lt;\u0026lt; test \u0026lt;\u0026lt; std::endl; 7 return 0; 8} ","permalink":"http://localhost:1313/posts/cpp-primer-ch02-1/","summary":"\u003cp\u003e这一集视频我们来看一下第二章的第一节。从这一集视频开始，我决定只讲代码和我认为需要挑出来讲解的难点/细节，对于难点和细节，我决定以提出问题和解决问题的形式来呈现。关于代码，基本只讲书上出现过的代码，实在有需要我再自己补充代码。毕竟基础知识的话，我觉得书上写的已经足够详细了，我再复述一遍没什么太多的意义，所以，大家看书的话，常看常新呀，总之就是一定要常看。\u003c/p\u003e","title":"C++ Primer 第五版 2.1  笔记"},{"content":"本节主要的内容只有一份代码，就是标题所说的书店程序，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item total; // variable to hold data for the next transaction 6 // read the first transaction and ensure that there are data to process 7 if (std::cin \u0026gt;\u0026gt; total) 8 { 9 Sales_item trans; // variable to hold the running sum 10 // read and process the remaining transactions 11 while (std::cin \u0026gt;\u0026gt; trans) 12 { 13 // if we’re still processing the same book 14 if (total.isbn() == trans.isbn()) 15 total += trans; // update the running total 16 else 17 { 18 // print results for the previous book 19 std::cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; std::endl; 20 total = trans; // total now refers to the next book 21 } 22 } 23 std::cout \u0026lt;\u0026lt; total \u0026lt;\u0026lt; std::endl; // print the last transaction 24 } 25 else 26 { 27 // no input! warn the user 28 std::cerr \u0026lt;\u0026lt; \u0026#34;No data?!\u0026#34; \u0026lt;\u0026lt; std::endl; 29 return -1; // indicate failure 30 } 31 return 0; 32} 33 34/* input: 350-201-70353-X 4 24.99 360-201-82470-1 4 45.39 370-201-88954-4 2 15.00 380-201-88954-4 5 12.00 390-201-88954-4 7 12.00 400-201-88954-4 2 12.00 410-399-82477-1 2 45.39 420-399-82477-1 3 45.39 430-201-78345-X 3 20.00 440-201-78345-X 2 25.00 45*/ 可能有同志会注意到这个程序在读取输入的时候，最后可能需要先回车一下，然后按下 Ctrl + Z 然后再回车，才能使程序接收到 EOF(end of file) 信号，这个问题我们只需要知道如何去规避即可，如果想刨根究底，那么，也没有问题，推荐去看以下两个链接，主要是第二个链接，\nhttps://stackoverflow.com/questions/1782080/what-is-eof-in-the-c-programming-language https://stackoverflow.com/questions/5655112/why-do-i-require-multiple-eof-ctrlz-characters ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-6/","summary":"\u003cp\u003e本节主要的内容只有一份代码，就是标题所说的书店程序，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026#34;Sales_item.h\u0026#34;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eSales_item\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// variable to hold data for the next transaction\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// read the first transaction and ensure that there are data to process\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eSales_item\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// variable to hold the running sum\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// read and process the remaining transactions\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e// if we’re still processing the same book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotal\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisbn\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eisbn\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// update the running total\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e18\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e// print results for the previous book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e19\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e20\u003c/span\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etrans\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// total now refers to the next book\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e21\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e22\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e23\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotal\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// print the last transaction\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e24\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e25\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e26\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e27\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// no input! warn the user\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e28\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecerr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;No data?!\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e29\u003c/span\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// indicate failure\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e30\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e31\u003c/span\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e32\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e33\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e34\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e/* input:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e35\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-70353-X 4 24.99\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e36\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-82470-1 4 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e37\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 2 15.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e38\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 5 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e39\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 7 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e40\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-88954-4 2 12.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e41\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-399-82477-1 2 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e42\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-399-82477-1 3 45.39\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e43\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-78345-X 3 20.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e44\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e0-201-78345-X 2 25.00\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e45\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可能有同志会注意到这个程序在读取输入的时候，最后可能需要先回车一下，然后按下 Ctrl + Z 然后再回车，才能使程序接收到 EOF(end of file) 信号，这个\u003ca href=\"https://stackoverflow.com/questions/31261483/why-ctrl-z-does-not-trigger-eof\"\u003e问题\u003c/a\u003e我们只需要知道如何去规避即可，如果想刨根究底，那么，也没有问题，推荐去看以下两个链接，主要是第二个链接，\u003c/p\u003e","title":"C++ Primer 第五版 1.6 书店程序 笔记"},{"content":"这一集我们简要介绍一下类这个知识点。\n所谓的类，我们可以把它想象成一个内置的类型一样的物件，然后，和内置类型不同的点在于，类需要我们自己去设计和定义。\n这一小节主要是让我们看一下如何简单地使用一个类。\nPart1 Sales_item 类 那么，接下来接直接看代码，看一下如何简单地使用 Sales_item 这个类，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3 4int main() 5{ 6 Sales_item book; 7 8 // read ISBN, number of copies sold, and sales price 9 std::cin \u0026gt;\u0026gt; book; 10 // write ISBN, number of copies sold, total revenue, and average price 11 std::cout \u0026lt;\u0026lt; book \u0026lt;\u0026lt; std::endl; 12 13 return 0; 14} 这里插一句，书中的代码也可以直接到配套网站去下载，\nhttps://www.informit.com/store/c-plus-plus-primer-9780321714114\n书上有些没有给出的代码，但是配套代码给出了，那么，对于这一部分，我们就去到配套代码那里给取过来。比如，我们这里的代码想要跑通，就得把 Sales_item.h 这个头文件给复制过来。\n然后，是第二份代码，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item item1, item2; 6 std::cin \u0026gt;\u0026gt; item1 \u0026gt;\u0026gt; item2; // read a pair of transactions 7 std::cout \u0026lt;\u0026lt; item1 + item2 \u0026lt;\u0026lt; std::endl; // print their sum 8 return 0; 9} 按：关于书上提到的重定向操作，在 Windows 的命令行提示符和 Linux 系统的 shell 中，确实可以像下面这样，\n1addItems \u0026lt; infile \u0026gt; outfile 但是，在 PowerShell 中，我们得用另一种语法，\n1Get-Content .\\input.txt | addItems.exe \u0026gt; .\\output.txt Part2 成员函数 然后，是成员函数的简单使用，\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026#34;Sales_item.h\u0026#34; 3int main() 4{ 5 Sales_item item1, item2; 6 std::cin \u0026gt;\u0026gt; item1 \u0026gt;\u0026gt; item2; 7 // first check that item1 and item2 represent the same book 8 if (item1.isbn() == item2.isbn()) 9 { 10 std::cout \u0026lt;\u0026lt; item1 + item2 \u0026lt;\u0026lt; std::endl; 11 return 0; // indicate success 12 } 13 else 14 { 15 std::cerr \u0026lt;\u0026lt; \u0026#34;Data must refer to same ISBN\u0026#34; \u0026lt;\u0026lt; std::endl; 16 return -1; // indicate failure 17 } 18} 19} ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-5/","summary":"\u003cp\u003e这一集我们简要介绍一下类这个知识点。\u003c/p\u003e\n\u003cp\u003e所谓的类，我们可以把它想象成一个内置的类型一样的物件，然后，和内置类型不同的点在于，类需要我们自己去设计和定义。\u003c/p\u003e","title":"C++ Primer 第五版 1.5 类简介 笔记"},{"content":"如何让你的 VSCode 更加地 sexual？这是一个有意思的的话题，而让光标具有动画效果，可以让其更加赏心悦目，进而提升编写代码的幸福感。\n那么，今天就来介绍一下可以让 VSCode 具有光标动画的插件，只需要安装两个插件，\nApc Customize UI++ VSCode Animations 然后按照官方的文档来操作即可。它们的官方仓库的地址如下，\nhttps://github.com/drcika/apc-extension https://github.com/BrandonKirbyson/VSCode-Animations ","permalink":"http://localhost:1313/posts/vscode-make-caret-or-cursor-animations/","summary":"\u003cp\u003e如何让你的 VSCode 更加地 sexual？这是一个有意思的的话题，而让光标具有动画效果，可以让其更加赏心悦目，进而提升编写代码的幸福感。\u003c/p\u003e\n\u003cp\u003e那么，今天就来介绍一下可以让 VSCode 具有光标动画的插件，只需要安装两个插件，\u003c/p\u003e","title":"VSCode 使光标具有动画效果"},{"content":"这一集视频我们主要来看一下 C++ Primer 1.4 节。\n主要是对几个常用的控制流的语句进行说明，包括，\nwhile 循环 for 循环 读取输入 if 语句 我们这里的讲解主要是对书上示例的代码进行相应的解析，对于大家容易理解的知识点，就不去花费多余的时间来说明。删繁就简，同时，不漏疑难点。\nPart1 while 循环 首先是 while 语句，核心是理解这样一句话，\nwhile 语句反复执行一段代码，直至给定条件为假为止。\n直接看书中的示例代码，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0, val = 1; 5 // keep executing the while as long as val is less than or equal to 10 6 while (val \u0026lt;= 10) 7 { 8 sum += val; // assigns sum + val to sum 9 ++val; // add 1 to val 10 } 11 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 12 return 0; 13} Part2 for 循环 然后是 for 语句，我们更加常用的一种循环语句，\n比如，书上的例子是从 1 加到 10，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0; 5 // sum values from1 through 10 inclusive 6 for (int val = 1; val \u0026lt;= 10; ++val) 7 sum += val; // equivalent to sum = sum + val 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} for 循环后面如果不加花括号，那么，for 循环中只会执行一条语句，\n1#include \u0026lt;iostream\u0026gt; 2int main() { 3 int sum = 0; 4 // sum values from1 through 10 inclusive 5 for (int val = 1; val \u0026lt;= 10; ++val) 6 sum += val; // equivalent to sum = sum + val 7 sum += 100; 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} 11// output: 155 我们再来看加了花括号的效果，\n1#include \u0026lt;iostream\u0026gt; 2int main() { 3 int sum = 0; 4 // sum values from1 through 10 inclusive 5 for (int val = 1; val \u0026lt;= 10; ++val) { 6 sum += val; // equivalent to sum = sum + val 7 sum += 100; 8 } 9 std::cout \u0026lt;\u0026lt; \u0026#34;Sum of 1 to 10 inclusive is \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 10 return 0; 11} 12// output: 1055 Part3 读取输入 读取输入数据。\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int sum = 0, value = 0; 5 // read until end-of-file, calculating a running total of all values read 6 while (std::cin \u0026gt;\u0026gt; value) 7 sum += value; // equivalent to sum = sum + value 8 std::cout \u0026lt;\u0026lt; \u0026#34;Sum is: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; 9 return 0; 10} 从键盘输入文件结束符(EOF, end of file)这里，书上说的是在 Windows 下，输入文件结束符的方法是敲 Ctrl + Z，然后按回车键，但是在上面这个程序中无法体现，因为我们只要输入的不是一个 int 值，循环就会结束，比如，我们输入 Ctrl + D 然后回车也是可以的。所以，我们可以单独写一个程序来验证一下这个文件结束符，\n1// 测试一下 Windows 下 Ctrl + Z 然后回车是否是 EOF 2#include \u0026lt;cstdio\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4 5int main() 6{ 7 int x; 8 if ((x = std::cin.get()) == EOF) 9 { 10 std::cout \u0026lt;\u0026lt; \u0026#34;Here is an EOF.\u0026#34; \u0026lt;\u0026lt; std::endl; 11 } 12 return 0; 13} 同时，这一小节中，书上还介绍了编写程序时会导致的一些编译错误，这里具体演示一下，\n语法错误 类型错误 声明错误 首先是语法错误，\n然后是类型错误，比如，\n1int a = \u0026#34;this is a string\u0026#34;; 然后是声明错误，\n1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 int v1 = 0, v2 = 0; 5 std::cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; v2; // error: uses \u0026#34;v\u0026#34; not \u0026#34;v1\u0026#34; 6 // error: cout not defined; should be std::cout 7 cout \u0026lt;\u0026lt; v1 + v2 \u0026lt;\u0026lt; std::endl; 8 return 0; 9} Part4 if 1#include \u0026lt;iostream\u0026gt; 2int main() 3{ 4 // currVal is the number we’re counting; we’ll read new values into val 5 int currVal = 0, val = 0; 6 // read first number and ensure that we have data to process 7 if (std::cin \u0026gt;\u0026gt; currVal) 8 { 9 int cnt = 1; // store the count for the current value we’re processing 10 while (std::cin \u0026gt;\u0026gt; val) 11 { // read the remaining numbers 12 if (val == currVal) // if the values are the same 13 ++cnt; // add 1 to cnt 14 else 15 { // otherwise, print the count for the previous value 16 std::cout \u0026lt;\u0026lt; currVal \u0026lt;\u0026lt; \u0026#34; occurs \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; std::endl; 17 currVal = val; // remember the new value 18 cnt = 1; // reset the counter 19 } 20 } // while loop ends here 21 // remember to print the count for the last value in the file 22 std::cout \u0026lt;\u0026lt; currVal \u0026lt;\u0026lt; \u0026#34; occurs \u0026#34; \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; times\u0026#34; \u0026lt;\u0026lt; std::endl; 23 } // outermost if statement ends here 24 return 0; 25} 26// input: 42 42 42 42 42 55 55 62 100 100 100 ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-4/","summary":"\u003cp\u003e这一集视频我们主要来看一下 C++ Primer 1.4 节。\u003c/p\u003e\n\u003cp\u003e主要是对几个常用的控制流的语句进行说明，包括，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ewhile 循环\u003c/li\u003e\n\u003cli\u003efor 循环\u003c/li\u003e\n\u003cli\u003e读取输入\u003c/li\u003e\n\u003cli\u003eif 语句\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们这里的讲解主要是对书上示例的代码进行相应的解析，对于大家容易理解的知识点，就不去花费多余的时间来说明。删繁就简，同时，不漏疑难点。\u003c/p\u003e","title":"C++ Primer 第五版 1.4 控制流 笔记"},{"content":"《算法竞赛入门经典》(第二版) 第 6 章例题 6-1。\n题目描述 英文描述 Programs executed concurrently on a uniprocessor system appear to be executed at the same time, but in reality the single CPU alternates between the programs, executing some number of instructions from each program before switching to the next. You are to simulate the concurrent execution of up to ten programs on such a system and determine the output that they will produce.\nThe program that is currently being executed is said to be running, while all programs awaiting execution are said to be ready. A program consists of a sequence of no more than 25 statements, one per line, followed by an end statement. The statements available are listed below.\nA variable is any single lowercase alphabetic character and a constant is an unsigned decimal number less than 100. There are only 26 variables in the computer system, and they are shared among the programs. Thus assignments to a variable in one program affect the value that might be printed by a different program. All variables are initially set to zero.\nEach statement requires an integral number of time units to execute. The running program is permitted to continue executing instructions for a period of time called its quantum. When a program’s time quantum expires, another ready program will be selected to run. Any instruction currently being executed when the time quantum expires will be allowed to complete.\nPrograms are queued first-in-first-out for execution in a ready queue. The initial order of the ready queue corresponds to the original order of the programs in the input file. This order can change, however, as a result of the execution of lock and unlock statements.\nThe lock and unlock statements are used whenever a program wishes to claim mutually exclusive access to the variables it is manipulating. These statements always occur in pairs, bracketing one or more other statements. A lock will always precede an unlock, and these statements will never be nested. Once a program successfully executes a lock statement, no other program may successfully execute a lock statement until the locking program runs and executes the corresponding unlock statement. Should a running program attempt to execute a lock while one is already in effect, this program will be placed at the end of the blocked queue. Programs blocked in this fashion lose any of their current time quantum remaining. When an unlock is executed, any program at the head of the blocked queue is moved to the head of the ready queue. The first statement this program will execute when it runs will be the lock statement that previously failed. Note that it is up to the programs involved to enforce the mutual exclusion protocol through correct usage of lock and unlock statements. (A renegade program with no lock/unlock pair could alter any variables it wished, despite the proper use of lock/unlock by the other programs.)\nInput\nThe input begins with a single positive integer on a line by itself indicating the number of the cases following, each of them as described below. This line is followed by a blank line, and there is also a blank line between two consecutive inputs.\nThe first line of the input file consists of seven integers separated by spaces. These integers specify (in order): the number of programs which follow, the unit execution times for each of the five statements (in the order given above), and the number of time units comprising the time quantum. The remainder of the input consists of the programs, which are correctly formed from statements according to the rules described above.\nAll program statements begin in the first column of a line. Blanks appearing in a statement should be ignored. Associated with each program is an identification number based upon its location in the input data (the first program has ID = 1, the second has ID = 2, etc.).\nOutput\nFor each test case, the output must follow the description below. The outputs of two consecutive cases will be separated by a blank line.\nYour output will contain of the output generated by the print statements as they occur during the simulation. When a print statement is executed, your program should display the program ID, a colon, a space, and the value of the selected variable. Output from separate print statements should appear on separate lines.\nSample Input\n3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end Sample Output\n1: 3 2: 3 3: 17 3: 9 1: 9 1: 9 2: 8 2: 8 3: 21 3: 21 题目全文·中文翻译 在单处理器系统上并发执行的程序看起来像是同时执行的，但实际上单个 CPU 在多个程序之间交替执行，在切换到下一个程序之前，每个程序执行一定数量的指令。你需要模拟最多十个程序在这种系统上的并发执行，并确定它们将产生的输出。\n当前正在执行的程序称为“运行中”，而所有等待执行的程序称为“就绪”。一个程序由不超过 25 条语句的序列组成，每行一条语句，最后以一个结束语句结尾。可用的语句列在下面。\n一个变量是任何单个的小写字母字符，常量是小于 100 的无符号十进制数。系统中只有 26 个变量(按：也就是 26 个英文字母)，并且这些变量在所有程序中共享。因此，一个程序中对变量的赋值会影响其他程序可能打印的值。所有变量初始值均为零。\n每条语句的执行都需要一个整数量的时间单位。运行中的程序被允许在一个称为“时间片”的时间段内继续执行指令。当程序的时间片耗尽时，将选择另一个就绪程序来运行。当时间片到期时，正在执行的指令会被允许完成。\n程序按照先进先出的顺序排队执行，就绪队列的初始顺序与输入文件中的程序顺序相对应。然而，由于锁（lock）和解锁（unlock）语句的执行，这一顺序可能发生变化。\n当一个程序希望对其操作的变量进行互斥访问时，会使用锁和解锁语句。这些语句总是成对出现，包围一个或多个其他语句。锁语句总是先于解锁语句执行，并且这些语句不会嵌套。一旦程序成功执行锁语句，其他程序在锁定程序运行并执行相应的解锁语句之前，无法成功执行锁语句。如果一个正在运行的程序在已有锁生效时尝试执行锁语句，该程序将被放置到阻塞队列的末尾。以这种方式被阻塞的程序会失去当前剩余的时间片。当解锁语句执行时，阻塞队列头部的程序会被移到就绪队列的头部。该程序在运行时执行的第一条语句将是之前失败的锁语句。需要注意的是，互斥协议的实施依赖于程序通过正确使用锁和解锁语句来实现。（一个不遵循锁/解锁规则的流氓程序仍然可以随意修改任何变量，尽管其他程序正确使用了锁/解锁语句。）\n输入\n输入以一行包含单个正整数的行开始，表示接下来要处理的测试用例数量，每个测试用例如以下所述。该行后有一行空行，两个连续输入之间也有一行空行。\n输入文件的第一行由七个用空格分隔的整数组成。这些整数按顺序指定：后续程序的数量、五条语句的单位执行时间（按上述顺序）、以及构成时间片的时间单位数。输入的其余部分由程序组成，这些程序根据上述规则正确由语句组成。\n所有程序语句都从行的第一列开始。语句中的空格应被忽略。每个程序都有一个与其在输入数据中的位置相关的标识号（第一个程序的 ID = 1，第二个程序的 ID = 2，以此类推）。\n输出\n对于每个测试用例，输出必须遵循以下描述。两个连续测试用例的输出之间应有一个空行。\n你的输出应包含在模拟过程中由 print 语句生成的输出。当 print 语句被执行时，程序应显示程序 ID、一个冒号、一个空格，以及被选变量的值。不同 print 语句的输出应分别显示在不同的行上。\n输入样例\n3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end 输出样例\n1: 3 2: 3 3: 17 3: 9 1: 9 1: 9 2: 8 2: 8 3: 21 3: 21 注意：这里的输入样例是有问题的，修正后如下：\n1 3 1 1 1 1 1 1 a = 4 print a lock b = 9 print b unlock print b end a = 3 print a lock b = 8 print b unlock print b end b = 5 a = 17 print a print b lock b = 21 print b unlock print b end 思路分析 核心的思路就是模拟。所需要使用的数据结构是队列。普通队列和双端队列都需要。\n好吧，其实这题的关键是理解题意。看懂输入输出要干什么就可以了。\n我们先来看输入，\n第一行的 1 表示有接下来有一个 case 需要我们去处理，然后接下来的下一行是空行，这是固定的格式要求，然后，下一行是\n13 1 1 1 1 1 1 其中，3 表示接下来有 3 个 program 要并行运行。然后，\n第一个 1：赋值(Assignment)语句花费的时间。 第二个 1：输出(Output)语句花费的时间。 第三个 1：锁(lock)语句花费的时间。 第四个 1：解锁(unlock)语句花费的时间。 第五个 1：结束(end)语句花费的时间。 最后的 1 表示：cpu 会分配的时间片的长短。\n关于对题目的理解，有个地方需要注意一下，\n当时间片到期时，正在执行的指令会被允许完成。\n比如某个语句(指令)执行主要 4 个单位的时间，但是当前被分配的时间片只剩 2 个单位了，没关系，这个语句依旧会被执行。\n书中还提出了一个问题：本题不会出现越界错误，为什么？这是因为在执行插入到队首这个动作之前，队首的元素已经被 pop 出来进行处理了，所以队首总是空着一个位置的，这时如果想要插入一个元素到队首，自然不会发生越界的情况。\n那么，本题的思路，说起来其实很简单：\n先把所有的程序按照输入的顺序放入 ready 队列中； 然后，逐个从队列中 pop 出程序进行处理。 具体的处理过程如下，\n如果当前这次时间片用完了，但是程序还没有执行完，那么，记录当前执行到的位置，再将程序放入 ready 队列中； 当前运行到了程序结尾，此程序生命周期结束，无需额外操作； 如果遇到了 lock 语句，那么，根据当前是否有其他程序上了锁来进行处理； 如果已经被上锁，那么，将当前程序放入 block 队列，时间片如果还没用完，那么，也作废了； 如果还没有被上锁，那么，进行上锁操作(这里其实就是设置以下 locked 这个全局变量)，然后还是正常执行； 如果遇到了 unlock， 如果阻塞队列不为空，出队一个元素，然后，入队到 ready 的队首； 接下来还是正常运行。 代码分析 代码分析就全部在注释里面了。如果觉得不够清晰，那就再听一听我视频里面的讲解。\n主要就三个部分。\n全局变量定义 1const int maxlinecnt = 1000; // 最多 1000 行，这是一个大致的数量 2const int linecharcnt = 10; // 每一行的字符串长度不会超过 10(按：这是推断出来的，我们假定程序中没有过多的空格，否则这里就还需要再调整) 3 4deque\u0026lt;int\u0026gt; readyQ; // ready 队列 5queue\u0026lt;int\u0026gt; blockQ; // 存放被阻塞的程序的队列 6int n; // 会参与并行运行的程序的数量 7int quantum; // 时间片长度 8int c[5]; // 每个语句所需的运行时间 9int var[26]; // 最多 26 个变量 10int ip[maxlinecnt]; // ip[pid]是程序pid的当前行号。所有程序都存在prog数组，更类似真实的情况，代码也更短 11bool locked; // 是否已经被锁住 12char prog[maxlinecnt][linecharcnt]; // 存储所有程序的指令，每个程序的每条指令都是一行字符串 主要的模拟函数 1void run(int pid) { 2 int q = quantum; 3 while (q \u0026gt; 0) { 4 char *p = prog[ip[pid]]; // 取出 pid 号程序中当前该运行的那一行 5 switch (p[2]) { // 根据第 3 个字符来判断 6 case \u0026#39;=\u0026#39;: // 赋值 7 var[p[0] - \u0026#39;a\u0026#39;] = isdigit(p[5]) ? (p[4] - \u0026#39;0\u0026#39;) * 10 + p[5] - \u0026#39;0\u0026#39; : p[4] - \u0026#39;0\u0026#39;; 8 q -= c[0]; 9 break; 10 case \u0026#39;i\u0026#39;: // 打印 11 printf(\u0026#34;%d: %d\\n\u0026#34;, pid + 1, var[p[6] - \u0026#39;a\u0026#39;]); 12 q -= c[1]; 13 break; 14 case \u0026#39;c\u0026#39;: // lock 15 if (locked) { 16 blockQ.push(pid); // 放入阻塞队列 17 return; 18 } 19 locked = true; 20 q -= c[2]; 21 break; 22 case \u0026#39;l\u0026#39;: // unlock 23 locked = false; 24 if (!blockQ.empty()) { 25 int pid2 = blockQ.front(); 26 blockQ.pop(); 27 readyQ.push_front(pid2); 28 } 29 q -= c[3]; 30 break; 31 case \u0026#39;d\u0026#39;: // end 32 return; 33 } 34 ip[pid]++; 35 } 36 readyQ.push_back(pid); 37} main 函数 主要是做一些数据的读入操作。\n1int main() { 2 // 重定向输入数据，省去我们手动输入的繁琐 3 string relativePathToCurrentCFile = \u0026#34;./data/UVa210/input1.txt\u0026#34;; 4 // relativePathToCurrentCFile = \u0026#34;./data/UVa210/input3.txt\u0026#34;; 5 freopen(string(\u0026#34;./ch06\u0026#34; + relativePathToCurrentCFile.substr(1, relativePathToCurrentCFile.size() - 1)).c_str(), \u0026#34;r\u0026#34;, stdin); 6 7 int T; // input 数据中 case 的数量 8 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 9 while (T--) { // 分别处理每一个 case 10 scanf(\u0026#34;%d %d %d %d %d %d %d\\n\u0026#34;, \u0026amp;n, \u0026amp;c[0], \u0026amp;c[1], \u0026amp;c[2], \u0026amp;c[3], \u0026amp;c[4], \u0026amp;quantum); 11 memset(var, 0, sizeof(var)); 12 13 int line = 0; 14 for (int i = 0; i \u0026lt; n; i++) { 15 fgets(prog[line++], maxlinecnt, stdin); // 按行读取数据 16 ip[i] = line - 1; 17 while (prog[line - 1][2] != \u0026#39;d\u0026#39;) 18 fgets(prog[line++], linecharcnt, stdin); 19 readyQ.push_back(i); // 把 id 为 i 的程序入队 20 } 21 22 locked = false; // 初始值为 false 23 while (!readyQ.empty()) { 24 int pid = readyQ.front(); 25 readyQ.pop_front(); 26 run(pid); 27 } 28 if (T) 29 printf(\u0026#34;\\n\u0026#34;); 30 } 31 return 0; 32} ","permalink":"http://localhost:1313/posts/uva210/","summary":"UVa210 解题思路及代码解析","title":"UVa210"},{"content":"这一集视频我们主要来看一下 C++ Primer 1.3 节。\n从这一集视频开始，我将继续采取挑取核心重点的形式来进行解说。如果是很简单的东西，那么会简单带过，如果是需要注意或者不容易理解的细节，那么，也绝对不会漏掉。这样一来，可以一定程度上保证信息密度。整体会结合我记录的笔记来和大家讲解。当然，书中所给出的每一处示例代码，都不会跳过，这一点也请大家放心。\n并且，从这一节开始，我们将采用 CMake 来作为我们代码的构建工具，这样，我们就可以进一步把精力集中在语言学习本身了。\n这一节介绍了 C++ 的注释，内容很少。需要理解的地方，就两个点，\n单行注释 多行注释 这里，仔细看书上的示例代码，理解一下就好。\n1#include \u0026lt;iostream\u0026gt; 2/* 3 * Simple main function: 4 * Read two numbers and write their sum 5 */ 6int main() { 7 // 提示用户输入两个数 8 std::cout \u0026lt;\u0026lt; \u0026#34;Enter two numbers:\u0026#34; \u0026lt;\u0026lt; std::endl; 9 int v1 = 0, v2 = 0; // 保存我们读入的输入数据的变量 10 std::cin \u0026gt;\u0026gt; v1 \u0026gt;\u0026gt; v2; // 读取输入数据 11 std::cout \u0026lt;\u0026lt; \u0026#34;The sum of \u0026#34; \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; v2 \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; v1 + v2 \u0026lt;\u0026lt; std::endl; 12 return 0; 13} 然后，对于单行注释，大家放心去用即可：单行注释以双斜线（//）开始，以换行符结束。// 后面可以接任何的字符，那么，当然也包括 // 本身。\n对于多行注释，也就是用注释界定符的这个注释，需要注意一下不能嵌套。我们实际看一个例子就明白了。\n1// 不能像下面这样有嵌套，会报错 2/* 3 * 注释对 /* */ 不能嵌套 4 * “不能嵌套”几个字会被认为是源码 5 * 像剩余程序一样处理 6 */ 7int main() 8{ 9 return 0; 10} 需要注意一点，/* */ 形式的注释也可以用于单行注释。这里我们也来看一个例子，\n1int main() 2{ 3 /* 也可以用作单行注释 */ 4 return 0; 5} ","permalink":"http://localhost:1313/posts/cpp-primer-ch01-3/","summary":"\u003cp\u003e这一集视频我们主要来看一下 C++ Primer 1.3 节。\u003c/p\u003e\n\u003cp\u003e从这一集视频开始，我将继续采取挑取核心重点的形式来进行解说。如果是很简单的东西，那么会简单带过，如果是需要注意或者不容易理解的细节，那么，也绝对不会漏掉。这样一来，可以一定程度上保证信息密度。整体会结合我记录的笔记来和大家讲解。当然，书中所给出的每一处示例代码，都不会跳过，这一点也请大家放心。\u003c/p\u003e","title":"C++ Primer 第五版 1.3 注释简介 笔记"},{"content":"本文假定读者的 Linux 环境为 Arch Linux + KDE。\nKitty 重要程度：必装。\n直接命令行安装，\n1yay -S kitty fish 重要程度：必装。\n直接命令行安装，\n1yay -S fish kitty 和 fish 安装好之后，其实就基本可以使用了。\ngcc 重要程度：必装。\n直接命令行安装，\n1yay -S gcc CMake 重要程度：必装。\n直接命令行安装，\n1yay -S cmake VSCode 重要程度：必装。\n直接命令行安装，\n1yay -S visual-studio-code-bin 安装好之后，安装几个插件，\nclangd CMake 然后，可以把 VSCode 的默认的 shell 设置成 fish。这个直接在 settings.json 配置文件中加一行配置即可，\n1\u0026#34;terminal.integrated.defaultProfile.linux\u0026#34;: \u0026#34;fish\u0026#34;, 然后，就可以新建一个项目试一下使用了。\n如果有遇到 cmake 插件让选择编译器的，记得选择 gcc，\nNeovim 首先，安装一些必要的软件，\n1yay -S nodejs 2yay -S npm 3yay -S p7zip 4yay -S bottom 5yay -S fastfetch 6yay -S fd 7yay -S gitui 8yay -S grep 9yay -S ripgrep 10yay -S starship 然后，在命令行中复制我的 neovim 配置，\n1git clone https://github.com/fanlumaster/lazyvim-archlinux.git ~/.config/nvim 然后，运行 neovim，\n1nvim 然后，在 nvim 中使用 mason 安装 clangd，\n1:MasonInstall clangd 这样一来，环境差不多就配置好了。\n对于 Linux 用户，我想对命令行应该都不陌生，所以，就不去讲配置 starship 这种比较简单的操作了。\n","permalink":"http://localhost:1313/posts/cpp-coding-environment-configuration-linux-version/","summary":"\u003cp\u003e本文假定读者的 Linux 环境为 Arch Linux + KDE。\u003c/p\u003e\n\u003ch2 id=\"kitty\"\u003eKitty\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e直接命令行安装，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eyay -S kitty\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"fish\"\u003efish\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e直接命令行安装，\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e1\u003c/span\u003e\u003cspan class=\"cl\"\u003eyay -S fish\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ekitty 和 fish 安装好之后，其实就基本可以使用了。\u003c/p\u003e","title":"Linux 系统下的 C++ 编程环境配置"},{"content":"Windows Terminal 重要程度：必装。\n到微软的应用商店中找到 Windows Terminal 和 Windows Terminal Perivew(预览版) 任意选择一个即可。\nPowershell7.0+ 重要程度：必装。\n下载地址：https://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\n选择这个 msi 文件进行下载，然后安装，一路默认下一步即可,\n安装好了之后，可以在 Windows Terminal 中设置一下默认启动 powershell7。\nCMake 重要程度：必装。\n前提：解决了网络的问题。\n首先，通过 scoop 安装 cmake。\n如果还没有安装 scoop，请先到 scoop 的官网安装。\n然后，执行安装命令，\n1scoop install cmake Visual Studio 篇 重要程度：必装。\n因为是需要 C++ 编译套件，所以把使用C++的桌面开发勾选上即可。需要勾选的选项，直接看我下面的截图，\nVisual Studio 直接在初始界面创建 CMake 项目即可。\nVSCode 篇 重要程度：选装。\n来到VSCode官网界面进行下载。\n下载好之后，直接一路下一步，全部按默认的来，因为现在已经 2024 年了，大家的 C 盘没有 1T 也至少 512GB 起步了，不差空间。\n安装好之后，安装几个插件，\nC/C++ CMake 然后，可以把 VSCode 的默认的 shell 设置成 powershell7。\n安装好之后，就可以写简单的 C++ 程序测试一下了。\n1#include \u0026lt;iostream\u0026gt; 2 3int main(int, char**){ 4 std::cout \u0026lt;\u0026lt; \u0026#34;哟西！\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 5} CLion 篇 重要程度：选装。\n来到官网下载安装。\n大家可以自行使用破解或者试用。\n之后新建一个项目就可以开始编写代码了。\nNeovim 篇 重要程度：选装。\n安装 Neovim，\n1scoop install neovim 安装一些常用的软件，\n1scoop install neovide 2scoop install 7zip 3scoop install bottom 4scoop install btop 5scoop install fastfetch 6scoop install fd 7scoop install gitui 8scoop install grep 9scoop install gsudo 10scoop install make 11scoop install nodejs 12scoop install ripgrep 13scoop install starship 14scoop install vcredist2022 15scoop install which 然后到 pwsh(即 powershell)复制我的 neovim 配置，\n1git clone https://github.com/fanlumaster/FanyLazyvim.git $env:LOCALAPPDATA\\nvim 然后，打开 neovim 等待其自动下载插件，配置一会儿即可，\n1nvim 然后，在 nvim 中使用 mason 安装 clangd，\n1:MasonInstall clangd 这样一来，环境差不多就配置好了。\n然后，还可以稍微配置一下 powershell，这里就简单设置一下 starship，\n1nvim $PROFILE 1Invoke-Expression (\u0026amp;starship init powershell) 参考：\n1、https://www.lazyvim.org/installation\n","permalink":"http://localhost:1313/posts/cpp-coding-environment-configuration-windows-version/","summary":"\u003ch2 id=\"windows-terminal\"\u003eWindows Terminal\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e到微软的应用商店中找到 Windows Terminal 和 Windows Terminal Perivew(预览版) 任意选择一个即可。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://i.postimg.cc/VmjKSpKC/image.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"powershell70\"\u003ePowershell7.0+\u003c/h2\u003e\n\u003cp\u003e重要程度：\u003cstrong\u003e必装\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e下载地址：\u003ca href=\"https://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\"\u003ehttps://github.com/PowerShell/PowerShell/releases/tag/v7.4.5\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e选择这个 msi 文件进行下载，然后安装，一路默认下一步即可,\u003c/p\u003e","title":"Windows 系统下的 C++ 编程环境配置"},{"content":"Hey 朋友们，今天我们来聊一期系列介绍的视频。\n谈一谈我接下来将要在 B 站投稿的 C++ Primer 第五版的系列视频。\n名字叫：【大学生】《C++ Primer》精读精讲\n面向人群 大学生。尤其是大一大二的学生。不限于计算机相关专业，不限文理科。计算机领域是相当包容的。因为是相当于入门课程，所以可能会比较啰唆，甚至是照本宣科，所以，高年级的同学可能没有那么多时间来观看，以及，以高年级同学的知识储备来讲，可能内容偏基础。\n我希望大家准备的东西 一台电脑。无论是运行 Windows11/10 还是 Linux 的电脑，都可以。 畅通的网络，即可以流畅地访问 Google、GitHub、Stackoverflow 等等。限于某些原因，我无法在这里给大家讲解这部分的内容，但相信大家在网上应该可以找到对应的材料，实在不行，让身边的小伙伴手把手教一下请他/她吃顿饭也成。 为什么想要出这一个系列的视频 《C++ Primer》这本书用来打基础是相当好的，但是，这本书有一个缺点，也是我认为的惟一的缺点，那就是，有那么一丢丢阅读的门槛。我相信，很多人都听说过这本书，也读过这本书，但是，真正能把这本书读完的，十中无一。我以前也没有读完，最近重新捡起来读，花费了一个月，每天大概读四五个小时，最终是把这本书读完了。也正是因为仔细读了一遍下来，才知道这本书确实是真正地好书，也就促成了我录这个视频来分享交流的契机。\n所以，我这一系列的视频，就是为了打破这个门槛。让初入校园或者刚接触编程或者刚接触 C++ 的同学能够破除阻碍，读下这本书，从而为自己的爱好打下一个良好的基础。\n使用的教材以及获取方式 教材当时是视频标题的这本《C++ Primer》第五版啦。这本书是十年前出版的，但是，我读完之后，发现其中的内容鞭辟入里，放在今天一点也不过时，同时，结合国内外的评论，发现大家的看法也都是类似的，那就是，推荐。\n豆瓣上的评分：https://book.douban.com/subject/10505113/。\n获取方式如下，\n英文版：\nhttps://zhjwpku.com/assets/pdf/books/C++.Primer.5th.Edition_2013.pdf 中文版：\nC++ Primer 中文版·第五版 或者，有条件的直接到微信读书开一个会员即可。 也可以到以下网站去检索一下：\nzlibrary 安娜的档案 我讲解的方式 对于重要的文本，逐字逐句讲解，不落下。 对于书中出现的示例代码，一个不落，全部拓展成完整的可以运行的源文件进行测试。并且，全部在视频中手动编写、编译(包括借助 IDE)、运行。代码编排的顺序大概以英文版的页码为主。 有时候可能会结合其他材料，比如：网上的技术博客、cppreference 网站、GitHub 讨论区、stackoverflow、reddit 论坛的讨论等等。 对于习题，尽量全部讲解，但是更新的速度可能比主要的章节要慢一些。视频主要的节奏还是以非习题的主体部分为主。 我的想法还是，以代码为主，希望大家能够跟我一起边看边敲。有我的视频在，大家在编写、编译、调试、运行代码的过程中，基本上是不会有什么问题的，这样就可以把精力集中在学习编程语言本身这个事情上来。\n这里还是要多说一点，就是，我讲解的内容只能保证尽量通俗，大家额外该看的资料肯定是不能少的。也希望大家多多给我提意见，我会不断改进，有好的建议我会做成补充视频的形式，供大家参考。\n我演示编写代码的工具 编译套件 命令行或者 CMake。对于演示和学习而言，这两者足够简单并且够用。\nCMake 现在也是编写 C++ 大型项目的主流工具，不过，我们在学习的过程中只会用到很简单很简单的一小部分。\n具体到编译器，那么，在 Windows 中使用微软家的 MSVC 编译套件系列；在 Linux 中使用 gcc/g++ 套件。\n操作系统 Windows11 Arch Linux KDE(wayland) 代码编辑器/IDE 主要是 Neovim + Neovide。然后借助 Powershell 脚本或者 shell 脚本来自动化 CMake 的编译过程，然后运行。\n我的 Neovim 配置是公开的，我把它们放在了我另一个 GitHub 帐号中：\nWindows 中的 Neovim 配置：https://github.com/fanlumaster/FanyLazyvim Linux 中的 Neovim 配置：https://github.com/fanlumaster/lazyvim-archlinux 会介绍 VSCode、Visual Studio、CLion 的使用，大家随意使用。\n我自己除了在前期的编程环境配置视频中会使用 IDE 以外，后期应该都会使用 neovim 来进行代码编写。对于代码调试，在 Windows 端我会使用 Visual Studio 或者 VSCode；在 Linux 我会使用 gdb 或者 VSCode。\n终端工具 或者，大家也可以称其为命令行工具。\nWindows 下，建议使用 Windows Terminal + Powershell7 Linux 下，建议使用 Kitty + fish 大家可能会有的一些疑问 有课时的顾虑吗？ 当然没有，这里不是大学，不是正式的老师，不用恪守严格的规则。所以，我个人对课时不设限制，不会有大学老师所说的因为课时压缩等等原因而去跳过一些内容。所以，书中所有的内容都会涉及。\n收费吗？可以转载吗？ 我都放在 B 站了(条件允许也会同步到 Youtube)，那当然是不会收费。并且，以后也不会收费。整本书的讲解都不会收费。我争取把整本书讲完，希望能够得到大家的支持。\n不管是视频还是博客，任何形式的转载、下载都是可以的，包括商业、非商业。当然，一定要注明出处哈。\n视频涉及到的文档和代码材料在哪里？ 所有的文稿都会放在我这个博客里面。并且在每个视频的简介里面附上 url 地址。\n视频中所涉及的代码材料，我都会放在我当前的这个 GitHub 中。\nup 主会讲解其他的编程语言或者算法题吗？ 大概率会。比如，我还有一些书想录制一些视频讲一下，比如，《流畅的 Python》第二版、《C 程序设计语言》K\u0026amp;R 第二版等。\n对于数据结构和算法相关，我也想录制一些《算法竞赛入门经典》第二版、《数据结构与算法分析 C 语言描述》这类的视频。\n总之，如果时间没有问题的话，我不打算给自己的题材设限。\n会有一些小项目之类的视频吗？ 会有的。目前的想法是先把一门完整的编程语言讲完，后续会录制项目相关视频。\n当然，希望大家不要有太多的期待。因为我并不会整一些培训班的项目，可能顶多就是一些小游戏、或者像是在屏幕中显示键盘按下的按键、中文输入法开发这样的小众的项目。这也和我录制这些视频的初衷相吻合，我录制视频的目的并非是面向找工作，而且希望大家真的能够为了自己喜欢的编程奉献一点时间。\n可以私信问 up 问题吗？ 当然可以，不过，更建议以评论的方式留言，这样，我漏掉的时候还会有其他朋友来帮助回答。\n欢迎多多评论。无论是在 B 站还是我这个博客下面。\n声明 本人水平有限，欢迎随便喷。可以在视频的评论区吐槽，可以在博客的评论区留言，如果有理有据，那当然是更好啦，承诺：遇到错误，一定修正。\n以及，有时间会做字幕，没空的时候就不加字幕了，望担待。\n好，本期视频的前言就介绍到这里，下一期视频，我们将讲解 Windows 和 Linux 系统中 C++ 编程环境的搭建。\n","permalink":"http://localhost:1313/posts/bilibili-cpp-primer-0-1-preface/","summary":"\u003cp\u003eHey 朋友们，今天我们来聊一期系列介绍的视频。\u003c/p\u003e\n\u003cp\u003e谈一谈我接下来将要在 B 站投稿的 C++ Primer 第五版的系列视频。\u003c/p\u003e\n\u003cp\u003e名字叫：【大学生】《C++ Primer》精读精讲\u003c/p\u003e\n\u003ch2 id=\"面向人群\"\u003e面向人群\u003c/h2\u003e\n\u003cp\u003e大学生。尤其是大一大二的学生。不限于计算机相关专业，不限文理科。计算机领域是相当包容的。因为是相当于入门课程，所以可能会比较啰唆，甚至是照本宣科，所以，高年级的同学可能没有那么多时间来观看，以及，以高年级同学的知识储备来讲，可能内容偏基础。\u003c/p\u003e","title":"Bilibili C++ Primer 精读精讲 ch0-1 前言"},{"content":"编程体验 CS 相关的同学比较感兴趣。\n首先看编程语言。\n简单起见，就稍微看一下 C++ 和 Python 这两门语言在 Arch + KDE 上的表现如何。\n然后，看编程工具。同时我们想要看一下代码的提示功能如何。\nNeovim: 弄潮儿，Neovide VSCode Godot 然后，是终端，\nkitty 日常工具 输入法 pdf 阅读工具 浏览器 goldendict 音乐体验 telegram ","permalink":"http://localhost:1313/posts/is-arch-kde-wayland-good-for-daily-use/","summary":"\u003ch2 id=\"编程体验\"\u003e编程体验\u003c/h2\u003e\n\u003cp\u003eCS 相关的同学比较感兴趣。\u003c/p\u003e\n\u003cp\u003e首先看编程语言。\u003c/p\u003e\n\u003cp\u003e简单起见，就稍微看一下 C++ 和 Python 这两门语言在 Arch + KDE 上的表现如何。\u003c/p\u003e\n\u003cp\u003e然后，看编程工具。同时我们想要看一下代码的提示功能如何。\u003c/p\u003e","title":"Arch Linux KDE 适合我们作为一个日常的操作系统去使用吗？"},{"content":"前言 首先，建议大家读一下原题目，题目的内容这里就不放了，大家可以到这个地址去下载: https://vjudge.net/problem/UVA-12569，有些人可能说英文不太好，那么，也没关系，除了查字典，现在还可以使用这个翻译插件：沉浸式翻译，总之，现在英语语言层面的问题是不会有问题的。\n为什么我建议大家读原题目呢？虽然我们大家接触到这个题目可能都是通过刘汝佳的这本《算法竞赛入门经典》才选择去看的，但是，书中给出的描述都是很略的，简单讲一点，题目很重要的输入和输出样例数据，书上一般都是没有的，其他的细节更不必说。大概就这样。\n然后，我们来详细研究一下 UVa12569 这道题的思路和解析。\n这道题整体的思路是 BFS。然后代码参考(可能有我的微小调整)的是《算法竞赛入门经典-习题与解答》的配套代码，GitHub 地址为：https://github.com/sukhoeing/aoapc-bac2nd-keys。\n此外，如果我们想要更多的测试数据，这个 udebug 的网站也是必不可少的：https://www.udebug.com。本题的测试数据地址为：https://www.udebug.com/UVa/12569。\n同时，我的代码托管在了这个地址：https://github.com/sonnycalcr/aoapc-homework。\n首先，这道题很多人可能觉得简单，我说一下我的观点：对于初学者或者算法初阶的同学来讲，这道题还是有很多值得学习的部分的。\n接下来，我挑一些关键的代码讲一下，更详细的解释在代码的注释里面。\n注意，在具体看/写代码之前，我们首先要明确一个点，题目中的编号是从 1 开始递增的，而下面我们的程序都是从 0 开始递增的。\nPart1 先看数据结构，一个是 Node，\n1struct Node { 2 int from, to; 3 Node *next; 4}; Node 是表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点，主要是用来在 State 类型中表示 path，也就是当前的状态是由上一个状态从 from 移动了机器人/石头到 to 而转化过来的。\nPart2 再看 State，\n1struct State { 2 Node *path; // 路径 3 int g; // 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 \u0026lt;= n \u0026lt;= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头 4 int len; // 路径长度，到了当前状态已经经历的长度 5 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 6 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } // 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头 7 inline void setRock(size_t i, bool val = true) { // 设置位置 i 上是否有石头 8 if (val) 9 g |= 1 \u0026lt;\u0026lt; (i + 4); // 位或操作来把第(i + 4)位来置 1 10 else 11 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); // 先取反，再用与操作来把第(i + 4)位来置 0 12 } 13 // 机器人的位置操作 14 inline int getP() const { return g \u0026amp; 15; } // 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置 15 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } // 设置机器人的位置，这里先右移再左移 4 位清除原有的数据 16}; 所谓的 State，就是当前的局面，由以下几个维度的数据构成，\npath 是路径，上面讲过了，其中保存了上一个状态转变到当前状态是移动了哪一个编号，然后又是移动到了哪一个编号，同时 next 指向了上一次状态的 path。 g 代表了整体的状态，其中，前 4 位(分别是：0, 1, 2, 3)二进制值作为一个整体可以转化成十进制，表示了当前机器人在哪个编号的位置；然后再往左取 16 位二进制 bit 位，其中每一位都代表了一个编号，比如，0 号位置的 bit 位是 (0 + 4)，也就是第 4 位，如果这一位为 1，则表示树中编号为 0 的位置上有石头，反之则没有，其它的编号依此类推。 len 表示从最原始的状态来到了当前的状态，一共走了多少步。 理解了上面的几个成员变量，就不难理解之后的几个成员函数了。\nPart3 我们再看输出运算符的重载，\n1// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的 2ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 3 if (p == NULL) 4 return os; 5 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; // 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号 6 return os; 7} 这里我们要注意，因为 Node 实际上是用来表示 State 中的 path 的，所以，并且，我们是到了最后成功到达终点时(看代码 109 行)直接打印最终的那个 State 的 path 的，而每一个 path 指向的又是上一个 State 的 path，所以，这个输出重载就达到了输出从初始的状态移动到最终目标的全部路径的目的。\nPart4 然后，我们看一下尝试移动机器人或者石头的思路，在这之前，我们先再来看一下全局变量，\n1const int MAXN = 16; // 节点的最大数量是 16，根据题目中的条件得来 2vector\u0026lt;int\u0026gt; G[MAXN]; // 图的邻接矩阵表示，题目中简化成了树(无环图) 3MemPool\u0026lt;Node\u0026gt; pool; // 链表节点分配，用 MemPool 比较好管理内存 4// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置 5// O: 每一个石头的位置编号 6// VIS: 表示某个位置是否已经 visited 过了 7int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 这个注释比较清晰了，就不多讲了。然后，让我们进入正题，来看 tryMove 这个函数，\n1// 尝试移动在点 from 上的物体(机器人或者石头) 2void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 3 int rp = s.getP(); // 获取当前状态下机器人的位置编号 4 for (auto to : G[from]) { 5 if ((to == rp) || s[to]) // to 和当前状态的机器人位置重合或者 to 的位置上有机器人 6 continue; 7 int ng = s.g; 8 if (from == rp) 9 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; // 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置 10 else 11 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); // 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置 12 if (VIS[ng]) 13 continue; // 新的状态已经访问过 14 VIS[ng] = 1; // 标记访问 15 // 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node 16 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 17 } 18} 因为 G 是邻接矩阵，我们可以利用这个特点来进行 for 循环，遍历与 from 顶点所邻接的几个顶点，尝试去移动到这些位置，然后就是一系列的细节处理，看注释比较容易理解。\nPart5 下面我们来看最终的核心的代码，\n1// bfs 2void solve() { 3 // 定义并初始化原始的状态 4 State s; 5 _for(i, 0, m) s.setRock(O[i]); 6 s.setP(S); 7 queue\u0026lt;State\u0026gt; q; 8 q.push(s); 9 VIS[s.g] = 1; // 标记当前机器人和石头的状态已经被访问过 10 // bfs 一层一层地遍历 11 while (!q.empty()) { 12 const State \u0026amp;st = q.front(); 13 int rp = st.getP(); 14 if (rp == T) { // 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数 15 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 16 return; 17 } 18 tryMove(st, rp, q); // 尝试移动机器人 19 _for(i, 0, n) if (st[i]) tryMove(st, i, q); // 尝试移动石头 20 q.pop(); 21 } 22 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; // 无法到达目的地 23} 这里就是一个纯粹的 bfs，我们定义好了原始的状态之后，然后利用队列这个数据结构一圈一圈地往外进行波纹扩散性地遍历，队列中从前往后存放的分别是第 1 圈、第 2 圈\u0026hellip;的数据，而且队列是先进先出(FIFO, First In First Out)，所以，我们可以暴力地遍历所有的情况，并且，可以保证，一旦第一次得到了想要的结果，那么，这个结果就是我们最终想要的结果。\n完整的代码和注释 以上就是关键的代码和解释了。其他的东西没什么好讲的。关于数据的输入和处理，上面也没有细讲，直接看注释即可。\n下面就是完整的代码和详细的注释：\n1#include \u0026lt;cmath\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4#include \u0026lt;queue\u0026gt; 5#include \u0026lt;vector\u0026gt; 6#include \u0026lt;fstream\u0026gt; 7 8#define _for(i, a, b) for (int i = (a); i \u0026lt; (b); ++i) 9 10using namespace std; 11 12int readint() { 13 int x; 14 cin \u0026gt;\u0026gt; x; 15 return x; 16} 17 18template \u0026lt;typename T\u0026gt; struct MemPool { 19 vector\u0026lt;T *\u0026gt; buf; 20 T *createNew() { 21 buf.push_back(new T()); 22 return buf.back(); 23 } 24 25 void dispose() { 26 for (int i = 0; i \u0026lt; buf.size(); i++) 27 delete buf[i]; 28 buf.clear(); 29 } 30}; 31 32const int MAXN = 16; // 节点的最大数量是 16 33 34struct Node { // 表示路径的链表节点，to 表示的是当前的节点，from 是上一个节点 35 int from, to; 36 Node *next; 37}; 38 39struct State { 40 Node *path; // 路径 41 int g; // 状态压缩，前 4 位(当然是从右往左)表示机器人🤖位置的编号，因为节点数 n 的范围是：4 \u0026lt;= n \u0026lt;= 15，后面 16 位的每一位用来表示位置 i 上是否有石头，比如，(2 + 4) 这个 bit 位为 1，就表示编号为 2 的位置上有石头 42 int len; // 路径长度，到了当前状态已经经历的长度 43 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 44 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } // 位置 i 上是否有石头，前 4 位被机器人占据了，往后的位才能用来表示石头 45 inline void setRock(size_t i, bool val = true) { // 设置位置 i 上是否有石头 46 if (val) 47 g |= 1 \u0026lt;\u0026lt; (i + 4); // 位或操作来把第(i + 4)位来置 1 48 else 49 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); // 先取反，再用与操作来把第(i + 4)位来置 0 50 } 51 // 机器人的位置操作 52 inline int getP() const { return g \u0026amp; 15; } // 与 1111(二进制) 进行与操作，取出前 4 位的值，也就是机器人的位置 53 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } // 设置机器人的位置，这里先右移再左移 4 位清除原有的数据 54}; 55 56vector\u0026lt;int\u0026gt; G[MAXN]; // 图的邻接矩阵表示，题目中简化成了树(无环图) 57MemPool\u0026lt;Node\u0026gt; pool; // 链表节点分配，用 MemPool 比较好管理内存 58// n: 顶点数；m: 障碍物(石头)数量；S: 源，即机器人的起点位置；T: 目标位置 59// O: 每一个石头的位置编号 60// VIS: 表示某个位置是否已经 visited 过了 61int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 62Node *newNode(Node *next = NULL, int u = -1, int v = -1) { 63 Node *p = pool.createNew(); 64 p-\u0026gt;next = next, p-\u0026gt;from = u, p-\u0026gt;to = v; 65 return p; 66} 67 68// 一个递归的输出，因为 tryMove 保证了最终到达终点时的状态中的 path 是递归地往前指的 69ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 70 if (p == NULL) 71 return os; 72 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; // 这里要把 from 和 to 分别加 1 来映射成题目中的从 1 开始的序号 73 return os; 74} 75 76// 尝试移动在点 from 上的物体(机器人或者石头) 77void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 78 int rp = s.getP(); // 获取当前状态下机器人的位置编号 79 for (auto to : G[from]) { 80 if ((to == rp) || s[to]) // to 和当前状态的机器人位置重合或者 to 的位置上有机器人 81 continue; 82 int ng = s.g; 83 if (from == rp) 84 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; // 把 s.g 的前 4 位置成 to 这个值，也就是移动机器人到 to 的位置 85 else 86 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); // 把 ng 的 from 对应的 bit 位置 0，然后把 to 对应的 bit 位置 1，也就是把石头从 from 位置移动到 to 这个位置 87 if (VIS[ng]) 88 continue; // 新的状态已经访问过 89 VIS[ng] = 1; // 标记访问 90 // 这里构建的新 State 的 newNode 的 next 属性指向的是移动前的 State 的 path Node 91 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 92 } 93} 94 95// bfs 96void solve() { 97 // 定义并初始化原始的状态 98 State s; 99 _for(i, 0, m) s.setRock(O[i]); 100 s.setP(S); 101 queue\u0026lt;State\u0026gt; q; 102 q.push(s); 103 VIS[s.g] = 1; // 标记当前机器人和石头的状态已经被访问过 104 // bfs 一层一层地遍历 105 while (!q.empty()) { 106 const State \u0026amp;st = q.front(); 107 int rp = st.getP(); 108 if (rp == T) { // 到达目的地，因为是 bfs，所以一旦到达目的地，也就表明是最短路径之一，后面不可能有移动步数更少的结果，最好的情况也是花费和当前一样的步数 109 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 110 return; 111 } 112 tryMove(st, rp, q); // 尝试移动机器人 113 _for(i, 0, n) if (st[i]) tryMove(st, i, q); // 尝试移动石头 114 q.pop(); 115 } 116 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; // 无法到达目的地 117} 118 119int main() { 120 // 重定向标准输入到文件 121 string relativePathToCurrentCppFile = \u0026#34;./data/UVa12569/input1.txt\u0026#34;; 122 // relativePathToCurrentCppFile = \u0026#34;./data/UVa12569/input2.txt\u0026#34;; 123 // 因为我们是在根目录下执行编译出来的可执行文件的 124 ifstream inputFile(\u0026#34;./ch07\u0026#34; + relativePathToCurrentCppFile.substr(1, relativePathToCurrentCppFile.size() - 1)); 125 if (!inputFile.is_open()) { 126 cerr \u0026lt;\u0026lt; \u0026#34;Failed to open input data file.\u0026#34; \u0026lt;\u0026lt; endl; 127 return 2; 128 } 129 streambuf *cinbuf = cin.rdbuf(); // save original buf 130 cin.rdbuf(inputFile.rdbuf()); 131 132 int K = readint(); // 读取 case 的数量，为了和 case 关键字区分，一般用 Kase 或者 K 来表示 case 133 for (int t = 1; t \u0026lt;= K; t++) { 134 memset(VIS, 0, sizeof(VIS)); // 初始化置 0 135 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; S \u0026gt;\u0026gt; T; // 读入 n m S T 136 --S; // 程序用到的编号要减 1 137 --T; // 同上 138 cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; 139 _for(i, 0, m) O[i] = readint() - 1; // 读入石头的编号，编号是从给的数据减 1 而得来 140 _for(i, 0, n) G[i].clear(); // 清除之前的数据 141 142 // 构建邻接矩阵 143 _for(i, 0, n - 1) { // 读入 n - 1 条边 144 int u = readint() - 1, v = readint() - 1; // 每一个顶点的编号都要减 1 145 G[u].push_back(v); 146 G[v].push_back(u); 147 } 148 149 solve(); 150 pool.dispose(); // 释放内存 151 cout \u0026lt;\u0026lt; endl; 152 } 153 154 // 恢复标准输入 155 cin.rdbuf(cinbuf); 156 return 0; 157} 纯净的代码 由于上面的代码我为了自己测试方便进行标准输入流重定向的处理，是不能直接提交的，所以，我在下面提供一份纯净的可以用于提交验证的代码，这里同时去除了所有的注释，因为中文字符似乎不被接受，\n1#include \u0026lt;cmath\u0026gt; 2#include \u0026lt;cstring\u0026gt; 3#include \u0026lt;iostream\u0026gt; 4#include \u0026lt;queue\u0026gt; 5#include \u0026lt;vector\u0026gt; 6 7#define _for(i, a, b) for (int i = (a); i \u0026lt; (b); ++i) 8 9using namespace std; 10 11int readint() { 12 int x; 13 cin \u0026gt;\u0026gt; x; 14 return x; 15} 16 17template \u0026lt;typename T\u0026gt; struct MemPool { 18 vector\u0026lt;T *\u0026gt; buf; 19 T *createNew() { 20 buf.push_back(new T()); 21 return buf.back(); 22 } 23 24 void dispose() { 25 for (int i = 0; i \u0026lt; buf.size(); i++) 26 delete buf[i]; 27 buf.clear(); 28 } 29}; 30 31const int MAXN = 16; 32 33struct Node { 34 int from, to; 35 Node *next; 36}; 37 38struct State { 39 Node *path; 40 int g; 41 int len; 42 State(int gi = 0, int li = 0, Node *pn = NULL) : g(gi), len(li), path(pn) {} 43 inline bool operator[](size_t i) const { return g \u0026amp; (1 \u0026lt;\u0026lt; (i + 4)); } 44 inline void setRock(size_t i, bool val = true) { 45 if (val) 46 g |= 1 \u0026lt;\u0026lt; (i + 4); 47 else 48 g \u0026amp;= ~(1 \u0026lt;\u0026lt; (i + 4)); 49 } 50 51 inline int getP() const { return g \u0026amp; 15; } 52 inline void setP(int p) { g = ((g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | p; } 53}; 54 55vector\u0026lt;int\u0026gt; G[MAXN]; 56MemPool\u0026lt;Node\u0026gt; pool; 57 58int n, m, S, T, O[MAXN], VIS[1 \u0026lt;\u0026lt; 19]; 59Node *newNode(Node *next = NULL, int u = -1, int v = -1) { 60 Node *p = pool.createNew(); 61 p-\u0026gt;next = next, p-\u0026gt;from = u, p-\u0026gt;to = v; 62 return p; 63} 64 65ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, Node *p) { 66 if (p == NULL) 67 return os; 68 os \u0026lt;\u0026lt; p-\u0026gt;next \u0026lt;\u0026lt; p-\u0026gt;from + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; p-\u0026gt;to + 1 \u0026lt;\u0026lt; endl; 69 return os; 70} 71 72void tryMove(const State \u0026amp;s, int from, queue\u0026lt;State\u0026gt; \u0026amp;q) { 73 int rp = s.getP(); 74 for (auto to : G[from]) { 75 if ((to == rp) || s[to]) 76 continue; 77 int ng = s.g; 78 if (from == rp) 79 ng = ((s.g \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 4) | to; 80 else 81 ng ^= (1 \u0026lt;\u0026lt; (from + 4)), ng ^= (1 \u0026lt;\u0026lt; (to + 4)); 82 if (VIS[ng]) 83 continue; 84 VIS[ng] = 1; 85 86 q.push(State(ng, s.len + 1, newNode(s.path, from, to))); 87 } 88} 89 90void solve() { 91 92 State s; 93 _for(i, 0, m) s.setRock(O[i]); 94 s.setP(S); 95 queue\u0026lt;State\u0026gt; q; 96 q.push(s); 97 VIS[s.g] = 1; 98 99 while (!q.empty()) { 100 const State \u0026amp;st = q.front(); 101 int rp = st.getP(); 102 if (rp == T) { 103 cout \u0026lt;\u0026lt; st.len \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; st.path; 104 return; 105 } 106 tryMove(st, rp, q); 107 _for(i, 0, n) if (st[i]) tryMove(st, i, q); 108 q.pop(); 109 } 110 cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; endl; 111} 112 113int main() { 114 int K = readint(); 115 for (int t = 1; t \u0026lt;= K; t++) { 116 memset(VIS, 0, sizeof(VIS)); 117 cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; S \u0026gt;\u0026gt; T; 118 --S; 119 --T; 120 cout \u0026lt;\u0026lt; \u0026#34;Case \u0026#34; \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; 121 _for(i, 0, m) O[i] = readint() - 1; 122 _for(i, 0, n) G[i].clear(); 123 124 _for(i, 0, n - 1) { 125 int u = readint() - 1, v = readint() - 1; 126 G[u].push_back(v); 127 G[v].push_back(u); 128 } 129 130 solve(); 131 pool.dispose(); 132 cout \u0026lt;\u0026lt; endl; 133 } 134 135 return 0; 136} 当然，这个代码也是可以在我的 GitHub 仓库中找到的。\n参考 1、《算法竞赛入门经典》第二版\n2、https://github.com/sukhoeing/aoapc-bac2nd-keys\n","permalink":"http://localhost:1313/posts/uva12569/","summary":"UVa12569 解题思路及代码解析","title":"UVa12569"},{"content":"这篇博客主要来聊一聊我在 Windows 端使用的终端和 Shell 软件。\n按：本篇博客大致上只是一个提纲，更详细的内容和使用体验在我的 B 站视频中，毕竟这东西不如直接用视频的形式展示出来比较直观。\n终端 Windows Terminal. Alacritty，这个之前使用过，后来放弃了。 Shell Windows 平台下也就是 pwsh7 这个软件了。其实也没什么太多好讲的，就简单介绍一下我目前使用的一些和终端相关的软件吧。\nPowerShell 7.0+ $PROFILE starship fastfetch scoop Neovim，关于 Neovim 的配置相关后面的视频中会讲，当前只是讲一下它的使用。 一些常用的命令。\n1ls 2cls 3cd 4cp 5tree 6Get-Command 如果想要一些快捷的命令的话，那么，可以去定制 pwsh 的配置文件，比如，去定制一些命令别名、函数之类。\n然后，还有一个小技巧，就是在 Neovim 中使用 pwsh，比较方便我们去复制一些内容。\n","permalink":"http://localhost:1313/posts/personal-likes-terminal-and-shell-in-windows/","summary":"\u003cp\u003e这篇博客主要来聊一聊我在 Windows 端使用的终端和 Shell 软件。\u003c/p\u003e\n\u003cp\u003e按：本篇博客大致上只是一个提纲，更详细的内容和使用体验在我的 B 站视频中，毕竟这东西不如直接用视频的形式展示出来比较直观。\u003c/p\u003e","title":"终端和 Shell 的使用之 Windows 篇"},{"content":"几个月前也简单安装过 Hyprland，在 nixos 发行版上。只是由于当时时间不够，就没有怎么深入去配置，导致最终的使用体验其实比较糟糕。所以最终是放弃了体验。\n最近时间比较多，刚好我的 KDE 出了点问题，所以，直接重装，WM(Windows Manager) 也换成了 hyprland，最终的体验还行。这里就简单分享一些我认为简易配置一下就可以获得的体验。\n提前说一下我的个人建议：好看，但不推荐。目前有太多的问题。\n按：本文更多面向的是 CS 专业在读学生，如果是非 CS 专业，但是对 CS 感兴趣、有实践的同学，那就更加 perfect 了。\n基本的使用的效果 就是一些平铺效果，这个没什么好说的。\n高分屏的适配 按照默认的配置来，其实还行。\n基本的编程软件 Kitty fish Neovim Neovide VSCode starship 这几个体验起来其实还行，只有 VSCode 需要开启 wayland 的标志，不然，缩放很有问题。\n美化和主题 暗色模式很有问题。比如，使用 dolphin，起界面调起来有一番难度。整个系统想要调整成暗色模式也很有难度。\n常用的工具 ags，标题栏和一些小组件的美化和定制。 rofi，这里我使用的 wayland 的版本，rofi-wayland，但是有一个问题：不能输入中文。 fcitx5，大部分应用是可以正常使用的。 chrome，开启了 wayland 的 flag 之后，使用起来还行。 edge，和 chrome 类似。 firefox，如果缩小到屏幕的 1/32，那么，缩放会出问题。 telegram，很不稳定。启动的时间长，缩放有一定问题，输入法偶尔失灵。 obs-studio，这个录屏的软件还是挺好用的。 很多缺失的工具 比如，截图软件，其实没有好用的。\n总结 我个人给出的结论是，不推荐使用这个系统。我们在使用一个系统的时候，其实是有很多事情要做的，因此，必须要有足够多的软件来支持，这一点 KDE 就做得非常好，而 hyprland 毕竟是一个年轻的 WM，所以，它在很多方面都有欠缺，因此，如果要作为我们的主系统的话，那么，它是很不合适的。不过，如果，仅仅是用来编写代码的副操作系统，大家大可以尝试一番，它的理念，也就是平铺式桌面的里面是相当优秀的。\n之前(大概是前天)也是因为 KDE 的 chrome 浏览器会导致 fcitx5 卡死，才一气之下换到了 hyprland，现在发现问题好像可以解决了。KDE 中的 chrome 默认使用的 x11 协议，那么，换成 wayland 其实就可以解决输入法的问题了。\n","permalink":"http://localhost:1313/posts/arch-linux-trying-hyprland/","summary":"\u003cp\u003e几个月前也简单安装过 Hyprland，在 nixos 发行版上。只是由于当时时间不够，就没有怎么深入去配置，导致最终的使用体验其实比较糟糕。所以最终是放弃了体验。\u003c/p\u003e","title":"Arch Linux Trying Hyprland"},{"content":"如何给 Kitty 设置主题呢？这个问题其实很简单，因为像这样成熟的 terminal 模拟器，必然有人在网上已经整理好了相关的 themes，通常只需要我们去 clone 一下就可以使用了。Kitty 就是如此。\n","permalink":"http://localhost:1313/posts/how-to-set-themes-for-kitty/","summary":"\u003cp\u003e如何给 Kitty 设置主题呢？这个问题其实很简单，因为像这样成熟的 terminal 模拟器，必然有人在网上已经整理好了相关的 themes，通常只需要我们去 clone 一下就可以使用了。Kitty 就是如此。\u003c/p\u003e","title":"How to Set Themes for Kitty"},{"content":"追根溯源，也就是速度、易用性和便携性。\n以前我是使用 Hexo 来建站的，而且，放到 Github 上面的是 hexo 最终渲染好的 html 文件之类，我现在发现这样特别笨重，尤其是在有多台 pc 的情况下，如果想要在不同的设备和操作系统之间进行写作，那么，这无疑是一件困难的事情。而且，每一次渲染造成的文件改动是很多的，这个在一定程度上是不利于版本管理的。而 Hugo 就很好地做到了这一点，利用 Github Actions 实现了文章与最终构建出来的产物进行分离，这样一来，我只需要把 markdown 文件托管到 Github 上面就可以了。对于 Hexo，我觉得应该也是可以做到这一点的，之所以没有去尝试，一方面懒了，另一方面，人总是想要尝试一点新鲜的东西，所以，这就转到了 Hugo。\n我之前其实建立过好多个基于 Github Pages 网站，其中，写得最多的，是这个站点，也是因为写得文章实在是有点多了，所以，hexo 在速度这一块的弊病就显现出来了，毕竟是基于 nodejs 的嘛。此外，我在之前的博客中使用的图床是 imgur，评论使用的是 disqus，这俩可谓是反面意义的卧龙凤雏了，速度都奇慢无比。有时候，imgur 的图片甚至加载不出来，应该是全球的服务器不够用。在速度这个层面上，postimage 和 Github Discussion 就要好很多，非常多。基本上只要搭了个梯子，那么，速度是没问题的。Hugo 本身由于 go 语言本身的性能，速度是相当快的，而且，在 Windows 上的表现比 Linux 中的表现差不了多少。目测 500 篇文章的生成速度应该可以保持在 5s 以内。\n","permalink":"http://localhost:1313/posts/why-i-build-another-github-pages-website/","summary":"\u003cp\u003e追根溯源，也就是速度、易用性和便携性。\u003c/p\u003e\n\u003cp\u003e以前我是使用 Hexo 来建站的，而且，放到 Github 上面的是 hexo 最终渲染好的 html 文件之类，我现在发现这样特别笨重，尤其是在有多台 pc 的情况下，如果想要在不同的设备和操作系统之间进行写作，那么，这无疑是一件困难的事情。而且，每一次渲染造成的文件改动是很多的，这个在一定程度上是不利于版本管理的。而 Hugo 就很好地做到了这一点，利用 Github Actions 实现了文章与最终构建出来的产物进行分离，这样一来，我只需要把 markdown 文件托管到 Github 上面就可以了。对于 Hexo，我觉得应该也是可以做到这一点的，之所以没有去尝试，一方面懒了，另一方面，人总是想要尝试一点新鲜的东西，所以，这就转到了 Hugo。\u003c/p\u003e","title":"谈一谈我为什么重新建立了一个 Github Pages 个人网站"},{"content":"前言 之前四五年的时间里也算写过五六百篇博客。以前的 Hexo 顶不住博客数量的压力了，所以，切到 Hugo 试一下。\n涉及工具 除了搭建博客和介绍如何使用这个博客框架这样一个流程本身，还包含了对 PaperMod 这个主题的一些细节的定制。\n本文涉及到的工具或者网站：\nhugo papermod github postimage giscus neovim/vscode git flaticon 为什么 这里主要解释一下为什么要选择这样一个组合。\n选择 hugo 纯粹是因为快。 选择 PaperMod 这个主题是因为它的 star 数量挺高的，不过，比起 hexo 的主题生态还是差得太远了，文档也相当简陋。不过，没办法，这已经算是最好的一档了。 博客选择托管在 github pages 上面是因为稳定，而且没有限制，基本上没有内容审查。我之前也使用 hexo 配合 github 搭建过静态博客，之前写过大概几百篇博客，从来没有遇到过内容审查，当然，也从来没有想过写一些很敏感的东西。 图床选择的是 postiamge，这个是免费的，类似的还有 imgur，但是 imgur 的图片加载速度在一些地方实在是堪忧甚至经常加载不出来，只好换上另一个有很多年头的网站了，正因为年纪大，所以给人的感觉是稳定。 评论使用 giscus 是因为快，因为也是使用 github 的服务，利用的是 github discussion，所以，比 discus 之类的小厂要快。稳定性倒是差不多。以及，github 的用户是比较多的，所以会更方便大家评论交流，这一点很重要。 neovim/vscode 是用来编辑配置用的，编辑工具/IDE这一点见仁见智。 git 不用多说了。 flaticon 是用来挑选网站的 favicon 的。 总结一下，就是几个词儿：免费、快、稳。\n安装 首先，安装 hugo，在 Windows 中，推荐使用 scoop 来安装预编译的二进制版本，\n1scoop install hugo-extended 安装完之后，执行命令看一下版本信息，\n1hugo version 看到类似下面的输出，就说明安装成功了，\n使用 创建博客 然后，我们就使用 hugo 在本地创建一个站点，也就是一个博客，\n按：这里可以参考 hugo 官网的指导。\n1hugo new site SonnyCalcr 然后，\n1cd SonnyCalcr 2tree . /f 可以看到默认创建的一些文件和目录，\n然后，我们先将此目录初始化成 git 仓库，\n1git init 2git add . 3git commit -m \u0026#34;first commit\u0026#34; 添加 PaperMod 主题 1git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 可以看到，这个命令执行完之后新增的内容，其实就是往 thems 目录下添加了一个主题，而 .gitmodules 则是记录了添加的这个主题的模块的信息，\n然后，我们可以再看 PaperMod 这个主题里面都有些什么文件，从下面的命令的输出可以看到，基本上就是一些 html、css 和 js 文件，毕竟是主题嘛，\n1❯ tree .\\themes\\PaperMod\\ /f 2Folder PATH listing for volume Windows 3Volume serial number is B867-6B94 4C:\\HDISK\\HUGO\\SONNYCALCR\\THEMES\\PAPERMOD 5│ go.mod 6│ LICENSE 7│ README.md 8│ theme.toml 9│ 10├───.github 11│ │ PULL_REQUEST_TEMPLATE.md 12│ │ 13│ ├───ISSUE_TEMPLATE 14│ │ bug_report.md 15│ │ config.yml 16│ │ proposal.md 17│ │ 18│ └───workflows 19│ gh-pages.yml 20│ 21├───assets 22│ ├───css 23│ │ ├───common 24│ │ │ 404.css 25│ │ │ archive.css 26│ │ │ footer.css 27│ │ │ header.css 28│ │ │ main.css 29│ │ │ post-entry.css 30│ │ │ post-single.css 31│ │ │ profile-mode.css 32│ │ │ search.css 33│ │ │ terms.css 34│ │ │ 35│ │ ├───core 36│ │ │ license.css 37│ │ │ reset.css 38│ │ │ theme-vars.css 39│ │ │ zmedia.css 40│ │ │ 41│ │ ├───extended 42│ │ │ blank.css 43│ │ │ 44│ │ └───includes 45│ │ chroma-mod.css 46│ │ chroma-styles.css 47│ │ scroll-bar.css 48│ │ 49│ └───js 50│ fastsearch.js 51│ fuse.basic.min.js 52│ license.js 53│ 54├───i18n 55│ ar.yaml 56│ be.yaml 57│ bg.yaml 58│ bn.yaml 59│ ca.yaml 60│ ckb.yaml 61│ cs.yaml 62│ da.yaml 63│ de.yaml 64│ el.yaml 65│ en.yaml 66│ eo.yaml 67│ es.yaml 68│ fa.yaml 69│ fr.yaml 70│ he.yaml 71│ hi.yaml 72│ hr.yaml 73│ hu.yaml 74│ id.yaml 75│ it.yaml 76│ ja.yaml 77│ ko.yaml 78│ ku.yaml 79│ mn.yaml 80│ ms.yaml 81│ nl.yaml 82│ no.yaml 83│ oc.yaml 84│ pa.yaml 85│ pl.yaml 86│ pnb.yaml 87│ pt.yaml 88│ ro.yaml 89│ ru.yaml 90│ sk.yaml 91│ sv.yaml 92│ sw.yaml 93│ th.yaml 94│ tr.yaml 95│ uk.yaml 96│ uz.yaml 97│ vi.yaml 98│ zh-tw.yaml 99│ zh.yaml 100│ 101├───images 102│ screenshot.png 103│ tn.png 104│ 105└───layouts 106 │ 404.html 107 │ robots.txt 108 │ 109 ├───partials 110 │ │ anchored_headings.html 111 │ │ author.html 112 │ │ breadcrumbs.html 113 │ │ comments.html 114 │ │ cover.html 115 │ │ edit_post.html 116 │ │ extend_footer.html 117 │ │ extend_head.html 118 │ │ footer.html 119 │ │ head.html 120 │ │ header.html 121 │ │ home_info.html 122 │ │ index_profile.html 123 │ │ post_canonical.html 124 │ │ post_meta.html 125 │ │ post_nav_links.html 126 │ │ share_icons.html 127 │ │ social_icons.html 128 │ │ svg.html 129 │ │ toc.html 130 │ │ translation_list.html 131 │ │ 132 │ └───templates 133 │ │ opengraph.html 134 │ │ schema_json.html 135 │ │ twitter_cards.html 136 │ │ 137 │ └───_funcs 138 │ get-page-images.html 139 │ 140 ├───shortcodes 141 │ collapse.html 142 │ figure.html 143 │ inTextImg.html 144 │ ltr.html 145 │ rawhtml.html 146 │ rtl.html 147 │ 148 └───_default 149 │ archives.html 150 │ baseof.html 151 │ index.json 152 │ list.html 153 │ rss.xml 154 │ search.html 155 │ single.html 156 │ terms.html 157 │ 158 └───_markup 159 render-image.html 然后，可以添加一下 .gitignore 文件，我这里就直接照抄 PaperMod 的作者部署的那个网站的文件了，\n1# Compiled Object files, Static and Dynamic libs (Shared Objects) 2*.o 3*.a 4*.so 5 6# Folders 7_obj 8_test 9 10# Architecture specific extensions/prefixes 11*.[568vq] 12[568vq].out 13 14*.cgo1.go 15*.cgo2.c 16_cgo_defun.c 17_cgo_gotypes.go 18_cgo_export.* 19 20_testmain.go 21 22*.exe 23*.test 24 25/public 26.DS_Store 27.hugo_build.lock 28resources/_gen/ 其实这里主要就是把 public 目录给排除掉，这个会在网页部署的时候自动生成。\n接下来就是正式的主题配置了。\n配置 PaperMod 主题 配置好之后相较于默认效果的一些改进 支持 giscus 进行评论，且主题支持明暗切换。 支持 mathjax，但是如果数学块公式中有超过三个花括号，那么，需要将整个数学公式包括外围的 $$ 符号都用 div 标签包裹起来。 代码字体自定义为 Jetbrains Mono。代码的亮色主题为 tokyo-night-light，暗色主题为 github-dark。 移动端隐藏返回顶部的按钮。 一些自定义 css 的效果，如字体大小、链接颜色、目录上的悬浮的鼠标图标等等。 主要就是上面几点，因为文档写得不详细，所以配置上面的内容花费了一些时间和工夫。\n一些基本信息的配置 首先，把博客根目录下的 hugo.toml 文件改成 hugo.yaml，因为 PaperMod 给出的配置文件就是 yaml 格式的，所以，这里改一下文件格式，就省去了我们再去将 yaml 的配置内容转为 toml 的麻烦，\n1Rename-Item .\\hugo.toml hugo.yaml 然后，配置一下基本信息，基本上每一个选项我都打上了注释，\n1baseURL: \u0026#34;https://sonnycalcr.github.io/\u0026#34; # 主站的 URL 2title: SonnyCalcr\u0026#39;s Blog # 站点标题 3copyright: \u0026#34;[©2024 SonnyCalcr\u0026#39;s Blog](https://sonnycalcr.github.io/)\u0026#34; # 网站的版权声明，通常显示在页脚 4theme: PaperMod # 主题 5languageCode: zh-cn # 语言 6 7enableInlineShortcodes: true # shortcode，类似于模板变量，可以在写 markdown 的时候便捷地插入，官方文档中有一个视频讲的很通俗 8hasCJKLanguage: true # 是否有 CJK 的字符 9enableRobotsTXT: true # 允许生成 robots.txt 10buildDrafts: false # 构建时是否包括草稿 11buildFuture: false # 构建未来发布的内容 12buildExpired: false # 构建过期的内容 13enableEmoji: true # 允许 emoji 14pygmentsUseClasses: true 15defaultContentLanguage: zh # 顶部首先展示的语言界面 16defaultContentLanguageInSubdir: false # 是否要在地址栏加上默认的语言代码 配置导航栏 1languages: 2 zh: 3 languageName: \u0026#34;中文\u0026#34; # 展示的语言名 4 weight: 1 # 权重 5 taxonomies: # 分类系统 6 category: categories 7 tag: tags 8 # https://gohugo.io/content-management/menus/#define-in-site-configuration 9 menus: 10 main: 11 - name: 首页 12 pageRef: / 13 weight: 4 # 控制在页面上展示的前后顺序 14 - name: 归档 15 pageRef: archives/ 16 weight: 5 17 - name: 分类 18 pageRef: categories/ 19 weight: 10 20 - name: 标签 21 pageRef: tags/ 22 weight: 10 23 - name: 搜索 24 pageRef: search/ 25 weight: 20 26 - name: 关于 27 pageRef: about/ 28 weight: 21 配置归档 在 content 目录下新建 archives.md 文件，内容如下，\n1--- 2title: \u0026#34;归档\u0026#34; 3layout: \u0026#34;archives\u0026#34; 4url: \u0026#34;/archives/\u0026#34; 5summary: archives 6--- 配置分类和标签 在 hugo 中，这俩是一样的。上面配置好了 taxonomies 之后，我们在博客的 front matter 中加上相关信息即可，就拿本篇博客举例，\n1title = \u0026#39;Hugo + PaperMod + Github Pages 搭建一个完善的个人博客(以 Windows11 为例)\u0026#39; 2date = 2024-08-04T03:25:53+08:00 3categories = [\u0026#34;通用技术\u0026#34;] 4tags = [\u0026#34;博客搭建\u0026#34;, \u0026#34;Bilibili\u0026#34;] 然后执行一下 hugo server 就可以在浏览器中预览一下效果了。\n配置搜索 要在 output 中加上 JSON，\n1# https://github.com/adityatelange/hugo-PaperMod/wiki/Features#search-page 2outputs: 3 home: 4 - HTML # 生成的静态页面 5 - RSS # 这个其实无所谓 6 - JSON # necessary for search, 这里的配置修改好之后，一定要重新生成一下 然后，在 content 目录下新建一个 search.md 文件，\n1--- 2title: \u0026#34;搜索\u0026#34; # in any language you want 3layout: \u0026#34;search\u0026#34; # necessary for search 4summary: \u0026#34;search\u0026#34; 5placeholder: \u0026#34;搜索\u0026#34; 6--- 然后是搜索的一些个性化设置，\n1params: 2 # 搜索 3 fuseOpts: 4 isCaseSensitive: false # 是否大小写敏感 5 shouldSort: true # 是否排序 6 location: 0 7 distance: 1000 8 threshold: 0.4 9 minMatchCharLength: 0 10 # limit: 10 # refer: https://www.fusejs.io/api/methods.html#search 11 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] 12 includeMatches: true 这样以来，搜索就可以正常工作了，\n配置关于页面 新建两个文件，一个是 layouts\\_default 目录下下的 about.html，\n1{{- define \u0026#34;main\u0026#34; }} 2 3\u0026lt;header class=\u0026#34;page-header\u0026#34;\u0026gt; 4 \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; 5 {{- if .Description }} 6 \u0026lt;div class=\u0026#34;post-description\u0026#34;\u0026gt; 7 {{ .Description }} 8 \u0026lt;/div\u0026gt; 9 {{- end }} 10 \u0026lt;/header\u0026gt; 11 12\u0026lt;section\u0026gt; 13 \u0026lt;br\u0026gt; 14 {{ .Content }} 15\u0026lt;/section\u0026gt; 16 17{{- end }}{{/* end main */}} 另一个是 content 目录下的 about.md,\n1--- 2title: \u0026#34;关于\u0026#34; 3layout: \u0026#34;about\u0026#34; 4url: \u0026#34;/about/\u0026#34; 5summary: about 6--- 7 8这里就可以写一些关于的相关信息了。 配置评论 这里的评论使用了 giscus 插件。\n先在 layouts\\partials 下新建一个 comments.html 文件，\n1\u0026lt;div id=\u0026#34;tw-comment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 2\u0026lt;script\u0026gt; 3 // 默认是暗色，根目录下的配置中的主题默认也是暗色 4 const getStoredTheme = () =\u0026gt; localStorage.getItem(\u0026#34;pref-theme\u0026#34;) === \u0026#34;light\u0026#34; ? \u0026#34;{{ .Site.Params.giscus.lightTheme }}\u0026#34; : \u0026#34;{{ .Site.Params.giscus.darkTheme }}\u0026#34;; 5 const setGiscusTheme = () =\u0026gt; { 6 const sendMessage = (message) =\u0026gt; { 7 const iframe = document.querySelector(\u0026#39;iframe.giscus-frame\u0026#39;); 8 if (iframe) { 9 iframe.contentWindow.postMessage({giscus: message}, \u0026#39;https://giscus.app\u0026#39;); 10 } 11 } 12 sendMessage({setConfig: {theme: getStoredTheme()}}) 13 } 14 15 document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { 16 const giscusAttributes = { 17 \u0026#34;src\u0026#34;: \u0026#34;https://giscus.app/client.js\u0026#34;, 18 \u0026#34;data-repo\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repo }}\u0026#34;, 19 \u0026#34;data-repo-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.repoId }}\u0026#34;, 20 \u0026#34;data-category\u0026#34;: \u0026#34;{{ .Site.Params.giscus.category }}\u0026#34;, 21 \u0026#34;data-category-id\u0026#34;: \u0026#34;{{ .Site.Params.giscus.categoryId }}\u0026#34;, 22 \u0026#34;data-mapping\u0026#34;: \u0026#34;{{ .Site.Params.giscus.mapping }}\u0026#34;, 23 \u0026#34;data-strict\u0026#34;: \u0026#34;{{ .Site.Params.giscus.strict }}\u0026#34;, 24 \u0026#34;data-reactions-enabled\u0026#34;: \u0026#34;{{ .Site.Params.giscus.reactionsEnabled }}\u0026#34;, 25 \u0026#34;data-emit-metadata\u0026#34;: \u0026#34;{{ .Site.Params.giscus.emitMetadata }}\u0026#34;, 26 \u0026#34;data-input-position\u0026#34;: \u0026#34;{{ .Site.Params.giscus.inputPosition }}\u0026#34;, 27 \u0026#34;data-theme\u0026#34;: getStoredTheme(), 28 \u0026#34;data-lang\u0026#34;: \u0026#34;{{ .Site.Params.giscus.lang }}\u0026#34;, 29 \u0026#34;data-loading\u0026#34;: \u0026#34;lazy\u0026#34;, 30 \u0026#34;crossorigin\u0026#34;: \u0026#34;anonymous\u0026#34;, 31 }; 32 33 // 动态创建 giscus script 34 const giscusScript = document.createElement(\u0026#34;script\u0026#34;); 35 Object.entries(giscusAttributes).forEach( 36 ([key, value]) =\u0026gt; giscusScript.setAttribute(key, value)); 37 document.querySelector(\u0026#34;#tw-comment\u0026#34;).appendChild(giscusScript); 38 39 // 页面主题变更后，变更 giscus 主题 40 const themeSwitcher = document.querySelector(\u0026#34;#theme-toggle\u0026#34;); 41 if (themeSwitcher) { 42 themeSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); 43 } 44 const themeFloatSwitcher = document.querySelector(\u0026#34;#theme-toggle-float\u0026#34;); 45 if (themeFloatSwitcher) { 46 themeFloatSwitcher.addEventListener(\u0026#34;click\u0026#34;, setGiscusTheme); 47 } 48 }); 49\u0026lt;/script\u0026gt; 然后，根据 giscus 官网的指导，最后生成一份代码，\n然后，把相应的字段提取到配置中，\n1params: 2 # 评论的设置 3 giscus: 4 repo: \u0026#34;sonnycalcr/sonnycalcr.github.io\u0026#34; 5 repoId: \u0026#34;xxxxxx\u0026#34; 6 category: \u0026#34;Announcements\u0026#34; 7 categoryId: \u0026#34;xxxxx\u0026#34; 8 mapping: \u0026#34;pathname\u0026#34; 9 strict: \u0026#34;0\u0026#34; 10 reactionsEnabled: \u0026#34;1\u0026#34; 11 emitMetadata: \u0026#34;0\u0026#34; 12 inputPosition: \u0026#34;bottom\u0026#34; 13 lightTheme: \u0026#34;light\u0026#34; 14 darkTheme: \u0026#34;dark\u0026#34; 15 lang: \u0026#34;zh-CN\u0026#34; 16 crossorigin: \u0026#34;anonymous\u0026#34; 这样就可以正常使用了。\n配置数学公式 这里使用的是 mathjax。\n我们需要添加两个文件，一个是 layouts\\partials 下的 mathjax.html 文件，如下，\n1\u0026lt;script type=\u0026#34;text/javascript\u0026#34; 2 async 3 src=\u0026#34;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; 4MathJax.Hub.Config({ 5 tex2jax: { 6 inlineMath: [[\u0026#39;$\u0026#39;,\u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;,\u0026#39;\\\\)\u0026#39;]], 7 displayMath: [[\u0026#39;$$\u0026#39;,\u0026#39;$$\u0026#39;], [\u0026#39;\\[\\[\u0026#39;,\u0026#39;\\]\\]\u0026#39;]], 8 processEscapes: true, 9 processEnvironments: true, 10 skipTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;], 11 TeX: { equationNumbers: { autoNumber: \u0026#34;AMS\u0026#34; }, 12 extensions: [\u0026#34;AMSmath.js\u0026#34;, \u0026#34;AMSsymbols.js\u0026#34;] } 13 } 14}); 15 16MathJax.Hub.Queue(function() { 17 // Fix \u0026lt;code\u0026gt; tags after MathJax finishes running. This is a 18 // hack to overcome a shortcoming of Markdown. Discussion at 19 // https://github.com/mojombo/jekyll/issues/199 20 var all = MathJax.Hub.getAllJax(), i; 21 for(i = 0; i \u0026lt; all.length; i += 1) { 22 all[i].SourceElement().parentNode.className += \u0026#39; has-jax\u0026#39;; 23 } 24}); 25\u0026lt;/script\u0026gt; 26 27\u0026lt;style\u0026gt; 28code.has-jax { 29 font: inherit; 30 font-size: 100%; 31 background: inherit; 32 border: inherit; 33 color: #515151; 34} 35\u0026lt;/style\u0026gt; 另一个是 layouts\\partials 下的 extend_head.html 文件，\n1{{- /* Head custom content area start */ -}} 2{{- /* Insert any custom code (web-analytics, resources, etc.) - it will appear in the \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; section of every page. */ -}} 3{{- /* Can be overwritten by partial with the same name in the global layouts. */ -}} 4{{ partial \u0026#34;mathjax.html\u0026#34; . }} 5{{- /* Head custom content area end */ -}} 到这里，数学公式就可以正常使用了，我们来写一点数学公式试一下，\n1行内数学公式：$a^2 + b^2 = c^2$。 2 3块公式， 4 5$$ 6a^2 + b^2 = c^2 7$$ 8 9\u0026lt;div\u0026gt; 10$$ 11\\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} 12$$ 13\u0026lt;/div\u0026gt; 渲染出来的效果如下，\n行内数学公式：$a^2 + b^2 = c^2$。\n块公式，\n$$ a^2 + b^2 = c^2 $$\n$$ \\boldsymbol{x}_{i+1}+\\boldsymbol{x}_{i+2}=\\boldsymbol{x}_{i+3} $$ 上面的第二个公式之所以要用 div 包裹起来，是因为这里的数学公式如果有超过了三对花括号，那么，其解析和转义就会出问题，这个和 hugo 有关目前折中的方案就是上面这种在外面套一层 div。\n给代码换个字体 先到谷歌字体 中找一款开源字体，我这里选用的是 Jetbrains Mono，然后复制其信息到 layouts\\partials\\extend_head.html 中，\n1\u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.googleapis.com\u0026#34;\u0026gt; 2\u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://fonts.gstatic.com\u0026#34; crossorigin\u0026gt; 3\u0026lt;link href=\u0026#34;https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800\u0026amp;display=swap\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 然后，新建一个 assets\\css\\extended\\blank.css 文件，添加样式如下，\n1.post-content pre, 2code { 3 font-family: \u0026#34;JetBrains Mono\u0026#34;, monospace; 4 font-size: 1rem; 5 line-height: 1.2; 6} 这样就可以生效了，如果发现不生效，可以重新执行一下 hugo server 试试。\n代码明暗样式切换 我这里使用的不是 highlightjs，而是 hugo 推荐的 chroma，这样的话，我们先建立一个 assets\\css\\extended\\chroma-styles-overrides.css 文件，\n然后，执行一下命令生成你想要的样式，\n1hugo gen chromastyles --style=tokyonight-day \u0026gt; syntax.css 然后，把 syntax.css 中的内容复制到 chroma-styles-overrides.html 文件中，如果是暗色主题，那么，生成的样式则要包裹在 .dark {} 里面，我这里生成了两个样式，白天的样式是 tokyonight-day，黑暗的样式是 github-dark，同时，要记得将生成的样式中有些空缺的部分给补上默认的颜色，我这里白天的颜色补的是黑色，夜晚的颜色补的是白色，不然代码的样式会出问题，我这里完整的样式如下，\n1/* Background */ .bg { color:#3760bf;background-color:#e1e2e7; } 2/* PreWrapper */ .chroma { color:#3760bf;background-color:#e1e2e7; } 3/* Other */ .chroma .x { color: #000 } 4/* Error */ .chroma .err { color:#c64343 } 5/* CodeLine */ .chroma .cl { color: #000 } 6/* LineLink */ .chroma .lnlinks { outline:none;text-decoration:none;color:inherit } 7/* LineTableTD */ .chroma .lntd { vertical-align:top;padding:0;margin:0;border:0; } 8/* LineTable */ .chroma .lntable { border-spacing:0;padding:0;margin:0;border:0; } 9/* LineHighlight */ .chroma .hl { background-color:#a1a6c5 } 10/* LineNumbersTable */ .chroma .lnt { white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6172b0 } 11/* LineNumbers */ .chroma .ln { white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6172b0 } 12/* Line */ .chroma .line { display:flex; } 13/* Keyword */ .chroma .k { color:#9854f1 } 14/* KeywordConstant */ .chroma .kc { color:#8c6c3e } 15/* KeywordDeclaration */ .chroma .kd { color:#9d7cd8 } 16/* KeywordNamespace */ .chroma .kn { color:#007197 } 17/* KeywordPseudo */ .chroma .kp { color:#9854f1 } 18/* KeywordReserved */ .chroma .kr { color:#9854f1 } 19/* KeywordType */ .chroma .kt { color:#0db9d7 } 20/* Name */ .chroma .n { color: #000 } 21/* NameAttribute */ .chroma .na { color:#2e7de9 } 22/* NameBuiltin */ .chroma .nb { color:#587539 } 23/* NameBuiltinPseudo */ .chroma .bp { color:#587539 } 24/* NameClass */ .chroma .nc { color:#b15c00 } 25/* NameConstant */ .chroma .no { color:#b15c00 } 26/* NameDecorator */ .chroma .nd { color:#2e7de9;font-weight:bold } 27/* NameEntity */ .chroma .ni { color:#007197 } 28/* NameException */ .chroma .ne { color:#8c6c3e } 29/* NameFunction */ .chroma .nf { color:#2e7de9 } 30/* NameFunctionMagic */ .chroma .fm { color:#2e7de9 } 31/* NameLabel */ .chroma .nl { color:#587539 } 32/* NameNamespace */ .chroma .nn { color:#8c6c3e } 33/* NameOther */ .chroma .nx { color: #000 } 34/* NameProperty */ .chroma .py { color:#8c6c3e } 35/* NameTag */ .chroma .nt { color:#9854f1 } 36/* NameVariable */ .chroma .nv { color: #000 } 37/* NameVariableClass */ .chroma .vc { color: #000 } 38/* NameVariableGlobal */ .chroma .vg { color: #000 } 39/* NameVariableInstance */ .chroma .vi { color: #000 } 40/* NameVariableMagic */ .chroma .vm { color: #000 } 41/* Literal */ .chroma .l { color: #000 } 42/* LiteralDate */ .chroma .ld { color: #000 } 43/* LiteralString */ .chroma .s { color:#587539 } 44/* LiteralStringAffix */ .chroma .sa { color:#9d7cd8 } 45/* LiteralStringBacktick */ .chroma .sb { color:#587539 } 46/* LiteralStringChar */ .chroma .sc { color:#587539 } 47/* LiteralStringDelimiter */ .chroma .dl { color:#2e7de9 } 48/* LiteralStringDoc */ .chroma .sd { color:#a1a6c5 } 49/* LiteralStringDouble */ .chroma .s2 { color:#587539 } 50/* LiteralStringEscape */ .chroma .se { color:#2e7de9 } 51/* LiteralStringHeredoc */ .chroma .sh { color:#a1a6c5 } 52/* LiteralStringInterpol */ .chroma .si { color:#587539 } 53/* LiteralStringOther */ .chroma .sx { color:#587539 } 54/* LiteralStringRegex */ .chroma .sr { color:#007197 } 55/* LiteralStringSingle */ .chroma .s1 { color:#587539 } 56/* LiteralStringSymbol */ .chroma .ss { color:#587539 } 57/* LiteralNumber */ .chroma .m { color:#8c6c3e } 58/* LiteralNumberBin */ .chroma .mb { color:#8c6c3e } 59/* LiteralNumberFloat */ .chroma .mf { color:#8c6c3e } 60/* LiteralNumberHex */ .chroma .mh { color:#8c6c3e } 61/* LiteralNumberInteger */ .chroma .mi { color:#8c6c3e } 62/* LiteralNumberIntegerLong */ .chroma .il { color:#8c6c3e } 63/* LiteralNumberOct */ .chroma .mo { color:#8c6c3e } 64/* Operator */ .chroma .o { color:#587539;font-weight:bold } 65/* OperatorWord */ .chroma .ow { color:#587539;font-weight:bold } 66/* Punctuation */ .chroma .p { color: #000 } 67/* Comment */ .chroma .c { color:#a1a6c5;font-style:italic } 68/* CommentHashbang */ .chroma .ch { color:#a1a6c5;font-style:italic } 69/* CommentMultiline */ .chroma .cm { color:#a1a6c5;font-style:italic } 70/* CommentSingle */ .chroma .c1 { color:#a1a6c5;font-style:italic } 71/* CommentSpecial */ .chroma .cs { color:#a1a6c5;font-style:italic } 72/* CommentPreproc */ .chroma .cp { color:#a1a6c5;font-style:italic } 73/* CommentPreprocFile */ .chroma .cpf { color:#a1a6c5;font-weight:bold;font-style:italic } 74/* Generic */ .chroma .g { color: #000 } 75/* GenericDeleted */ .chroma .gd { color:#c64343;background-color:#e9e9ed } 76/* GenericEmph */ .chroma .ge { font-style:italic } 77/* GenericError */ .chroma .gr { color:#c64343 } 78/* GenericHeading */ .chroma .gh { color:#8c6c3e;font-weight:bold } 79/* GenericInserted */ .chroma .gi { color:#587539;background-color:#e9e9ed } 80/* GenericOutput */ .chroma .go { color: #000 } 81/* GenericPrompt */ .chroma .gp { color: #000 } 82/* GenericStrong */ .chroma .gs { font-weight:bold } 83/* GenericSubheading */ .chroma .gu { color:#8c6c3e;font-weight:bold } 84/* GenericTraceback */ .chroma .gt { color:#c64343 } 85/* GenericUnderline */ .chroma .gl { text-decoration:underline } 86/* TextWhitespace */ .chroma .w { color: #000 } 87 88.dark { 89 /* Background */ .bg { color:#e6edf3;background-color:#0d1117; } 90 /* PreWrapper */ .chroma { color:#e6edf3;background-color:#0d1117; } 91 /* Other */ .chroma .x { color: #fff } 92 /* Error */ .chroma .err { color:#f85149 } 93 /* CodeLine */ .chroma .cl { color: #fff } 94 /* LineLink */ .chroma .lnlinks { outline:none;text-decoration:none;color:inherit } 95 /* LineTableTD */ .chroma .lntd { vertical-align:top;padding:0;margin:0;border:0; } 96 /* LineTable */ .chroma .lntable { border-spacing:0;padding:0;margin:0;border:0; } 97 /* LineHighlight */ .chroma .hl { background-color:#6e7681 } 98 /* LineNumbersTable */ .chroma .lnt { white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#737679 } 99 /* LineNumbers */ .chroma .ln { white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#6e7681 } 100 /* Line */ .chroma .line { display:flex; } 101 /* Keyword */ .chroma .k { color:#ff7b72 } 102 /* KeywordConstant */ .chroma .kc { color:#79c0ff } 103 /* KeywordDeclaration */ .chroma .kd { color:#ff7b72 } 104 /* KeywordNamespace */ .chroma .kn { color:#ff7b72 } 105 /* KeywordPseudo */ .chroma .kp { color:#79c0ff } 106 /* KeywordReserved */ .chroma .kr { color:#ff7b72 } 107 /* KeywordType */ .chroma .kt { color:#ff7b72 } 108 /* Name */ .chroma .n { color: #fff } 109 /* NameAttribute */ .chroma .na { color: #fff } 110 /* NameBuiltin */ .chroma .nb { color: #fff } 111 /* NameBuiltinPseudo */ .chroma .bp { color: #fff } 112 /* NameClass */ .chroma .nc { color:#f0883e;font-weight:bold } 113 /* NameConstant */ .chroma .no { color:#79c0ff;font-weight:bold } 114 /* NameDecorator */ .chroma .nd { color:#d2a8ff;font-weight:bold } 115 /* NameEntity */ .chroma .ni { color:#ffa657 } 116 /* NameException */ .chroma .ne { color:#f0883e;font-weight:bold } 117 /* NameFunction */ .chroma .nf { color:#d2a8ff;font-weight:bold } 118 /* NameFunctionMagic */ .chroma .fm { color: #fff } 119 /* NameLabel */ .chroma .nl { color:#79c0ff;font-weight:bold } 120 /* NameNamespace */ .chroma .nn { color:#ff7b72 } 121 /* NameOther */ .chroma .nx { color: #fff } 122 /* NameProperty */ .chroma .py { color:#79c0ff } 123 /* NameTag */ .chroma .nt { color:#7ee787 } 124 /* NameVariable */ .chroma .nv { color:#79c0ff } 125 /* NameVariableClass */ .chroma .vc { color: #fff } 126 /* NameVariableGlobal */ .chroma .vg { color: #fff } 127 /* NameVariableInstance */ .chroma .vi { color: #fff } 128 /* NameVariableMagic */ .chroma .vm { color: #fff } 129 /* Literal */ .chroma .l { color:#a5d6ff } 130 /* LiteralDate */ .chroma .ld { color:#79c0ff } 131 /* LiteralString */ .chroma .s { color:#a5d6ff } 132 /* LiteralStringAffix */ .chroma .sa { color:#79c0ff } 133 /* LiteralStringBacktick */ .chroma .sb { color:#a5d6ff } 134 /* LiteralStringChar */ .chroma .sc { color:#a5d6ff } 135 /* LiteralStringDelimiter */ .chroma .dl { color:#79c0ff } 136 /* LiteralStringDoc */ .chroma .sd { color:#a5d6ff } 137 /* LiteralStringDouble */ .chroma .s2 { color:#a5d6ff } 138 /* LiteralStringEscape */ .chroma .se { color:#79c0ff } 139 /* LiteralStringHeredoc */ .chroma .sh { color:#79c0ff } 140 /* LiteralStringInterpol */ .chroma .si { color:#a5d6ff } 141 /* LiteralStringOther */ .chroma .sx { color:#a5d6ff } 142 /* LiteralStringRegex */ .chroma .sr { color:#79c0ff } 143 /* LiteralStringSingle */ .chroma .s1 { color:#a5d6ff } 144 /* LiteralStringSymbol */ .chroma .ss { color:#a5d6ff } 145 /* LiteralNumber */ .chroma .m { color:#a5d6ff } 146 /* LiteralNumberBin */ .chroma .mb { color:#a5d6ff } 147 /* LiteralNumberFloat */ .chroma .mf { color:#a5d6ff } 148 /* LiteralNumberHex */ .chroma .mh { color:#a5d6ff } 149 /* LiteralNumberInteger */ .chroma .mi { color:#a5d6ff } 150 /* LiteralNumberIntegerLong */ .chroma .il { color:#a5d6ff } 151 /* LiteralNumberOct */ .chroma .mo { color:#a5d6ff } 152 /* Operator */ .chroma .o { color:#ff7b72;font-weight:bold } 153 /* OperatorWord */ .chroma .ow { color:#ff7b72;font-weight:bold } 154 /* Punctuation */ .chroma .p { color: #fff } 155 /* Comment */ .chroma .c { color:#8b949e;font-style:italic } 156 /* CommentHashbang */ .chroma .ch { color:#8b949e;font-style:italic } 157 /* CommentMultiline */ .chroma .cm { color:#8b949e;font-style:italic } 158 /* CommentSingle */ .chroma .c1 { color:#8b949e;font-style:italic } 159 /* CommentSpecial */ .chroma .cs { color:#8b949e;font-weight:bold;font-style:italic } 160 /* CommentPreproc */ .chroma .cp { color:#8b949e;font-weight:bold;font-style:italic } 161 /* CommentPreprocFile */ .chroma .cpf { color:#8b949e;font-weight:bold;font-style:italic } 162 /* Generic */ .chroma .g { color: #fff } 163 /* GenericDeleted */ .chroma .gd { color:#ffa198;background-color:#490202 } 164 /* GenericEmph */ .chroma .ge { font-style:italic } 165 /* GenericError */ .chroma .gr { color:#ffa198 } 166 /* GenericHeading */ .chroma .gh { color:#79c0ff;font-weight:bold } 167 /* GenericInserted */ .chroma .gi { color:#56d364;background-color:#0f5323 } 168 /* GenericOutput */ .chroma .go { color:#8b949e } 169 /* GenericPrompt */ .chroma .gp { color:#8b949e } 170 /* GenericStrong */ .chroma .gs { font-weight:bold } 171 /* GenericSubheading */ .chroma .gu { color:#79c0ff } 172 /* GenericTraceback */ .chroma .gt { color:#ff7b72 } 173 /* GenericUnderline */ .chroma .gl { text-decoration:underline } 174 /* TextWhitespace */ .chroma .w { color:#6e7681 } 175} 我在上面提到的生成的样式中空缺的部分，可以看一下下面的样例，\n要记得把他们的颜色都补上。\n然后，修改一下配置即可，\n1params: 2 assets: 3 disableHLJS: true 4markup: 5 goldmark: 6 renderer: 7 unsafe: true # 可以 unsafe，有些 html 标签和样式可能需要 8 highlight: 9 anchorLineNos: false # 不要给行号设置锚标 10 codeFences: true # 代码围栏 11 noClasses: false # TODO: 不知道干啥的，暂时没必要了解，不影响展示 12 lineNos: true # 代码行 13 lineNumbersInTable: false # 不要设置成 true，否则如果文章开头是代码的话，摘要会由一大堆数字(即代码行号)开头文章 14 # 这里设置 style 没用，得自己加 css 15 # style: \u0026#34;github-dark\u0026#34; 16 # style: monokai 修改网页的 favicon 先到 flaticon 网站中找一个 icon 图片，然后放到 static 目录下，\n然后，修改配置，\n1params: 2 # 设置网站的标签页的图标，即 favicon 3 assets: 4 favicon: \u0026#34;favicon.png\u0026#34; 5 favicon16x16: \u0026#34;favicon.png\u0026#34; 6 favicon32x32: \u0026#34;favicon.png\u0026#34; 7 apple_touch_icon: \u0026#34;favicon.png\u0026#34; 8 safari_pinned_tab: \u0026#34;favicon.png\u0026#34; 其他一些小的样式修改 这个就直接看我的代码仓库就可以了，修改的基本都是 css，代码都在 assets 目录下，\n部署到 Github Pages 这里其实有两种方式，一种是直接建立一个以 username.github.io 为名的 Github 仓库，然后，进行部署，另一种是在此基础上新建一个普通的项目，然后可以挂到 username.github.io 域名的后面。\n我们这里就选用简单的第一种比较直接的方式。\n新建一个仓库，没有什么好说的，然后把我们当前的这个仓库和远程仓库关联起来，然后推送过去。然后按照 Hugo 的文档指导来操作即可。\n对于官方给出的 .github/workflows/hugo.yaml， 把其中的分支名改一下即可，或者同时把其中的 Hugo 的版本信息改成和本地的一致也可以。之后，每次推送就可以看到 Github 在部署了。\n一些常用的 Hugo 命令 其实可能只有两个需要我们去记忆或者说熟悉，\nhugo new content content/posts/xxxxx.md hugo server 一些不足 PaperMod 的搜索十分简陋。但是，问题倒也不大。从好的方面来讲，该分享的内容是不影响分享的，而且，正式因为搜索不太好用，所以对个人的隐私可能反而会友好一点。\n附录 参考：\nhttps://pengfeixc.com/blogs/developer-handbook/git-submodules 添加 About 页面 修改字体 https://developer.mozilla.org/en-US/docs/Web/CSS/cursor https://cursor.in/ https://github.com/francoischalifour/medium-zoom https://shaohanyun.top/posts/env/hugo_mathjax/ ","permalink":"http://localhost:1313/posts/build-a-blog-using-hugo-papermod-github-pages/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e之前四五年的时间里也算写过五六百篇博客。以前的 Hexo 顶不住博客数量的压力了，所以，切到 Hugo 试一下。\u003c/p\u003e\n\u003ch3 id=\"涉及工具\"\u003e涉及工具\u003c/h3\u003e\n\u003cp\u003e除了搭建博客和介绍如何使用这个博客框架这样一个流程本身，还包含了对 PaperMod 这个主题的一些细节的定制。\u003c/p\u003e","title":"Hugo + PaperMod + Github Pages 搭建一个完善的个人博客(以 Windows11 为例)"},{"content":"\n正在尝试一种自由的生活。\n自由的生活，也是独居的生活。幽居于楚地的一隅。\n困的时候睡，睡够了然后醒。饿了的时候做饭、吃饭。不饿的时候看书、听歌、写一点无聊的东西。身体康健的时候锻炼，微恙的时候蛰伏。\n过往的生活大致说得过去。没有心理问题，没有身体问题，没有原生家庭问题等等。读过一个还算不错的大学，在一个还算不错的公司短暂地上过班。\n最后，我有一个朋友。\n","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"}]